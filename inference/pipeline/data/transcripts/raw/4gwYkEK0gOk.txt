second,duration,transcript
0.24,3.52,assembly a low-level programming
2.159,4.16,language designed to simplify the
3.76,4.24,instructions fed into a computer's cpu
6.319,3.681,in other words it's a human-readable
8.0,3.759,abstraction on top of machine code so
10.0,3.44,programmers don't have to manually count
11.759,3.76,ones and zeroes the first assembly
13.44,4.8,language was created by kathleen booth
15.519,4.801,in 1947 for the all-purpose electronic
18.24,4.08,computer over the next decade it evolved
20.32,4.16,into many different formats to power the
22.32,4.48,super computers of the day like the ibm
24.48,4.4,7090 which had a 20 million dollar price
26.8,3.52,tag in today's dollars writing code and
28.88,3.28,assembly was standard until the
30.32,4.079,emergence of high level languages like
32.16,4.32,fortran a few years later however
34.399,4.0,assembly is still used today for direct
36.48,3.759,access to the bare metal hardware and to
38.399,3.761,address low-level performance issues
40.239,3.601,often on device drivers and embedded
42.16,3.12,systems and it's also used to run native
43.84,3.44,software in a web browser via
45.28,3.84,webassembly what's tricky is that each
47.28,4.32,assembly language only works on a
49.12,5.119,specific cpu architecture like arm for
51.6,4.479,apple silicon and raspberry pi or x86
54.239,3.441,for intel chips to get started you'll
56.079,4.241,first need an assembler like the net
57.68,4.879,wide assembler for x86 chips an assembly
60.32,3.839,program is divided into three sections
62.559,3.6,the text section contains the actual
64.159,3.681,logic for the program by convention it
66.159,2.801,contains an entry point called start
67.84,2.88,which is where the code will start
68.96,3.44,executing next we have the block
70.72,3.04,starting symbol section which contains
72.4,3.359,variables that might change throughout
73.76,3.76,the lifecycle of the app and finally the
75.759,3.841,data section is where we can initialize
77.52,3.84,constants or data that does not change
79.6,3.76,to declare a constant like a string we
81.36,3.84,start with a label then use db for
83.36,3.84,defined byte to place the hello world
85.2,3.52,string into memory by itself it doesn't
87.2,3.36,do anything and to print it to the
88.72,3.68,standard output we will also need it to
90.56,3.84,length we can use equate to convert a
92.4,3.52,symbol into a constant the dollar sign
94.4,3.28,will subtract the current position from
95.92,3.199,the hello label providing the length of
97.68,2.96,the string and now these constants can
99.119,2.96,be referenced from the start label in
100.64,3.28,the main program each line of code
102.079,3.521,contains an instruction along with one
103.92,3.519,or more operands and there are hundreds
105.6,3.68,of instructions built into the language
107.439,4.081,now to perform operations quickly the
109.28,4.4,cpu has a limited number of registers
111.52,4.239,which are like 64-bit chunks of memory
113.68,3.68,built directly into the cpu instead of
115.759,3.521,the ram we can insert data into a
117.36,3.92,register with the move instruction by
119.28,3.839,providing operands for the register name
121.28,3.04,and the data to store there in this case
123.119,3.441,number one is used because it
124.32,3.999,corresponds to system write on linux
126.56,3.6,next we need to tell the system where to
128.319,4.081,write in which case we'll move one into
130.16,3.92,the rdi register which corresponds to
132.4,3.28,the standard output in the terminal the
134.08,3.44,next register stores the message to
135.68,3.84,right along with its length now execute
137.52,4.0,the code stored in the cpu by calling
139.52,3.6,the operating system kernel almost done
141.52,3.04,but we'll get a segmentation fault if we
143.12,3.68,try to run it at this point update the
144.56,3.759,racks register with 60 for system exit
146.8,3.68,and provide an error code of zero for a
148.319,4.0,success now use the assembler to compile
150.48,3.6,or assemble your code into an object
152.319,3.441,file then use the linker to convert it
154.08,3.84,into the final executable this has been
155.76,3.6,assembly language in 100 seconds if you
157.92,3.28,want to see more short videos like this
159.36,3.599,hit the like button and subscribe thanks
161.2,4.48,for watching and i will see you in the
162.959,2.721,next one
