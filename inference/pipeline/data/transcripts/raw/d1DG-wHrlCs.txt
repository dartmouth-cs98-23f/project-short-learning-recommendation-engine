second,duration,transcript
55.46,7.989,"We have discussed a very simple form of processor
design called single cycle design and in the"
63.449,6.06,"last lecture we ended by making some observation
about such a design. These observations were"
69.509,7.961,"about its performance and inability does certain
kind of instruction. So today we will introduce"
77.47,7.0,"another type of approach called multi cycle
design which tries to overcome these problems."
84.47,8.25,"This is the overall lecture plan and today
we will start by repeating those problems"
92.72,6.64,"re-observing those problems which are related
to single cycle data path. We will look at"
99.36,5.819,"how, we analyze the delays and what for the
difficulty which is noticed. We will see how"
105.179,8.141,"clock period can be improved; how clock could
be speeded up by using multi cycle design."
113.32,5.75,"We will also look at this as a way of improving
the resource utilization. The resources are"
119.07,7.132,"the main hardware components we have even
in our data path and what basically we will"
126.202,7.218,"do is we will try to share these components
such as memories and ALU and to facilitate"
133.42,5.71,"that we would need to introduced some more
components but often lower costs generally"
139.13,4.5,these are registers and multiplexers.
143.63,6.859,"This is the data path which was designed in
the previous lectures where every instruction"
150.489,9.601,"is completed in a single cycle. So all activities
begin with a new address in PC and the cycle"
160.09,6.78,"ends by updating the PC value as well as updating
the state of the whole processor in register"
166.87,7.959,"file and memory. So these are the three problems
which we have noticed that the slowest instruction"
174.829,4.261,"pulls down the clock frequency; if there is
a wide disparity in the timings of various"
179.09,8.269,"instructions then the whole set of instructions
will be running as slow as an instruction"
187.359,2.951,"so that is the difficulty with such a design
approach."
190.31,6.44,"And secondly, resource utilization is poor.
Apart from having a full fledge ALU we had"
196.75,6.5,"to use two adders and we had to keep the instruction
memory and data memory separate because in"
203.25,4.86,"that type of design it is not possible to
work with single memory from where you fetch"
208.11,5.95,"an instruction and then later on fetch data
also so that we will not work out."
214.06,5.459,"Also, I hinted upon some kind of instruction
which cannot be realized by this type of approach."
219.519,7.071,"So we will focus today on first two issues.
Just to recall that we had analyzed the performance"
226.59,5.889,"by taking the delays of individual components
some simple ones were assigned zero delay"
232.479,4.48,"and others had some significant delay denoted
by t plus t A and so on"
236.959,5.661,"these symbols are denoting the delays of individual
components."
242.62,7.0,"And for each instruction or a group of instruction
we enumerated various paths from storage element"
249.62,5.28,"to storage element through which the data
has to flow in the instruction and identified"
254.9,7.42,"the possible expressions which would decide
the overall clock period."
262.32,8.39,"So this was the final expression we had. The
one at the bottom is in a simplified form"
270.71,4.67,"and it could be noticed that the largest of
these sub-expressions will actually decide"
275.38,6.21,"the clock period. To illustrate this further
let us look at some values. Again I am not"
281.59,6.389,"putting these values in numeric sense but
trying to depict it pictorially; so the horizontal"
287.979,9.561,"x here is a time axis and for each instruction
I am trying to show the delays which are involved"
297.54,2.719,"in the flow of information along the data
path."
300.259,5.41,"For R class instruction there is a delay involved
in fetching the instruction, fetching the"
305.669,5.551,"operands from the register file then doing
the arithmetic operation and finally storing"
311.22,6.19,"the result in register file and so on for
each instruction I have indicated the possible"
317.41,8.86,"path which may dictate the clock period. So
I have taken nearly equal values for all these"
326.27,7.0,"terms except that there are slight differences;
t i and t M I have taken same and in fact"
333.27,7.23,"t plus is also same; t A is slightly less
than that and t R is even little less than"
340.5,1.02,that.
341.52,8.32,"So, from first three cases I have dropped
the t plus term because that is invariably"
349.84,7.79,"that is less than all these and we do not
really need to look at that. So now you can"
357.63,7.93,"very clearly see that lw with this kind of
values lw will dominate and dictate the clock"
365.56,4.62,"periods. So clock period would be from this
point to this point; remember that horizontal"
370.18,7.639,"axis is the time axis I am showing along the
time line. but once clock period is fixed"
377.819,4.28,"all instructions are taking same time and
you could see so much of dead time in other"
382.099,5.16,"instructions in R class, sw, in beq and most
in j."
387.259,9.761,"Now when we introduce multi cycle design basically
what we try to do is divide execution of instruction"
397.02,4.919,"into multiple cycles. So we need to decide
what gets done in first cycle, what gets done"
401.939,6.491,"in second cycle and so on and there are lots
of choices. So we will take one simple choice"
408.43,7.47,"here which tries to do one major action in
one clock cycle. This is only one of the possibilities"
415.9,9.34,"and what it means is that now looking at each
individual times we take max of these and"
425.24,6.019,"take that as a clock period. So in this case
t i, t M or t plus all are equivalent and"
431.259,5.91,"the largest among all so that decides the
clock period. The R class instruction now"
437.169,9.821,"gets done in four clocks: lw in 5, sw in 4,
beq in 3 and j in 1 so there are still small"
446.99,8.039,"dead times because of inequality because all
these times are not exactly equal there is"
455.029,7.031,"some differences. But you would notice that
the overall improvement in performance will"
462.06,5.419,"be there because the overall wastage in time
is much smaller."
467.479,8.111,"One more thing you must notice is that the
total time lw takes now is more than what"
475.59,5.51,"it was taking earlier. Earlier it was taking
one clock which was from here to here, now"
481.1,6.409,"it is taking five clocks which goes from here
to here. So because there is some wastage"
487.509,6.271,"of time here also but on the whole everything
put together this approach would still give"
493.78,2.65,you better performance or save time.
496.43,8.209,"Now things look quite here quite good here
because these different time parameters are"
504.639,5.671,"nearly balanced. I deliberately took these
values which are only slightly differing from"
510.31,7.23,"each other and therefore the wastage you see
is very little. But suppose there was a vast"
517.54,8.239,"disparity in this time we will be again having
a problem situation. For example, suppose"
525.779,6.56,"for some reason the adders which we had for
address calculation for branch and jump instruction"
532.339,5.731,"sorry not jump branch instruction and doing
PC plus 4 they were pretty slow."
538.07,5.6,"Let us say t plus becomes the bottleneck and
this will hold up the clock. So now clock"
543.67,9.46,"will get dictated by this time and we will
still follow the same approach; R instruction"
553.13,9.84,"takes four cycles, lw five cycles, sw four,
beq three and j single cycle. But now notice"
562.97,6.52,"that the clock period is larger and it has
to be sufficient to accommodate each of these"
569.49,6.89,"any of these individual activities. So t plus
is dominating and you would notice that now"
576.38,6.88,"even these instructions although they are
taking four cycles but they are taking longer"
583.26,2.95,"than what they were taking in the single cycle
approach."
586.21,6.62,"Of course lw was in any case taking longer
than a single cycle, sw is also taking longer"
592.83,7.29,"than single cycle and in beq there is a little
bit of saving there is of course still significant"
600.12,3.8,"saving in jump instruction
but there are very few jumps anyway in the"
603.92,8.82,"whole program. So if you add the cycle per
instruction CPI of all these now R has CPI"
612.74,8.1,"f 4 has 5 and so on we know the CPI of individual
instruction or class of instruction and we"
620.84,4.86,"have seen how we can calculate every CPI depending
upon the frequency of occurrence of certain"
625.7,7.82,"kind of instruction in a program you can find
an average. So, the total time a program would"
633.52,4.99,"take could in fact here be larger than what
it would take in a single cycle case."
638.51,8.59,"If there is an imbalance of this nature then
this approach the way we have implemented"
647.1,6.63,"multiple cycle design could be counterproductive.
So what can be done in such a case is we have"
653.73,8.6,"to do something so that there is a balance.
What we are doing in a clock cycle is uniformly"
662.33,6.82,"true uniformly same that means we identify
the activity to be performed within a clock"
669.15,7.63,"cycle which is generally balanced. it should
not happen that, for example, here in this"
676.78,6.371,"clock cycle we are doing little very little
and wasting lot of time whereas this cycle"
683.151,3.489,here is packed that is unbalanced.
686.64,5.2,"How to balance?
Possibilities are that you can have multiple"
691.84,5.36,"actions in a period. If there are two let
us say two actions which are taking very little"
697.2,6.69,"time you can do two in a clock. Earlier we
were doing a everything in a single clock"
703.89,6.43,"so that kind of idea could still be retained.
We need not say that one action in one clock"
710.32,7.61,"cycle although that is the simplest thing
but this may not be always very beneficial."
717.93,10.21,"Alternatively or in addition to this you could
have multiple periods for an action. For example,"
728.14,4.46,"it is not necessary that t plus if it is slow
has to be done this action has to be done"
732.6,4.75,"within a single clock. You might do everything
else in a single clock but may be reserve"
737.35,7.04,"two clocks for this so you might still have
an overall better performance."
744.39,5.5,"Now, once you bring this into picture the
number of possibilities becomes very large"
749.89,8.06,"and it is not a very straightforward solution
but the point here is that one could find"
757.95,9.88,"a suitable clock period so that the dead times
or the wastage of time which is due to quantization"
767.83,7.15,"of time by clock is minimized. So we will
not going into further details of that. We"
774.98,6.8,"will just resume that we have identified the
major actions for each instruction and each"
781.78,6.55,"can be put in one clock cycle. So we will
follow that approach keeping at the back of"
788.33,7.38,"our mind that there is a problem this is the
direction in which we need to look into."
795.71,3.4,"The second issue was improving the resource
utilization."
799.11,9.57,"Can we eliminate two adders? Can we just manage
with a single ALU; that is one question. In"
808.68,8.13,"general, how do we share resources across
cycles? You are using adder in one cycle to"
816.81,5.78,"do something, in another cycle you can do
something else with the same adder so the"
822.59,7.16,"solution lies in having the results of one
operation stored at the end of a cycle in"
829.75,7.46,"some register. You recall two designs of multiplier
we discussed two different types of design;"
837.21,8.68,"one was array multiplier where we had cascade
of adders with no storage in between and the"
845.89,4.19,"partial sum flew through flows through all
those adders."
850.08,7.25,"So now, as data flows through those you can
notice that each one is not getting fully"
857.33,4.12,"utilized each would be active and signals
are propagating through that to only part"
861.45,7.83,"of the duration. On the other hand, the sequential
multiplier we had we did something with the"
869.28,3.86,"adder, stored the results in register and
reused that adder again so the key thing is"
873.14,7.5,"that between two usages you have to store
one result so you do something store the result"
880.64,6.58,"and then the resource adder in this case is
free to do the next operation. So same idea"
887.22,10.32,"we will apply here and the three key resources
we will keep in mind is register file, ALU"
897.54,5.24,"which will do all arithmetic and logical operations
now and the two memories will be clubbed into"
902.78,3.77,"a single memory; it will store program as
well as data."
906.55,11.68,"Now let us take this is starting point which
is a single cycle design and in this we will"
918.23,8.28,"see what changes are required if we have to
share these resources and we know that we"
926.51,7.18,"are going to do a multi cycle design so each
major action would be done in a separate clock"
933.69,10.0,"cycle. Firstly, let us merge instruction memory
and the data memory; replace both these by"
943.69,8.37,"a single memory. So we remove these and replace
them with a single block which is doing read"
952.06,7.39,"as well as write and I have placed it here
where program memory was kept but what we"
959.45,7.56,"will do is we will route its inputs and outputs
back to the same memory that means the ALU"
967.01,6.42,"which was supplying the address will go back
and supply an alternative address; this was"
973.43,7.0,"the data input this will go back to this point
and the data which is being read will actually"
980.43,8.3,"now come out here. So these inputs and outputs
which were connected to these will now be"
988.73,5.5,"rerouted and brought back to this particular
block."
994.23,8.77,"Therefore, first of all, this output of ALU
which is the address for memory is connected"
1003.0,6.22,"back. Now we are bringing in a conflict here
but we know how to resolve that. We will introduce"
1009.22,5.1,"a multiplexer here to take care of this but
that is a problem we will tackle later."
1014.32,6.42,"So, first of all let us bring all connections
here. I have taken care of address input,"
1020.74,7.04,"next the data input which is going here will
be now brought to this; I have removed the"
1027.78,10.389,"old connection and it gets connected at this
point. Similarly, the data which is coming"
1038.169,6.88,"out of memory and was eventually through this
multiplexer going to register file will now"
1045.049,24.461,"come from this so that is removed and that
is yeah it is connected here let me see it"
1069.51,11.08,"again. So the old output of the memory is
removed and the new one will get connected"
1080.59,15.25,"into this. So it comes out of this and gets
connected. Again we are bringing a conflict"
1095.84,9.0,"here; we know that the data needs to be brought
from ALU or from memory for load instruction"
1104.84,6.459,"and for arithmetic instruction. So this is
a conflict point we will resolve with a multiplexer"
1111.299,1.48,again.
1112.779,4.341,"What we will do is for the moment we will
remove this multiplexer and reorganize it"
1117.12,17.47,"here later on. So, output of ALU is directly
connected here for the moment but we know"
1134.59,8.02,"that a multiplexer is required at this point.
We have gotten rid of one extra memory now"
1142.61,5.63,"gradually we will also collapse the two adders
on to this ALU."
1148.24,8.77,"So first let me make space let me just shift
things around so that there is space for carrying"
1157.01,9.239,"out an interconnection. Just the same thing
with things moved little apart and we will"
1166.249,7.06,"first eliminate this adder and then eliminate
that adder and same thing will be done; remove"
1173.309,6.47,"this and just route the interconnections on
to this so we remove that adder it was getting"
1179.779,14.03,"two inputs PC and 4. So the input coming from
PC is brought in to this point of the ALU"
1193.809,16.271,"so this is a new connection and the second
operand 4 will be brought to this multiplexer."
1210.08,6.419,"The output of this adder which was here was
eventually going through this multiplexer"
1216.499,11.831,"to be stored back into PC so, that we will
have to tag from this point now. So we remove"
1228.33,13.4,"that connection from top and take a connection
from here. Now we have still something hanging"
1241.73,9.699,"here; this was PC plus 4 which was being used
for offset addition here and generating jump"
1251.429,8.291,"address here. This will now come from PC because
we are assuming that you do PC plus 4 in one"
1259.72,9.01,"cycle the result goes back to PC. So the input
to this is not taken from here, we take the"
1268.73,5.389,"value; since it is a multi cycle design PC
plus 4 would be done in a particular cycle"
1274.119,7.991,"and that value will be put back into PC because
remember that we are going to put all values"
1282.11,6.199,"into some storage element in some register
at the end of the cycle so that resource which"
1288.309,10.921,"computed that becomes free. Therefore, this
input here will come from PC now. I simply"
1299.23,6.329,"make that connection there. We have taken
care of removing the first adder."
1305.559,8.852,"Now we eliminate the second adder; this one
will be moved away and its inputs are again"
1314.411,9.629,"brought to the same ALU. So we have this output
from PC which is already coming to this so"
1324.04,3.859,"that actually will not bother us that is already
there."
1327.899,7.51,"The second operand is coming from the offset
eventually and that would be brought to this"
1335.409,21.46,"multiplexer. The output from here will have
to go to this multiplexer. Yeah, so this second"
1356.869,15.391,"output second input to the old adder is removed
from there and is connected here. Then we"
1372.26,9.47,"simply get rid of the first input because
that is already taken care of and the output"
1381.73,7.71,"I make some space first for that and then
connect the output."
1389.44,10.26,"One might question actually that sorry......
why is it that we are still having two inputs"
1399.7,6.25,"to this they still seem to be coming from
the same point. But actually it may be a little"
1405.95,11.189,"difficult for you to see....... what will
actually happen is that although this value"
1417.139,4.631,"which is actually supposed to go to PC this
is the PC plus 4 value which is coming on"
1421.77,9.109,"this line it is meant to go to PC immediately
but the other thing which is coming here after"
1430.879,9.12,"offset addition is meant to again go to PC
but this is after comparison has been done"
1439.999,6.321,"in this ALU of the two registers and this
may go or may not go so what will happen is"
1446.32,5.229,"first this value will get immediately stored
in another register here"
1451.549,4.551,"before we do it before we take further decision
of sending elsewhere."
1456.1,6.709,"So, at the moment time I am keeping these
two both which look identical right now but"
1462.809,5.891,"one will come immediately from the output
of ALU, one will come from a register which"
1468.7,7.069,"is following ALU so that distinction we will
show up later but at this point you just take"
1475.769,4.53,it like this that we are simply retaining.
1480.299,4.87,"One was following this kind of design process.
You might actually.... if you are not able"
1485.169,7.09,"to see that you may eliminate one of these
but does not matter. If you need one later"
1492.259,5.05,"again, a separate one then you can bring it
back into the picture but I am just following"
1497.309,2.061,this approach.
1499.37,9.82,"Now we need to introduce registers at various
places so that output of every resource is"
1509.19,8.18,"stored in register. I simply make some space
for that and gradually introduce registers."
1517.37,8.6,"So, which are the points where we need to
introduce registers. what we are reading from"
1525.97,6.38,"the memory needs to be kept in a register;
we are reading two things: the instruction"
1532.35,4.78,"and we are also reading the data which needs
to go to register file eventually so two registers"
1537.13,5.879,"will be required here where one will store
instruction and one will store the data. Then"
1543.009,3.691,"you are reading operands from the register
file, they will be kept in small individual"
1546.7,5.829,"registers here, the output of ALU will be
kept in another register here. So these are"
1552.529,5.561,the places where we need to put registers.
1558.09,7.569,"So we place one register here we call it IR
or the instruction register, one is to be"
1565.659,7.191,"placed here we call it DR or data register
so both are carrying information brought from"
1572.85,9.51,"the memory. Then A register holds the first
operand and B register holds the second operand"
1582.36,6.929,"which come out of the register file. Then
there is a register which we call RES or the"
1589.289,6.971,"results which comes out of the ALU and here
I have made the distinction that PC plus 4"
1596.26,7.25,"value is immediately going to the PC from
ALU output; it is it is getting stored but"
1603.51,7.95,"getting stored in this PC whereas the other
things what else ALU is doing; ALU is doing"
1611.46,4.839,"normal addition, subtraction, AND OR, slt
operation so that that data will get stored"
1616.299,8.58,"in this register before it goes to register
file and also the memory address which is"
1624.879,6.0,"being calculated for load store instruction
will be resting in this here before it goes"
1630.879,6.16,"to the memory and also for branch instruction
the next instruction address which I calculate"
1637.039,6.21,"by adding offset will sit in this register
before I make a choice here whether to take"
1643.249,9.3,"PC plus 4 or PC plus 4 plus offset, so, that
is the purpose this register will serve."
1652.549,14.35,"Now the last thing which remains is to introduce
the multiplexers. We will At"
1666.899,6.01,"some place we will require fresh multiplexers,
somewhere we will simply do a rearrangement"
1672.909,8.201,"may be enhance the size or restructure the
multiplexer inputs. So we have multiplexer"
1681.11,9.73,"already there which are feeding the program
counter. What I will do I will just collapse"
1690.84,4.769,"them into a three input multiplexer three
input one output multiplexer which appears"
1695.609,11.721,"simpler and physically just bring it out here
so introduce a new multiplexer here but I"
1707.33,7.799,"will eliminate the old ones; this has three
inputs; one input comes from RES register,"
1715.129,7.321,"one comes from ALU directly and one comes
from this jump address. Those three are brought"
1722.45,6.15,"in here the output of this is going to feed
the PC."
1728.6,14.37,"So, first I switch the output then one input
comes from register result, one input comes"
1742.97,11.789,"from ALU and the third input comes from jump
address and I have gotten rid of the earlier"
1754.759,1.0,multiplexer.
1755.759,10.23,You can see it again. So this is one connection.
1765.989,3.57,This is second connection.
1769.559,2.23,This is third.
1771.789,9.531,"This is the fourth. So one output and three
inputs they are all rearranged."
1781.32,12.069,"Next we look at the multiplexer which is taking
care of the first input of ALU. ALU has two"
1793.389,9.29,"inputs now. The first input comes from either
A register A or it comes from PC from here."
1802.679,6.2,"So simply I need to introduce a multiplexer
here and connect these two inputs to that"
1808.879,1.351,multiplexer.
1810.23,12.379,"So this is a two input multiplexer: One input
comes from PC, another is already there shown"
1822.609,13.66,"from register A. Then this multiplexer which
is feeding second input of the ALU now has"
1836.269,11.53,"four inputs B, B register, the constant 4,
this offset which is used for load store instruction"
1847.799,7.61,"for calculating the address; it is the offset
in the instruction with signed extension."
1855.409,4.2,"For branch instruction we need to do a shift
also we need to sign extension followed by"
1859.609,5.121,"a shift so these are the two separate values
and there are total of four possibilities."
1864.73,10.36,"We need to have a bigger multiplexer here
now."
1875.09,13.149,"So place a bigger multiplexer and simply connect
these signals properly. So we would need to"
1888.239,5.64,"see we will need to worry about the control
of these multiplexers; what control value"
1893.879,8.92,"control input is required for different instructions
and that you will analyze later in the usual"
1902.799,7.161,"manner. Then we move our attention to this
area where we have data coming from DR or"
1909.96,11.891,"from RES that needs to be multiplex before
we feed into the register file. So just move"
1921.851,10.678,"that wire at the bottom; this one to make
some space here where I am placing this multiplexer"
1932.529,14.081,"so this is one input from DR the output is
properly connected and this signal coming"
1946.61,2.44,"from result is actually extended brought to
this."
1949.05,18.329,"Now this is taken care of. Finally I need
to put a multiplexer at that point. So here"
1967.379,10.16,"we have address; there are two address resources
PC for fetching in the instruction and this"
1977.539,9.441,"RES where load store address would be calculated
and kept, this is another address so it will"
1986.98,5.319,"be simpler to just extend this line here and
I will remove this line which is coming from"
1992.299,12.58,"top; same thing, I just pull it more neatly
from the bottom."
2004.879,12.91,"Now this is a complete design of the data
path for multi cycle. Basically more effort"
2017.789,9.36,"was there to ensure that resources are properly
shared. For that we need to collapse multiple"
2027.149,5.551,"components on to the same thing and with the
help of multiplexer we are able to feed different"
2032.7,5.87,"inputs to those resources at different times.
And then registers were introduced to break"
2038.57,8.689,"the time interval. So time interval gets broken
in to multiple clock cycles and now the paths"
2047.259,5.811,"which need to be considered for delay analysis
are a much shorter path."
2053.07,6.16,"For example, you can take paths going from
one storage element to another storage element."
2059.23,7.47,"When you are fetching instruction it is this
path PC to IR or there are paths from IR to"
2066.7,20.78,"A or IR to B or from DR to register file.
And similarly, path from A and B through ALU"
2087.48,7.54,"to result register and so on. So, main sources
of delay are these three components: memory,"
2095.02,7.68,"register file and ALU and if these three are
roughly balanced when this will work very"
2102.7,9.97,"nicely. So, that is 
complete design. We will look at the control"
2112.67,8.25,"part in the next lecture. I will just rearrange
this diagram to make redraw this little neater."
2120.92,9.48,"We will go into details of control signals.
Basically now we have lots of multiplexers."
2130.4,9.8,"We have 1 2 3 4 5 6 six multiplexers are there
which require control and multiplexers like"
2140.2,8.18,"this one will require 2 bits to control them.
Apart from that we have the usual control"
2148.38,9.159,"requirements for memory, register file and
ALU. We also need to now look at these registers"
2157.539,3.711,"in which cycle we load these registers and
which cycles we do not."
2161.25,8.599,"So, for example, if you take let us say add
instruction, after the first cycle IR gets"
2169.849,10.061,"loaded, after the second cycle A and B gets
loaded, after the third cycle RES gets loaded"
2179.91,11.09,"and then in the fourth cycle this RF writes
RF gets the value written into it. Also, we"
2191.0,6.39,"will typically load PC with the new value
PC plus 4 at the end of first cycle itself."
2197.39,6.479,"If it is a branch instruction and branch has
to be taken that we will overwrite that PC"
2203.869,5.051,"plus 4 value in the PC by a different value
and similarly in jump we will write something"
2208.92,6.08,"else in that. So, even PC will require a control."
2215.0,5.69,"In every cycle we need to determine whether
a new value goes into this or does not go"
2220.69,6.89,"because there is no register which is now
loading a new value in every cycle so this"
2227.58,4.91,"needs to be taken care of and the number of
control signals therefore is quite large."
2232.49,8.9,"We have these six multiplexers out of which
two require 2-bit input so a total of eight"
2241.39,3.09,control signals we require just for multiplexers.
2244.48,11.42,"We have two for memory, 1 bit for RF and 3
bits for ALU so this is another 6 bits and"
2255.9,7.36,"we have 1 2 3 4 5 and 6 registers
so one control signal for each of these registers."
2263.26,8.109,"So there is a large number of control signals
which are required. And also, the control"
2271.369,8.511,"would be different in the sense that in every
cycle there is a different set of control."
2279.88,6.469,"So the control will no longer be a simply
combinational box; it will be a sequential"
2286.349,5.301,"machine which goes through a set of cycles
four cycles, five cycles or three cycles depending"
2291.65,5.86,"upon what the instruction is and in each cycle
it tries to control things differently. So"
2297.51,5.93,"the design is a more involved in that sense
and that is the reason the single cycle design"
2303.44,5.34,"was considered the first being the most simple
design."
2308.78,9.46,"So, in a summary we have moved over from single
cycle design to multi cycle design. we have"
2318.24,7.02,"compared their performance. Basically it gives
you better performance and by resource sharing"
2325.26,11.829,"it tends to reduce the cost. But now we must
notice that there is a trade off although"
2337.089,5.901,"we are trying to gain both in time and in
cost somewhere there are losses also and we"
2342.99,5.5,"have to be careful that losses do not overshadow
the gains. So for example, in performance"
2348.49,6.84,"improvement if the quantization has to coarse
and if there is an imbalance on the values"
2355.33,6.4,"of timings for different individual actions
then on one hand we might gain but on other"
2361.73,5.66,"hand we might lose all the gain simply because
there is an imbalance."
2367.39,8.36,"Similarly, while resource sharing we have
eliminated those adders and we have removed"
2375.75,7.74,"we have eliminated one memory but we have
incurred extra cost in terms of registers"
2383.49,8.92,"and multiplexers. So you are sharing but there
is an overhead of sharing and we have to be"
2392.41,5.24,"a little more careful in our calculation and
ensure that the overhead does not overshadow"
2397.65,10.78,"the gain. Finally just to close we had design
where data path conceptually is simple in"
2408.43,5.859,"terms of key resources with just one ALU,
one memory and one register file but there"
2414.289,6.04,"are registers and multiplexers which glue
these all together. So, next we will look"
2420.329,30.26,"at the issue of control design for such a
data path, thank you."
