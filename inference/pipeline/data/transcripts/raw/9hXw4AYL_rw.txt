second,duration,transcript
1.439,4.001,welcome to frank's diana explains
3.52,4.239,and to the algorithms course at the
5.44,5.52,university of cambridge
7.759,4.88,today's topic is dynamic programming
10.96,3.599,today's topic and the topic of the next
12.639,4.161,few videos actually dynamic programming
14.559,5.841,is a powerful technique that applies to
16.8,6.239,a large class of problems where a naive
20.4,4.959,exhaustive search approach would have
23.039,4.08,exponential complexity
25.359,3.281,if you use dynamic programming instead
27.119,4.0,these problems can be solved
28.64,4.4,in low polynomial time a dramatic
31.119,3.921,improvement
33.04,3.679,dynamic programming can be quite
35.04,3.76,puzzling if you've
36.719,3.041,never heard of it before so this very
38.8,2.8,brief video
39.76,4.479,will give a general overview but
41.6,4.72,experience tells me that it may still
44.239,2.64,not completely make sense the first time
46.32,4.079,you hear
46.879,6.0,about this stuff in the next few videos
50.399,3.361,i'll work through a few examples and
52.879,2.641,then after that
53.76,3.04,we can recap and at that point this
55.52,4.719,video will hopefully
56.8,3.439,sound a lot clearer
60.96,3.36,if you are already experienced with
62.8,4.08,dynamic programming
64.32,3.76,more power to you and feel free to watch
66.88,3.279,these
68.08,3.28,numerous examples of application of
70.159,3.601,dynamic programming
71.36,3.6,at high speed so that you get more
73.76,3.76,quickly to the point
74.96,3.199,where you can open your editor open your
77.52,2.639,ide
78.159,3.761,and start writing code to prove to
80.159,5.521,yourself that you're actually capable
81.92,6.08,of applying these techniques
85.68,4.079,for example the dna problem that i posed
88.0,4.4,in the very first lecture in the course
89.759,3.201,and write a program that takes two input
92.4,2.16,strings
92.96,3.36,and returns the longest common
94.56,3.84,subsequence between them
96.32,4.159,longest the longest or one of the
98.4,5.92,longest if there are several
100.479,3.841,of the same length
104.479,3.041,of course not all problems can be solved
107.04,3.039,by
107.52,4.48,dynamic program but the problems that
110.079,4.72,can be solved by dynamic programs
112.0,5.04,programming share certain features which
114.799,5.441,you will have to learn to recognize
117.04,4.16,your glutes for saying okay dynamic
120.24,3.76,program
121.2,4.0,is probably a good idea in this case so
124.0,4.319,the first of these features
125.2,5.44,is that the problem uh has many choices
128.319,3.28,each choice with its own score and you
130.64,5.599,must find
131.599,6.72,one that has the optimum score
136.239,3.841,second property is that the number of
138.319,3.841,choices is too large
140.08,4.0,for trying demolite by brute force
142.16,3.36,typically an exponential number of
144.08,3.92,choice
145.52,3.04,the third property is that the optimal
148.0,3.28,solution
148.56,4.64,is made of optimal solutions for smaller
151.28,5.44,sub-problems
153.2,5.679,and the fourth property is that these
156.72,4.159,sub problems overlap
158.879,4.161,and therefore searching for the optimal
160.879,4.08,solution without dynamic programming
163.04,5.839,would typically end up recomputing the
164.959,3.92,same partial solutions many times
169.04,3.279,to apply dynamic programming you must
171.68,2.72,first
172.319,3.521,describe the problem top down in a
174.4,4.479,recursive fashion
175.84,3.84,describing as per property 3 the optimal
178.879,5.041,solution
179.68,5.12,in terms of smaller optimal solutions
183.92,3.599,however
184.8,3.84,if you then executed this recursive
187.519,3.36,function
188.64,3.36,you would usually end up conducting an
190.879,4.241,exponential time
192.0,5.84,exhaustive search and so the main
195.12,4.32,dynamic programming approach is instead
197.84,4.64,bottom-up
199.44,4.879,you solve the sub-problems starting from
202.48,4.88,the base case
204.319,3.761,and from smallest to largest so that
207.36,3.12,wherever
208.08,4.56,a solution requires the solutions to
210.48,3.759,sub-problems these sub-problems
212.64,3.599,have already been computed and you can
214.239,5.441,just look them up
216.239,6.72,that's the basic fundamental
219.68,5.119,bottom-up dynamic programming approach
222.959,4.081,it is also possible to do dynamic
224.799,5.921,programming in the top down fashion
227.04,6.559,by going through the recursive
230.72,3.76,expression of the optimal solution
233.599,4.881,provided
234.48,6.319,you use a trick called memorization
238.48,3.119,you augment the recursive function with
240.799,3.841,machinery
241.599,4.56,that remembers all previously computed
244.64,4.319,results
246.159,4.481,so when you do that the recursion
248.959,2.961,doesn't end up recomputing the same
250.64,3.28,things many times because
251.92,3.76,if it recognizes that the result was
253.92,5.279,already computed before
255.68,5.119,then it just looks it up and returns it
259.199,3.44,in the next few videos as i said i'll
260.799,4.561,give examples of problems that i
262.639,3.84,will then solve with dynamic programming
265.36,3.119,in this video
266.479,3.121,i will just show you a much easier
268.479,3.201,example that
269.6,3.12,isn't quite dynamic programming but that
271.68,4.239,demonstrates
272.72,6.64,the perils of wasteful recomputation of
275.919,4.881,intermediate results as for
279.36,2.64,an introduction to dynamic programming
280.8,3.04,i'm first going to mention something
282.0,4.479,that is not dynamic programming
283.84,3.44,but we'll give you some ideas about some
286.479,4.0,pitfalls
287.28,6.56,that dynamic programming
290.479,5.361,may expose you to so you are
293.84,3.04,familiar with the well-known fibonacci
295.84,4.16,sequence
296.88,4.319,where starting with one and one you add
300.0,2.56,them together and you get two
301.199,2.961,you add the last two numbers together
302.56,3.04,you get three you got the last two
304.16,3.44,numbers together you get five you have
305.6,3.36,the last two
307.6,3.439,and you get the next one you add the
308.96,4.799,last two numbers together to get
311.039,4.401,the next one so you were exposed to that
313.759,3.361,in kindergarten and you've seen that
315.44,3.759,this is the way that leads are arranged
317.12,5.68,around the stock is the way
319.199,6.56,that if you continue you get the
322.8,5.92,the golden ratio and greek temples and
325.759,2.961,all beautiful things
328.88,5.44,now it's fun when you are
332.4,4.4,just a few years old to compute the
334.32,5.2,successive
336.8,3.52,numbers in the fibonacci sequence when
339.52,2.64,you become
340.32,4.24,a computer scientist or a budding
342.16,5.52,computer scientist and you get exposed
344.56,4.88,to recursion then your brain gets
347.68,6.079,polluted into thinking
349.44,7.52,that it's cooler to compute them
353.759,6.72,in reverse by saying okay
356.96,6.72,uh give me the
360.479,4.72,um i don't know the 30th fibonacci
363.68,4.56,number okay
365.199,5.521,so fibonacci of n equals 30 if n
368.24,3.76,is less than 2 then i can find the
370.72,2.4,answer very easily because it's at the
372.0,3.28,bottom but otherwise
373.12,3.68,the result is going to be the sum of
375.28,3.919,fibonacci of 29
376.8,4.72,and fibonacci of 28 and you do that by
379.199,6.0,saying fibonacci 29 i go back in here
381.52,5.76,29 uh read the recursive by 28 and 37
385.199,4.401,and then when i finish with that i will
387.28,5.759,do the 28 and i will add it up
389.6,6.48,so if you write this type of
393.039,4.961,program a very simple
396.08,3.36,recursive program to compute fibonacci
398.0,2.96,sequences uh
399.44,4.16,and you run it on something like for
400.96,3.84,example 30 you will think that your
403.6,4.24,computer got stuck
404.8,3.04,because you said financially
408.96,4.56,nothing works uh why is that it will
411.84,4.32,take a very long time to even complete
413.52,5.519,something as basic as 30.
416.16,4.24,um you could do quicker on a piece of
419.039,2.56,paper by yourself than asking your
420.4,2.0,computer to compute you with that
421.599,2.401,program
422.4,4.0,because what happens with something as
424.0,5.36,small as just 10
426.4,4.88,is this so you ask it to compute a
429.36,2.72,fibonacci of 10 and you will first have
431.28,3.359,to compute
432.08,4.48,fibonacci of 9 and 8. but to do 9 8
434.639,4.321,first does 9
436.56,4.079,it does 9 and to do 9 first he has to do
438.96,2.639,8 and he keeps recursing back until he
440.639,4.081,gets to 1.
441.599,4.401,when he gets to 1 he can go back and say
444.72,4.56,all right
446.0,6.88,that was 1 so it returns
449.28,4.96,uh the value back to you but then uh
452.88,3.36,it's not enough because it has to go
454.24,5.2,back and compute fibonacci number
456.24,4.799,of uh eight so this was ten you have to
459.44,5.599,compute nine and eight
461.039,6.961,and eight you have to
465.039,4.241,redo so many of the same things that you
468.0,4.479,already did before because
469.28,6.319,here also when you said eight uh or
472.479,4.321,nine it's not enough just to compute
475.599,2.88,eight seven six
476.8,4.0,four eight in turn you have to go back
478.479,4.241,and compute seven uh and six
480.8,4.0,and four seven you have to go back to q6
482.72,5.12,so you recompute the same things
484.8,4.48,so many times uh it's uh easy to even
487.84,2.799,lose track here
489.28,2.479,this is how many times you have to
490.639,2.161,return something so every time there's
491.759,3.201,an error like this
492.8,3.519,one of these things returns a result and
494.96,3.519,look how many times
496.319,4.401,you have to go back before you finally
498.479,6.241,get the two things that you can add up
500.72,4.0,uh to return this number so with um
504.8,4.48,with these nested uh double calls it's
507.68,3.199,not the fact that you have two calls
509.28,4.08,it's the fact that each call
510.879,4.64,recomputes things that you've uh you're
513.36,5.76,computing over and over again
515.519,6.64,and so these things uh ends up with
519.12,5.6,a number an exponential number of calls
522.159,3.761,which makes your program extremely slow
524.72,3.84,and inefficient
525.92,2.64,so something
531.92,6.64,like this which
535.279,5.041,may look like a mess compared to this
538.56,3.2,it may look inelegant it's actually if
540.32,3.44,you read through it
541.76,3.44,it's simply well if it's uh one of the
543.76,2.4,first two then the result is one but
545.2,4.56,otherwise
546.16,6.88,set the basic uh starter chain to one
549.76,5.199,and then uh for every next element just
553.04,3.44,add the two previous ones and shift add
554.959,4.401,the two previous ones and shift
556.48,3.68,and the result is the end and return so
559.36,3.76,this is just an
560.16,4.16,iterative version doesn't call itself is
563.12,2.159,the thing you did when you were in
564.32,3.44,kindergarten
565.279,3.281,and you're adding them up and this is
567.76,3.92,actually
568.56,3.12,a much better idea
571.76,4.56,so because it's it looks easier to
574.64,4.08,express things this way well not that
576.32,5.84,much easier in this case but
578.72,6.32,in many cases the formulation that
582.16,4.64,goes from the top down and uses
585.04,4.96,recursion
586.8,6.32,is a bad idea for computing the result
590.0,5.68,however it is an easy way to describe
593.12,3.04,the solution to the problem there's a
595.68,3.52,trick
596.16,5.04,you could use to
599.2,5.04,resort to this formulation without
601.2,5.6,spending so much time and that is
604.24,3.76,use that but every time you actually
606.8,3.76,return a result
608.0,3.68,remember it somewhere so you make
610.56,3.519,yourself a little memo
611.68,4.8,and you write okay i actually already
614.079,5.841,computed fibonacci of three
616.48,5.76,and the result is two uh
619.92,3.84,and so next time you're asked to do
622.24,4.08,fibonacci of three instead of
623.76,3.44,uh recursing down you say ah and this
626.32,1.84,was two and then when
627.2,2.96,this next time you're asked to do
628.16,2.799,fibonacci of seven you don't have to
630.16,2.64,recurse
630.959,3.201,you read it up from the table of things
632.8,1.76,you computed earlier so you pay the
634.16,2.4,price
634.56,3.76,only once for each result you don't
636.56,2.88,recompute the same results every time so
638.32,4.079,this is called
639.44,4.24,memoization not a memorization
642.399,4.961,memoization
643.68,7.52,and it's a technique for rescuing
647.36,7.039,these otherwise pathetically inefficient
651.2,4.96,recursive formulations of these problems
654.399,2.961,so dynamic programming this is not
656.16,2.679,dynamic programming but dynamic
657.36,4.0,programming is
658.839,5.321,a a technique
661.36,3.28,that can be used to tackle problems
664.16,4.0,where
664.64,6.0,there is this feature that
668.16,3.119,the optimal solution to the big problem
670.64,3.199,involves
671.279,3.441,optimal solutions to smaller problems
673.839,4.801,which
674.72,6.0,overlap and which if you did in the
678.64,4.24,regular brute force or top-down way you
680.72,3.6,would end up recomputing many times the
682.88,2.399,same problems would be recomputed so
684.32,3.6,many times
685.279,4.24,so memorization is a technique whereby
687.92,4.72,each
689.519,5.921,component problem is only computed once
692.64,3.439,and so you save yourself from falling
695.44,8.399,into
696.079,7.76,that trap
