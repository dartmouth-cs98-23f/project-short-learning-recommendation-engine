second,duration,transcript
0.03,5.519,hey CS dojo its YK here so in this video
3.689,4.83,I'm going to talk about what dynamic
5.549,4.981,programming is and how to use it and as
8.519,3.66,I explain how it works I'm going to
10.53,3.81,assume that you're already familiar with
12.179,5.581,recursion so what is dynamic programming
14.34,5.4,exactly it's actually fairly simple even
17.76,4.26,though it might sound difficult it's
19.74,4.44,basically a way of making your algorithm
22.02,4.23,more efficient by storing some of the
24.18,4.47,intermediate results and it works really
26.25,4.83,well when your algorithm has a lot of
28.65,3.96,repetitive computations so that you
31.08,4.139,don't have to repeat those competitions
32.61,4.469,over and over again and I'm gonna give
35.219,4.531,you a concrete example of how it works
37.079,4.441,with Fibonacci sequence so just in case
39.75,3.989,you're not familiar with it phonology
41.52,4.68,sequence is a sequence of numbers that
43.739,5.07,starts with two ones at the beginning
46.2,5.31,and each number after that is computed
48.809,4.23,by adding up the two previous numbers so
51.51,5.01,the third three months number is two
53.039,5.221,because one plus one equals two and then
56.52,4.199,the fourth 300 number is three because
58.26,5.88,one plus two equals three and so on and
60.719,4.8,this sequence keeps on going forever so
64.14,3.87,let's say we're trying to solve the
65.519,6.71,problem of finding the entrance number
68.01,7.35,or writing a function called fib of n
72.229,5.68,which takes a positive integer n and
75.36,6.93,finds and returns the end speedruns
77.909,6.301,number so if the given n is three we
82.29,5.189,want to be able to find and return the
84.21,5.909,third Finch number which is two and if
87.479,4.801,the given n is five we want to be able
90.119,5.221,to return the fifth Reynolds number
92.28,4.58,which is five let's see how we can solve
95.34,4.2,this problem using dynamic programming
96.86,4.78,so if you want to solve a problem using
99.54,4.68,dynamic programming there are typically
101.64,4.74,three steps you can take the first step
104.22,4.38,is to come up with a recursive solution
106.38,4.23,to your problem and then in your
108.6,4.17,recursive solution if you notice that
110.61,4.38,there are a lot of repeated competitions
112.77,4.169,you can then store some of the
114.99,4.68,intermediate results so that you don't
116.939,5.731,have to repeat those competitions this
119.67,5.519,process is also called memoization or
122.67,5.309,memorize and this is not to be confused
125.189,5.221,with memorize and I've made a mistake
127.979,5.351,before too and then the third step if
130.41,4.45,you don't like using recursion anymore
133.33,4.2,is to come up with something called a
134.86,4.32,bottom-up approach so let's first see
137.53,4.35,what a recursive solution might look
139.18,4.32,like for this particular problem so as I
141.88,4.44,said earlier we're going to write a
143.5,5.67,function called fable of n which takes
146.32,5.79,and a positive integer and returns the N
149.17,6.03,3 branch number and if n is equal to 1
152.11,5.43,or 2 we know that the first and the
155.2,4.74,second finish numbers are 1 we're going
157.54,2.82,to return 1 but instead of returning it
159.94,2.43,right away
160.36,4.47,we're going to store it in a temporary
162.37,5.13,variable called the result and then
164.83,4.49,return that instead and it's going to be
167.5,6.209,clear why we need to do that later and
169.32,7.15,if n is neither one nor two then we're
173.709,5.401,going to return the sum of the two
176.47,6.66,previous Fibonacci numbers instead fib
179.11,6.48,of n minus 1 plus fib of n minus 2 store
183.13,5.4,that in result and then return it at the
185.59,6.119,end so the solution works but it's very
188.53,5.46,very inefficient to see why let's see an
191.709,5.631,example where we're trying to find the
193.99,6.749,5th Fibonacci number by calling table 5
197.34,6.1,so to find the return value of people 5
200.739,5.521,we need to first compute the return
203.44,5.579,values for table 4 and people 3 so we
206.26,5.009,can add them up and to find people for
209.019,5.19,we need to first compute fib of 3 and
211.269,5.491,peep of 2 and so on and that's what this
214.209,4.53,diagram shows and looking at this
216.76,3.93,diagram you might notice that there are
218.739,4.351,some competitions that we repeat over
220.69,4.549,and over again for example we need to
223.09,5.91,compute the return value for people to
225.239,6.911,three times and we need to compute the
229.0,5.43,return value for fib of 3 twice here and
232.15,4.92,it's not a big deal when we are trying
234.43,4.89,to find the fifth or sixth minus number
237.07,4.53,but if we're trying to find the
239.32,4.889,hundredth free bonus number it becomes
241.6,5.82,an issue and actually the time it takes
244.209,6.09,to find the nth Fibonacci number grows
247.42,5.22,exponentially or roughly in the order of
250.299,5.101,two to the power of n and dynamic
252.64,5.76,programming here says why not just store
255.4,5.97,those return values for example for fib
258.4,6.24,of 3 store the return value once we
261.37,5.64,compute it and then use that same value
264.64,4.98,when we see people 3 again in
267.01,5.73,instead of computing it again and again
269.62,4.77,this process is called memoization so
272.74,4.35,let's see what a memorized solution
274.39,5.1,looks like in code let's again consider
277.09,4.35,the example where we're trying to find
279.49,4.86,the fifth boomers number by calling
281.44,5.67,people five the idea of this solution is
284.35,8.31,going to be that we're going to use an
287.11,7.71,array whose length is n plus one or six
292.66,4.41,in this particular case because n here
294.82,5.28,is five and then we're going to store
297.07,7.71,the return value for the function of fib
300.1,7.32,of n at the index n so we're going to
304.78,5.52,store feeble of one which is the first
307.42,8.46,few months number right here at index 1
310.3,7.98,and then fib of 2 at index 2 and so on
315.88,6.6,and initially we're going to set all
318.28,6.96,these values to now and we're going to
322.48,4.83,write our function of fib and this is
325.24,4.08,going to take two arguments instead of
327.31,4.98,just one the first one is the same as
329.32,6.3,before and a positive integer and the
332.29,6.51,second one is going to be this array and
335.62,6.51,so you need to initialize the survey
338.8,5.58,memo before you call this function now
342.13,6.45,at the beginning of this function check
344.38,7.35,if memo at index n is null or not if
348.58,5.91,it's not equal to now that'll mean that
351.73,5.04,we've already seen this argument N and
354.49,5.7,we've already stored the return value
356.77,6.18,for that at the index n a memo so just
360.19,5.22,return that instead so we turn memo
362.95,4.77,square brackets and otherwise the
365.41,7.41,following part is the same as before if
367.72,7.56,n is equal to 1 or 2 we turn one store 1
372.82,6.42,in result and then return that at the
375.28,6.36,end and if that's not the case then find
379.24,4.86,the sum of the two previous fabulous
381.64,4.86,numbers and then return that instead and
384.1,6.3,then what's new in this function is that
386.5,8.31,before you return this result the return
390.4,7.02,value you need to store it in memo at
394.81,4.8,index n so that you can use it later
397.42,3.33,now let's now think about the time
399.61,4.46,complexity for the
400.75,5.76,solution we're going to call it T of n
404.07,4.81,this is going to be the time it takes to
406.51,4.92,find the nth Fibonacci number with this
408.88,6.84,particular method and we're going to
411.43,9.57,find that by multiplying the number of
415.72,7.92,times we call this function baby with
421.0,4.68,the time it takes to execute each of
423.64,4.83,those calls we're going to call that T
425.68,5.1,now there are only two ways we're going
428.47,4.56,to call this function of fib the first
430.78,4.65,way is when we call this function for
433.03,5.55,the first time with the arguments and
435.43,6.45,and memo to find the NSP ones number and
438.58,6.21,the second way is from this line right
441.88,8.03,here and notice that if you look at this
444.79,9.39,whole block after this first if clause
449.91,6.94,this whole block is only executed most n
454.18,5.12,times and this is true because there are
456.85,6.48,n possible arguments to this function
459.3,6.61,that's 1 through N and each time this
463.33,4.89,function is called with each of those
465.91,6.42,arguments the return value will be
468.22,6.27,stored a memo at index n so after the
472.33,5.04,first time this function is called with
474.49,6.33,each argument we'll never get to this
477.37,6.93,block and each time this block is
480.82,6.12,executed fib is called a most twice if
484.3,8.01,we get to this line so the number of
486.94,10.32,times fib is called is at most two times
492.31,7.98,n plus 1 so 2 n it comes from this block
497.26,5.73,right here and one comes from the first
500.29,4.83,time we call this function fib and the
502.99,5.79,time it takes to execute each of those
505.12,7.049,calls this T right here is going to be a
508.78,6.6,constant time or a Big O of 1 and this
512.169,7.711,is because if you look at each operation
515.38,6.81,in this function excluding these
519.88,4.37,recursive calls that follow each
522.19,5.13,operation is a constant time operation
524.25,7.72,and when you have a constant time
527.32,7.23,operation when you add them up you still
531.97,4.619,get a constant time operation
534.55,5.55,which is big-oh of one and that's why we
536.589,5.37,have Big O of one here and so T of N or
540.1,3.33,the time it takes to find the nth
541.959,5.431,feminist number with this particular
543.43,9.649,method is going to be 2 n plus 1 times
547.39,9.9,Big O of 1 which is Big O of 2 n plus 1
553.079,6.581,which is equal to Big O of N and this is
557.29,5.85,a huge improvement from what we had
559.66,6.75,earlier which was Big O of 2 to the
563.14,6.75,power of n now let's now examine how
566.41,5.1,this memo array is actually filled so
569.89,4.23,let's say we're trying to find the 5th
571.51,5.639,Fibonacci number again and when we call
574.12,4.98,fib with the argument 5 and memo of
577.149,5.94,course we'll see that we don't have a
579.1,6.03,stored value at the index 5 yet so we go
583.089,5.101,down and we're going to ask ourselves
585.13,6.51,what's the value of fib of 4 and then 3
588.19,7.11,and so on and when we get to fever of 2
591.64,7.37,we'll know that this value is 1 so we're
595.3,7.5,gonna store it at index 2 right here and
599.01,7.3,same with people 1 that's 1 right here
602.8,5.159,and once we have these two values we'll
606.31,4.339,be able to find the third a Fibonacci
607.959,5.401,number which is fib of 3 right here and
610.649,5.38,then once we find the value by adding
613.36,5.28,them up store that value right here so
616.029,6.391,we can use it later and then when we go
618.64,6.93,up to feeble 4 we'll add 1 and 2 right
622.42,6.539,here and we get 3 and so on until we get
625.57,7.56,here and so as you can see this array is
628.959,6.361,mostly filled from left to right so when
633.13,4.949,you see this you might say why not just
635.32,5.28,explicitly build this array from left to
638.079,5.281,right from scratch instead of building a
640.6,5.91,recursively and that's the idea behind a
643.36,4.979,bottom-up approach so let's see what a
646.51,4.139,bottom-up approach might look like in
648.339,6.0,code we're going to define a function
650.649,5.401,called fab bottom-up which takes an a
654.339,4.201,positive integer just like before and
656.05,6.599,returns the nth Fibonacci number and
658.54,6.359,then if n is equal to 1 or 2 of course
662.649,5.551,we're going to return 1 and after that
664.899,6.571,we're going to define an array whose lie
668.2,6.51,is going to be n plus 1 where n plus 1
671.47,5.4,is 6 of course if we're trying to find
674.71,5.64,the fifth Fibonacci number right here if
676.87,6.3,n is equal to five and after that we're
680.35,6.63,going to set the first and the second
683.17,6.93,elements of this array bottom up to be 1
686.98,7.11,these two items right here and then
690.1,7.62,we're going to run a for loop for I from
694.09,8.67,3 which corresponds to this item right
697.72,7.29,here up to N and n corresponds to the
702.76,5.07,last item right here of this array and
705.01,5.67,whatever index we're examining currently
707.83,5.28,we're going to set that element at the
710.68,5.37,index I or bottom up square brackets I
713.11,5.58,to be the sum of the two previous items
716.05,6.99,so in this particular example we'll have
718.69,7.44,two here three here and after that we're
723.04,5.16,going to return the last item in bottom
726.13,5.04,up or bottom up square brackets N and
728.2,5.57,we're done the time complexity for this
731.17,5.55,algorithm will be again Big O of n
733.77,5.4,because we're going to define this array
736.72,5.1,and go through this array only once
739.17,4.42,ok so that's how dynamic programming
741.82,4.29,works but now I'm going to show you a
743.59,4.5,quick demo with Python and something
746.11,4.95,called Jupiter notebook to show you how
748.09,4.83,this idea of my play out in practice so
751.06,5.07,in this jupiter notebook i have defined
752.92,5.28,a few functions in Python fib of n which
756.13,5.7,is a recursive naive recursive solution
758.2,7.05,and river of memo and people to which
761.83,5.49,represent a memorized solution and fifth
765.25,3.78,bottom up which is of course a bottom up
767.32,4.23,solution so let's see how they compare
769.03,5.34,to each other in performance we're gonna
771.55,5.66,try running fib of n first the naive
774.37,6.39,recursive solution with fever five and
777.21,6.22,that gives us 5 which is expected what
780.76,4.65,about fever of 20 that gives us the
783.43,5.91,answer pretty quickly - and what about
785.41,6.84,fever of 35 this actually takes five to
789.34,4.47,six seconds on my computer so it's
792.25,4.35,obviously not the most efficient
793.81,4.65,approach let's see how fib of 2 and 3
796.6,4.14,both memo the memorized solution
798.46,3.57,compares to that let's try running fifth
800.74,3.75,memo of 5
802.03,4.77,first and that gives us five which is
804.49,5.52,expected and what about 50 mm or 35
806.8,8.07,that's pretty quick - and what about 50
810.01,6.9,ml 100 and 1000 this actually gives us
814.87,4.53,an error and this error is called a
816.91,4.17,recursion error Python gives us this er
819.4,5.49,actually because there are too many
821.08,5.88,recursive calls on a call stack and to
824.89,4.74,fix that we can just use the bottom-up
826.96,4.95,approach one advantage of using a
829.63,4.47,bottom-up approach is that we don't have
831.91,3.96,to put any recursive calls on a call
834.1,3.9,stack so we don't have to worry about
835.87,4.35,that so we're going to load this
838.0,5.94,function and then run it with the
840.22,7.1,argument 35 which is pretty quick 1000
843.94,7.14,"and then let's try 10,000 as well and"
847.32,5.35,that's pretty instantaneous - okay so
851.08,3.84,that's my introduction to dynamic
852.67,3.6,programming let me know in the comment
854.92,3.9,section below what you thought of this
856.27,4.59,video and if you have any requests about
858.82,3.57,what kind of videos I should make in the
860.86,2.67,future let me know in the comment
862.39,4.14,section below as well
863.53,5.48,I'm YK from CES dojo and I'll see you in
866.53,2.48,the next video
