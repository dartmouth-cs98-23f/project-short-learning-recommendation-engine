second,duration,transcript
0.56,4.0,hello my name is jeff messier i'm a
2.24,4.0,professor in electrical and software
4.56,3.999,engineering in the schulich school of
6.24,4.24,engineering and in this lecture i'm
8.559,4.24,going to talk about
10.48,4.239,memory how memory is organized and
12.799,4.801,basically how we organize the values
14.719,4.56,that are stored in memory
17.6,4.08,before we get into that i just want to
19.279,5.121,review a few things about number
21.68,3.519,notation and
24.4,2.56,in
25.199,4.561,this module and in this course in
26.96,5.119,general we're going to use
29.76,4.56,several different number systems
32.079,4.0,we're going to use base 10 numbers we're
34.32,4.64,going to use hexadecimal numbers and
36.079,5.521,we're going to use binary numbers and
38.96,2.64,just to be
42.079,4.0,i guess just to start with the most
43.52,4.64,familiar base 10 numbers are what we've
46.079,4.48,been using all the way through
48.16,4.079,elementary school this is our standard
50.559,3.361,numbering system
52.239,3.921,and
53.92,7.319,for example if i were to write the
56.16,5.079,number uh 3821
63.039,6.08,for the purposes of this slide in this
66.0,5.439,discussion i'm going to give a subscript
69.119,4.881,10 here and that is going to indicate
71.439,5.201,that this is a base 10 number
74.0,5.52,and the value of
76.64,3.68,this number can be calculated
79.52,3.52,by
80.32,4.72,multiplying each of these digits by
83.04,4.8,a power of 10.
85.04,5.2,so 3821
87.84,5.279,is equal to 3
90.24,3.919,times 10 to the 3
93.119,2.721,plus
94.159,3.521,8 times
95.84,2.88,10 to the 2
97.68,4.24,plus
98.72,4.48,2 times 10 to the 1
101.92,5.28,plus
103.2,5.68,1 times 10 to the 0.
107.2,5.12,and
108.88,6.96,the powers of 10 are a function of the
112.32,3.52,position of each one of these digits
117.2,6.72,binary numbers are base 2 numbers and so
121.2,4.8,if i were to write out 1
123.92,3.28,1 0 1
126.0,3.44,i could
127.2,5.039,just to indicate the base write a little
129.44,4.4,subscript 2
132.239,2.961,to indicate that we're using a base 2
133.84,2.24,number
135.2,2.32,and
136.08,3.44,just like
137.52,4.0,our example for the 10 base number the
139.52,3.52,value of this
141.52,3.92,binary number
143.04,4.08,is 1 times
145.44,3.519,2 to the
147.12,4.479,3
148.959,4.64,plus 1 times
151.599,3.28,2 to the 2
153.599,2.881,plus
154.879,3.761,0 times
156.48,3.039,2 to the 1
158.64,2.56,plus
159.519,2.8,1 times
161.2,3.039,2
162.319,4.081,to the 0.
164.239,4.241,or in other words if we add up all of
166.4,4.8,these numbers this is
168.48,3.52,8 plus 4
171.2,2.88,plus
172.0,3.04,0 plus 1
174.08,4.32,or
175.04,5.04,13 if we want to write it in terms of of
178.4,3.119,base 10.
180.08,3.439,now when we're working with binary
181.519,3.121,numbers we're going to be grouping them
183.519,2.0,together
184.64,3.28,a
185.519,2.401,byte
190.56,2.88,is equal to
193.76,3.52,an 8 bit
195.76,4.88,base 2 number
197.28,3.36,and a nibble
201.519,2.8,is a four bit
205.44,4.24,base two number two nibbles make a bite
207.84,5.039,obviously
209.68,4.559,another really common number system that
212.879,2.961,we're going to be using in this class
214.239,4.72,are hexadecimal numbers which are
215.84,6.88,actually base 16. now
218.959,4.961,base 16 seems like a strange number base
222.72,3.599,to use
223.92,6.319,but
226.319,5.92,the numbers 0 through 15 are the maximum
230.239,3.841,range of numbers you can represent with
232.239,3.28,four bits and so
234.08,3.359,computer engineers like to use
235.519,3.761,hexadecimal numbers because it's
237.439,4.8,relatively easy once you get the hang of
239.28,5.84,it to very quickly translate between
242.239,5.601,hex numbers and and binary numbers a lot
245.12,6.319,easier than it is to translate between
247.84,4.72,base 10 numbers and and binary numbers
251.439,4.16,and
252.56,5.199,for hex numbers
255.599,5.92,since we've got 16 values that we
257.759,4.88,represent using digits we start with
261.519,2.561,0
262.639,3.201,1
264.08,5.839,all the way up to 9
265.84,5.44,and then we use letters after that we go
269.919,2.56,a
271.28,4.8,b
272.479,3.601,all the way up to f
276.56,4.639,and so if we go
278.56,4.88,if we add a through f at the end of 0 to
281.199,4.081,9 we get 16 values
283.44,4.319,and so
285.28,5.6,if i was to write out a
287.759,6.88,hexadecimal number it would be a mixture
290.88,4.879,of or it can be a mixture of letters and
294.639,3.521,and numbers
295.759,4.481,and so for example
298.16,4.24,a2
300.24,4.56,f
302.4,2.4,9
307.199,4.881,is equal to
309.12,5.44,a which is actually 10
312.08,3.36,right because it goes 0 through 9 and
314.56,2.0,then
315.44,4.56,a
316.56,6.32,is represents 10 b represents 11
320.0,4.639,f represents 15. so this hex number is
322.88,4.96,equal to 10
324.639,5.84,times 16
327.84,2.639,to the 3.
331.28,5.12,i'm just going to move my
334.08,5.32,example here so we don't get so
336.4,3.0,cluttered
341.199,2.961,plus 2
342.8,4.0,times
344.16,5.759,16 squared
346.8,6.32,plus f which represents 15
349.919,4.161,15 times 16 to the 1
353.12,4.24,plus
354.08,6.08,9 times 16 to the 0
357.36,5.679,and if you do all of this math
360.16,5.28,and express it as a base 10 number
363.039,5.6,it ends up being equal to
365.44,3.199,um four thousand
368.88,3.92,or four sorry forty one thousand
371.039,4.321,seven hundred and
372.8,2.56,twenty one
376.0,5.28,and that's that's fine but again really
379.199,3.761,the the reason why we like hex numbers
381.28,5.12,is because it makes it very easy to
382.96,5.359,translate between hex and and binary
386.4,3.28,and so
388.319,4.521,i'll just give myself a little more
389.68,4.959,space here i'll delete the base 10
392.84,4.199,example
394.639,2.4,tweet
398.479,5.44,delete
400.56,6.479,so as i was saying each hex number
403.919,4.961,can be represented using four bits and
407.039,3.841,if you get good at it you start to
408.88,5.2,basically sort of remember
410.88,5.36,how the 16 values map directly to binary
414.08,8.48,and so the number 10
416.24,9.519,can be represented as 1 0 1 0 because
422.56,6.16,that's 8 and that's 2 right 8 plus 10 or
425.759,2.961,8 plus 2 is 10.
429.12,6.96,the number 2 is represented as 0 0 1 0.
433.759,6.081,the number f is the maximum number it's
436.08,6.0,15. so that's one one one one and then
439.84,5.199,the number nine is one
442.08,3.839,zero zero one eight plus one right and
445.039,3.761,so
445.919,7.28,very quickly we can go from the hex
448.8,6.399,number to its equivalent in binary and
453.199,4.56,so we're going to be heavily using
455.199,3.521,binary numbers hex numbers base 10
457.759,3.601,numbers
458.72,4.319,i typically um
461.36,5.2,when i'm using binary numbers i
463.039,6.72,typically won't put you know base to
466.56,5.68,i won't put base 16 for for hex numbers
469.759,4.481,most commonly when i'm using hex numbers
472.24,4.079,i will proceed it with
474.24,6.079,the prefix 0x
476.319,5.681,so if i write 0x12
480.319,5.28,that's not
482.0,4.4,equal to 1 times 10
485.599,2.801,plus
486.4,3.12,2 times
488.4,5.44,1.
489.52,4.32,instead that's equal to 1 times 16
496.24,2.239,plus
499.039,7.361,2 times 16 to the 0 right so 0x
503.199,5.201,represents a hex number sometimes i will
506.4,3.919,use 0b
508.4,3.999,to represent a binary number but
510.319,3.921,typically i won't because in most of the
512.399,5.681,examples when we're using binary it'll
514.24,3.84,be self-evident that we're using binary
518.719,6.56,now just a quick word about prefixes so
522.719,5.041,um in general most people are
525.279,7.361,familiar with the standard metric
527.76,7.84,prefixes so for example kilo means um
532.64,5.6,you know change my color here so
535.6,3.919,so kilo means a thousand
538.24,4.08,um
539.519,4.481,mega means a million giga means a
542.32,2.56,billion
544.0,3.92,and
544.88,6.32,we use these prefixes a lot when talking
547.92,7.359,about computers right we talk about a
551.2,6.96,250 gigabyte hard drive
555.279,5.201,sometimes we talk about a one
558.16,3.52,you know a one gigabit per second
560.48,2.72,ethernet
561.68,3.76,link you know talking about the the
563.2,4.24,throughput of the ethernet link
565.44,4.64,but kind of confusingly
567.44,5.519,typically when we talk about storage
570.08,5.52,memory size we're not using the standard
572.959,5.601,base 10 definitions of
575.6,6.0,kilo mega giga terra instead we're using
578.56,4.48,the base two definitions now
581.6,3.12,these base two definitions that i'm
583.04,4.16,showing them over here
584.72,3.76,have their own
587.2,4.639,words
588.48,5.28,so instead of talking about kilo
591.839,2.801,when we talk about
593.76,2.079,a
594.64,2.56,thousand
595.839,3.521,um
597.2,4.16,you know some of the prefix that's
599.36,5.28,roughly equivalent to a thousand in base
601.36,7.64,two we should be saying kibi and kibi
604.64,8.0,represents 2 to the 10 or in other words
609.0,4.92,1024 so when we talk about
612.64,3.92,one
613.92,4.56,but but confusingly most often like when
616.56,4.16,you look at computer vendor sites or
618.48,4.08,when you talk to people they'll still
620.72,4.48,use the
622.56,5.839,the metric term kilo so when we talk
625.2,4.16,about oh this is a one kilobyte
628.399,4.0,um
629.36,5.599,you know this memory can store one
632.399,4.401,kilobyte of data
634.959,2.841,we're talking about a memory that can
636.8,3.84,store
637.8,6.599,1024 bytes not
640.64,8.08,1000 bytes when we're talking about
644.399,5.361,a 250 gigabyte hard drive we're talking
648.72,6.64,about
649.76,7.519,a hard drive that can store 250 times
655.36,5.599,2 to the 30
657.279,4.56,bytes rather than 250 times
660.959,3.041,um
661.839,3.44,10 to the 9 bytes
664.0,6.0,now
665.279,6.641,i'm trying to change i guess right so um
670.0,4.88,you know when i can i will use the
671.92,5.12,prefix ki i g i
674.88,3.92,but really this is not what's still
677.04,4.479,typically done today like if you go on
678.8,4.32,to a computer vendor site you're buying
681.519,3.921,you know a solid state drive for your
683.12,6.64,computer they still will use the
685.44,6.639,standard metric um
689.76,4.16,standard metric prefixes even though
692.079,3.121,it's understood that when you're talking
693.92,3.44,about memory and you're talking about
695.2,4.24,storage the the prefixes correspond to
697.36,3.44,the base two definitions and that's the
699.44,3.04,convention that we're going to be using
700.8,4.24,in this class so whenever i talk about
702.48,5.52,memory size even if i
705.04,6.64,you know slip up and say kilobytes or
708.0,5.6,megabytes it's always the base 2 prefix
711.68,3.839,definition and when i talk about
713.6,3.919,anything else like if we were to talk
715.519,4.721,about you know the throughput or the
717.519,4.56,data rate of you know a digital link or
720.24,4.159,something like that then we'll use the
722.079,3.281,regular metric definitions
724.399,2.641,so
725.36,3.44,can be a little confusing if you just
727.04,3.28,remember like it's always base two if
728.8,2.719,we're talking about memory then you'll
730.32,3.199,be fine
731.519,4.801,and if you're you need clarification
733.519,5.921,obviously just ask
736.32,5.12,when working with memory we talk about
739.44,5.199,not only the the contents of the memory
741.44,6.079,but also we talk a lot about addresses
744.639,4.64,and memory addresses and basically you
747.519,4.961,know when we think of memory as an array
749.279,6.481,of bytes the address of each byte is
752.48,5.039,basically the index of that byte and so
755.76,3.28,um
757.519,4.241,if
759.04,5.12,this is the first byte in our array it
761.76,5.12,has index zero and we would say that
764.16,3.84,this byte is at address zero the second
766.88,4.0,byte
768.0,5.36,has index one and we would say that this
770.88,3.759,byte has address one so this index
773.36,4.719,column
774.639,4.481,is basically the address column
778.079,3.921,and
779.12,4.56,by convention in this class i will be
782.0,4.16,drawing memory
783.68,4.399,kind of from the bottom up so address
786.16,5.76,zero will always be at the bottom of the
788.079,6.32,memory diagram and then as we go up
791.92,4.4,the address of the bytes will
794.399,3.44,will increase and that's the the
796.32,4.4,convention that you'll see in most
797.839,5.44,textbooks most data sheets the only time
800.72,5.04,that you see it reversed is when you are
803.279,4.641,working with things like debuggers
805.76,4.0,or
807.92,4.64,programming environments that give you a
809.76,5.92,snapshot of memory on a real device
812.56,4.719,generally then they will show
815.68,4.159,you know let's say maybe a little bit of
817.279,5.041,a screenshot of your of your memory
819.839,4.8,content and they might show you you know
822.32,3.92,bytes or hex numbers
824.639,3.76,and usually
826.24,3.36,this is address zero
828.399,2.56,and then
829.6,4.4,this will be
830.959,5.68,um sorry this byte is address zero this
834.0,5.199,would be the address one this would be
836.639,4.961,address two you know and so on and then
839.199,4.161,it it sort of wraps around so when we
841.6,4.799,get into
843.36,5.839,using our simulator programs that give
846.399,3.601,us a snapshot of data memory and some of
849.199,2.88,our
850.0,4.639,development environments you'll see
852.079,5.12,memory represented in this way but for
854.639,4.081,the purposes of our lecture discussions
857.199,4.721,we're always going to use this kind of
858.72,3.2,bottom up convention
862.24,6.399,the other way we can picture memory is
864.56,8.24,as an array of words now
868.639,6.081,a word is basically a group of bytes so
872.8,4.32,memory space can be grouped into
874.72,5.2,multi-byte chunks called words
877.12,4.32,and when representing
879.92,4.719,um
881.44,7.04,a memory as an array of words typically
884.639,4.64,i will have several bytes all in a row
888.48,3.359,and
889.279,6.401,one of these rows represents a single
891.839,8.401,word so for example the arm processor
895.68,6.32,uses 32-bit memory or four-byte words
900.24,2.64,and so
902.0,2.399,the
902.88,3.04,one of these
904.399,3.68,um
905.92,4.159,rows represents
908.079,4.481,one word of
910.079,3.601,our 32-bit arm
912.56,2.88,memory
913.68,3.2,now
915.44,3.199,this is basically just the way i'm
916.88,5.44,drawing the memory you can still
918.639,4.64,obviously think of 32-bit memory
922.32,4.0,as
923.279,5.12,just being an array of bytes still where
926.32,3.84,the first four bytes correspond to one
928.399,3.841,word and the next
930.16,3.52,byte four bytes correspond to the next
932.24,3.12,word but it's just a little bit more
933.68,4.32,ease it's just a little bit easier to
935.36,6.159,visualize when you draw it this way
938.0,4.88,now as soon as you have multi-byte
941.519,3.521,words
942.88,4.879,you are presented with two different
945.04,5.44,options for
947.759,4.801,how to do your addressing you can use
950.48,3.919,word level addressing or you can use
952.56,3.6,byte level addressing
954.399,5.521,now
956.16,5.919,word level addressing is basically using
959.92,4.08,the indices
962.079,3.68,that
964.0,3.759,are basically using the word indices
965.759,3.921,right so that means
967.759,4.161,the first
969.68,3.31,four byte row of memory
971.92,2.479,will
972.99,4.93,[Music]
974.399,6.081,correspond to addresses zero
977.92,3.76,and if we
980.48,3.68,move this up
981.68,6.64,the next
984.16,7.039,row of memory corresponds to address one
988.32,4.319,the third row of memory corresponds to
991.199,2.401,address two
992.639,2.64,and
993.6,4.0,and so on
995.279,5.12,however other memories
997.6,5.28,arm is an example of this uses still
1000.399,4.641,uses byte level addressing even though
1002.88,3.6,we are working with
1005.04,4.4,four byte words
1006.48,5.359,and so what that means
1009.44,2.399,is
1011.92,5.44,the address of each word corresponds to
1014.639,5.361,the byte index of the smallest byte in
1017.36,3.68,the word and so
1020.0,2.959,this
1021.04,3.44,byte is
1022.959,4.88,byte zero
1024.48,6.079,this is byte one this is by two this is
1027.839,2.72,byte three
1033.919,4.721,this is byte four
1036.16,4.32,this is byte 5
1038.64,3.199,6
1040.48,4.4,7
1041.839,6.321,this one is 8 and so on and so the
1044.88,6.08,address of this first word
1048.16,4.639,i'll just change my color here
1050.96,4.4,the address of the first word
1052.799,4.961,corresponds to the byte index of the
1055.36,4.08,lowest or corresponds to the lowest byte
1057.76,4.64,index in that word
1059.44,5.76,the address of the next word
1062.4,5.76,is the lowest byte index in the second
1065.2,5.52,word the address of the third word
1068.16,4.879,is the lowest byte index in the third
1070.72,2.319,word
1074.16,5.2,and so as micro architecture designers
1076.559,4.881,how do we decide on the width of our
1079.36,4.319,words well basically the width of the
1081.44,4.4,words typically determine how many bits
1083.679,5.441,are operated on in parallel by the
1085.84,5.04,processor so if we have 32-bit words
1089.12,7.2,generally that means we're feeding
1090.88,7.6,32-bit numbers into our processor and
1096.32,4.08,the wider the word you know the more
1098.48,4.24,bits that are operated on by our
1100.4,4.399,processor at one time basically the
1102.72,4.88,bigger the numbers we can represent
1104.799,5.041,right so um
1107.6,3.199,wider words have more
1109.84,3.04,uh
1110.799,5.201,can allow numbers with more range and
1112.88,6.72,resolution the disadvantage of wider
1116.0,6.96,words is basically cost the wider
1119.6,5.28,your your words the wider the buses on
1122.96,3.76,your
1124.88,3.84,computer chip have to be in order to
1126.72,5.12,transfer all of those bits in parallel
1128.72,4.959,so a 32-bit word typically requires
1131.84,5.6,buses that
1133.679,6.88,consist of 32 parallel wires 64-bit
1137.44,4.32,words would be 64 parallel wires and so
1140.559,2.641,on
1141.76,2.56,and of course
1143.2,2.0,you know
1144.32,2.719,as
1145.2,3.359,at this particular time when i'm
1147.039,5.921,recording this video
1148.559,5.441,most modern processors are 64 bits and
1152.96,3.599,so
1154.0,5.28,if you buy a laptop
1156.559,5.521,even your smartphone
1159.28,7.639,typically those processors are 64 bits
1162.08,7.68,and it's relatively rare to see
1166.919,6.361,128 bits and so the reason why we
1169.76,5.84,haven't gone to 128 bits is that there
1173.28,6.96,today aren't very many applications that
1175.6,5.92,require numbers that big or resolution
1180.24,3.92,so a
1181.52,4.96,a bigger number will will give you will
1184.16,4.08,allow you to store larger numbers but
1186.48,3.199,will also give you more precision if
1188.24,4.4,you're using sort of a floating point
1189.679,5.601,number and right now 64 bits
1192.64,5.84,is enough to give us numbers as big as
1195.28,5.92,we need and as precise as we need and
1198.48,4.48,that won't change until we get onto
1201.2,4.16,applications that require bigger numbers
1202.96,3.76,or more more precision because right now
1205.36,3.12,we want to
1206.72,4.16,you know keep we also want to keep an
1208.48,5.04,eye on cost and so 64 bits is kind of
1210.88,4.88,that sweet spot between number size and
1213.52,6.159,expense
1215.76,6.96,so as soon as we have multiple bytes in
1219.679,6.161,a memory word we have to talk about how
1222.72,5.68,we're going to index the bytes within
1225.84,3.52,each one of those words and as it turns
1228.4,3.68,out
1229.36,6.24,historically there were two ways to do
1232.08,5.04,this and they were the big indian
1235.6,3.84,bite ordering
1237.12,4.0,convention and the little indian bite
1239.44,4.08,ordering convention
1241.12,3.919,and the terminology is
1243.52,4.08,actually from the book gulliver's
1245.039,3.361,travels so in gulliver's travels the
1247.6,4.64,king
1248.4,4.8,requires all of his subjects to
1252.24,3.439,um
1253.2,5.12,open their hard-boiled eggs
1255.679,4.88,on the little end and so
1258.32,4.16,um that's not a very good egg but if you
1260.559,4.561,were a little indian you had to open
1262.48,5.439,your egg on the little end
1265.12,5.6,the big indians were the rebellious
1267.919,5.361,subjects that decided to open their eggs
1270.72,4.56,on the big end and so that's that's
1273.28,3.92,where the the indian
1275.28,4.16,terminology comes from
1277.2,2.24,the
1283.12,3.439,the
1285.12,3.6,the big indian and little indian
1286.559,4.641,conventions were basically used
1288.72,4.4,excuse me by different
1291.2,4.88,processor companies
1293.12,4.88,now processor design companies
1296.08,3.76,but now before i go into explaining the
1298.0,4.64,difference between big nd and little
1299.84,4.959,indian i should say that the convention
1302.64,5.12,that we use for ordering bits within a
1304.799,4.88,byte are is always the same regarded
1307.76,6.32,regardless of which indian convention
1309.679,5.521,you use so if we look within a byte
1314.08,2.24,we have
1315.2,4.359,of course
1316.32,3.239,eight bits
1321.039,5.041,and the right
1323.919,4.0,or sorry the leftmost bit
1326.08,4.76,is called the most
1327.919,6.561,significant bit
1330.84,6.76,because this bit value when we convert
1334.48,4.079,it to a 10 base number is multiplied by
1337.6,2.24,2
1338.559,5.281,to the
1339.84,6.719,7 or 128.
1343.84,4.16,the rightmost bit is called the least
1346.559,3.681,significant bit
1348.0,5.12,because when we convert the byte into a
1350.24,7.12,10 base number the value of the least
1353.12,6.72,significant bit contributes only zero or
1357.36,5.36,whoops zero or one whereas the most
1359.84,4.56,significant bit contributes either
1362.72,3.28,0 or
1364.4,4.88,128
1366.0,3.28,to the value of the number
1369.36,5.199,so for the big indian convention
1372.0,5.52,we would use byte
1374.559,4.48,indexing for each of our words and so
1377.52,2.639,that means
1379.039,2.081,the
1380.159,4.321,word
1381.12,7.679,address for the first byte is zero the
1384.48,6.079,word address for the second byte is four
1388.799,2.961,the word address for the third byte is
1390.559,4.561,eight
1391.76,8.159,and the indexing for the bytes within
1395.12,7.679,each word goes left to right and so
1399.919,5.601,this is byte 0
1402.799,2.721,byte 1
1406.48,5.04,byte 2
1409.039,5.52,and byte 3. and so
1411.52,5.039,for the bytes that i've circled
1414.559,4.721,this first byte
1416.559,4.0,is word address 4
1419.28,5.6,right there
1420.559,6.641,and byte offset 2.
1424.88,4.399,the byte that i've circled up here
1427.2,5.359,is word offset 8
1429.279,6.241,and byte offset 0.
1432.559,5.921,as you can imagine little endian is just
1435.52,4.96,the opposite way so um
1438.48,3.76,with this little indian example we still
1440.48,4.559,use byte
1442.24,5.12,level word addresses so
1445.039,4.481,the first word has
1447.36,4.799,word address zero the second word has
1449.52,3.44,address four the third word has address
1452.159,4.88,eight
1452.96,8.24,but the byte ordering goes right to left
1457.039,6.24,so this is byte offset 0
1461.2,3.599,1
1463.279,4.161,2
1464.799,2.641,and 3.
1467.919,5.441,so this byte circled right here
1470.4,4.56,is word address 8 byte offset 0. the
1473.36,3.36,second address
1474.96,5.04,is
1476.72,4.8,would be word address 4 byte offset 2.
1480.0,4.0,now
1481.52,7.039,as i've noted in my slides the big
1484.0,7.6,indian convention was used primarily for
1488.559,4.881,primarily by motorola for their power pc
1491.6,5.52,processor which was
1493.44,7.119,an important processor in the
1497.12,4.64,late 80s certainly in the mid 90s
1500.559,3.36,and then
1501.76,4.399,little endian convention was mainly used
1503.919,3.281,by the intel processors
1506.159,2.4,but
1507.2,4.64,over time
1508.559,5.761,as motorola dropped its power pc
1511.84,4.24,product the sort of the champion for the
1514.32,4.479,big indian convention kind of
1516.08,4.64,disappeared and so now all major
1518.799,4.721,architectures today use the little
1520.72,5.6,indian convention so the the x86
1523.52,5.2,processors the arm core processors mips
1526.32,4.4,processors all use the little indian
1528.72,3.52,convention and so going forward little
1530.72,4.24,indian is what we're going to be using
1532.24,2.72,in this course
1535.039,4.481,so we've talked about
1537.12,5.439,memory organization memory addressing in
1539.52,4.8,a very general way we've talked about
1542.559,4.161,byte level addressing word level
1544.32,4.959,addressing words that can be a variable
1546.72,5.12,number of bytes we've talked about big
1549.279,6.081,endian little endian now i would like to
1551.84,5.36,conclude with a just a two real world
1555.36,3.6,processor examples
1557.2,3.2,and these are the two processors that
1558.96,3.76,we're really going to be talking about
1560.4,4.159,most in this course
1562.72,4.4,the first one or the first thing i want
1564.559,4.801,to talk about is how an arm processor
1567.12,4.0,organizes its memory
1569.36,3.28,we're not going to be doing any hands-on
1571.12,3.28,exercises with
1572.64,3.84,arm processors in this class but i'm
1574.4,3.92,going to be using arm as an example of a
1576.48,3.36,more sophisticated processor than the
1578.32,3.76,avr
1579.84,4.88,and as it turns out arm processors
1582.08,5.04,modern arm processors anyways
1584.72,5.199,default to little indian but they do
1587.12,6.0,actually support big indian
1589.919,5.601,byte indexing as well
1593.12,5.52,and depending on
1595.52,6.96,the version of processor
1598.64,5.36,they use either 32 or 64-bit words in
1602.48,3.84,most of our examples i'm going to be
1604.0,3.36,assuming 32-bit words
1606.32,3.2,and
1607.36,4.0,they use
1609.52,3.519,as i said byte-level addressing so if i
1611.36,2.64,was to draw a picture
1613.039,4.081,of
1614.0,7.6,arm memory it would look like this so
1617.12,7.72,we've got 32 bit or four byte words so
1621.6,7.28,each row of memory consists of four
1624.84,7.48,bytes by default we use little indian
1628.88,5.919,byte addressing so the least significant
1632.32,4.56,byte is byte 0
1634.799,4.561,and then we proceed all the way up to
1636.88,4.72,byte offset 3
1639.36,4.559,and because we use
1641.6,4.319,byte level addressing the address of the
1643.919,4.161,first word is 0
1645.919,3.76,address of the second word is 4
1648.08,4.0,8 and
1649.679,5.201,and so on
1652.08,5.839,the avr processor is interesting because
1654.88,5.519,it actually uses different
1657.919,4.321,addressing and word lengths depending on
1660.399,4.721,whether we're working with instruction
1662.24,4.799,memory or data memory remember the avr
1665.12,3.52,uses a harvard architecture it has
1667.039,4.321,completely separate paths for
1668.64,4.88,instruction and data memory and so it
1671.36,4.679,has this flexibility
1673.52,5.279,instruction memory is divided into
1676.039,5.0,16-bit words
1678.799,3.681,and it uses
1681.039,4.161,17-bit
1682.48,5.04,word addressing so word level addressing
1685.2,3.28,and the maximum
1687.52,2.8,um
1688.48,3.36,and and the addresses are stored using
1690.32,3.359,17 bits
1691.84,4.24,and so that means the maximum memory
1693.679,4.801,size is 128
1696.08,4.959,kilobytes where we're using the base 2
1698.48,4.24,definition of kilo or i could say kibi
1701.039,4.401,bytes here
1702.72,5.199,but even in the the avr data sheet
1705.44,4.16,you'll see that we use the they use the
1707.919,7.281,prefix kilo
1709.6,8.559,data memory uses 8-bit words and 16-bit
1715.2,5.12,byte level addressing and so the nice
1718.159,3.841,thing about the avr processor and also
1720.32,4.88,including the arm
1722.0,5.039,as an alternate example is you get a
1725.2,5.92,real sort of you get a lot of experience
1727.039,5.681,with different types of addressing and
1731.12,5.64,comfort with using different types of
1732.72,4.04,addressing schemes as appropriate
