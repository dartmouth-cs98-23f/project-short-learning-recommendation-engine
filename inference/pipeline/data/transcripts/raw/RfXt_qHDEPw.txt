second,duration,transcript
0.0,3.659,here's a stack of books from the library
1.8,3.959,now sort them in alphabetical order
3.659,3.421,computers have to do stuff like this all
5.759,3.001,the time it's a seemingly simple
7.08,3.12,requirement that can be accomplished
8.76,3.18,with dozens of different sorting
10.2,3.599,algorithms all of which have trade-offs
11.94,3.779,with no one optimal approach modern
13.799,3.48,languages have built-in functions to do
15.719,3.121,the heavy lifting for you but you won't
17.279,3.241,always have that luxury on a technical
18.84,3.3,interview or when doing low-level
20.52,3.419,systems programming in today's video
22.14,4.08,we'll not only Implement seven different
23.939,4.92,sorting algorithms and code but also see
26.22,4.2,and hear them in action thanks to an
28.859,3.0,amazing project called the sound of
30.42,3.18,sorting if you're preparing for a
31.859,4.141,technical interview these visualizations
33.6,3.9,and audibilizations will absolutely
36.0,3.78,change your life
37.5,3.6,major props to Teemo Bing men were
39.78,2.88,releasing these videos under Creative
41.1,3.24,Commons so we can use them in videos
42.66,3.239,like this I'm going to implement my
44.34,3.12,algorithms in JavaScript and then
45.899,3.361,Benchmark them at the end and you can
47.46,3.3,find the source code on GitHub but first
49.26,4.319,I want to check out an amazing product
50.76,4.26,from our sponsor jetbrains MPS to the
53.579,3.0,average developer building a custom
55.02,3.3,programming language sounds like an
56.579,3.96,impossible challenge however with this
58.32,3.78,open source IDE from jetbrains anyone
60.539,3.781,can build their own domain-specific
62.1,3.96,language like meta R which is a highly
64.32,3.119,specialized language for biomedical
66.06,3.599,students who would otherwise have to
67.439,4.561,learn how to program in R jetbrains MPS
69.659,4.081,is a logical editor as opposed to a text
72.0,3.36,editor allowing end users to interact
73.74,3.36,with the code visually this allows
75.36,3.96,non-programmers to easily integrate
77.1,3.78,their own domain logic then MPS will
79.32,4.02,generate the code for the underlying
80.88,4.02,platform like C JavaScript or any other
83.34,3.3,language that means anyone in the
84.9,3.719,organization can harness the power of
86.64,3.479,code in a safe easy to learn environment
88.619,2.941,along with all the awesome tooling you
90.119,3.721,would expect like code completion
91.56,4.019,debuggers and more to get started simply
93.84,3.599,download it for free and give it a try
95.579,3.72,now back to the program the first album
97.439,3.841,Rhythm will Implement is bubble sort
99.299,3.421,which in my opinion is the easiest one
101.28,3.479,to wrap your head around it works by
102.72,3.48,comparing adjacent elements then swaps
104.759,3.36,them if they're in the wrong order which
106.2,3.66,allows smaller elements to Bubble to the
108.119,3.421,top of the list first we'll set up a for
109.86,3.42,Loop for the length of the array inside
111.54,3.42,of which we'll Nest another loop that
113.28,4.08,Loops over the array minus the current
114.96,4.32,index in this Loop we can do swapping by
117.36,3.719,comparing the current index to the one
119.28,3.299,next to it if the left side is greater
121.079,3.421,than the right side then they'll need to
122.579,3.601,trade places if the process continues
124.5,5.119,until we go through the entire outer
126.18,3.439,loop and here's what it looks like
135.3,2.42,oh
143.239,4.36,bubble sort is intuitive but not very
145.8,3.78,performant its average time complexity
147.599,3.78,is O of N squared or quadratic time
149.58,3.48,which gets slower and slower as the list
151.379,3.601,grows longer this won't cut it in the
153.06,3.899,real world another fairly easy option to
154.98,4.02,implement is insertion sort which builds
156.959,3.78,up a sorted array one element at a time
159.0,3.78,but once again we start with a loop but
160.739,3.661,this time we start at index 1 or the
162.78,3.239,second value in the array we then set up
164.4,3.3,variables for the current value and
166.019,3.481,previous index and while the previous
167.7,3.899,index is greater than the current value
169.5,3.959,we move the previous value to the right
171.599,3.601,then we move to the left until we find a
173.459,3.181,previous value that is smaller at which
175.2,4.2,point we can insert the current element
176.64,5.0,here's what it looks like in action
179.4,2.24,foreign
204.72,3.42,once again we have a nested Loop here
206.58,3.36,which results in quadratic time
208.14,3.599,complexity but in practice it can still
209.94,3.6,be pretty fast if the input data is
211.739,3.72,already mostly sorted another similar
213.54,3.36,approach is selection sort it works by
215.459,2.881,finding the smallest element in the
216.9,3.0,array and exchanges it with the element
218.34,3.479,at the beginning then repeats this
219.9,3.96,process until it's fully sorted once
221.819,3.901,again we Loop over the entire array and
223.86,3.36,then add a nested Loop inside of it but
225.72,3.599,this time we're looking for the minimum
227.22,3.84,value in the subarray in this nested
229.319,4.021,Loop if the minimum value doesn't equal
231.06,3.959,the current value then we swap them out
233.34,3.179,which will effectively put the smallest
235.019,3.121,element in the proper position then
236.519,5.121,repeat that process across the entire
238.14,3.5,array but let's check it out
241.92,2.959,foreign
246.02,5.32,[Applause]
248.599,4.661,also results in quadratic time next up
251.34,3.24,we have merge sort which is a divide and
253.26,3.78,conquer algorithm that's been around
254.58,4.86,since the 1940s the idea is to break the
257.04,4.02,main array into subarrays sort them and
259.44,3.12,then merge them back together unlike the
261.06,3.24,other examples we've looked at this one
262.56,3.48,is implemented recursively first the
264.3,3.66,recursive function finds the midpoint of
266.04,3.599,the array then we have a base case here
267.96,3.36,that will stop the loop when the array
269.639,3.421,length is less than two we then break
271.32,3.18,the array in half at the midpoint using
273.06,3.48,splice and then we call the same
274.5,3.419,function on both halves but in order for
276.54,3.54,that to work we'll also need to
277.919,4.081,implement a merge function that does the
280.08,4.14,actual sorting it Loops over both arrays
282.0,4.139,simultaneously Compares their values and
284.22,3.419,adds them in order to a new array then
286.139,4.821,finally it merges everything back
287.639,3.321,together here's how it looks
291.84,2.419,oh
308.54,4.719,it's a bit more complex to implement but
311.28,3.72,performs much better at quasi-linear
313.259,3.481,time that's why a variation of merge
315.0,4.02,sort is the algorithm implemented under
316.74,3.42,the hood for array sort in JavaScript as
319.02,3.0,well as many other languages and
320.16,3.78,applications one drawback though is that
322.02,4.019,it doesn't sort in place and requires
323.94,4.14,extra memory if that's a problem a
326.039,3.901,similar alternative option is quick sort
328.08,3.6,it's also a divide and conquer algorithm
329.94,3.539,that uses a pivot element to create
331.68,3.299,subarrays that are sorted recursively
333.479,3.361,with quicksort the array isn't
334.979,3.78,necessarily split in half and works with
336.84,3.419,any ratio to sort the array in place
338.759,3.601,we'll first create a function called
340.259,4.141,Partition its job is to divide the array
342.36,3.6,into two parts to separate the elements
344.4,3.299,smaller than the pivot from the values
345.96,3.78,greater than the pivot in this case the
347.699,3.84,pivot value is set to the element at the
349.74,3.179,right index of the array from there we
351.539,3.541,Loop over the portion of the array
352.919,3.84,between the left and right values if a
355.08,3.179,value is less than the pivot value then
356.759,3.361,we swap it with the element at the
358.259,3.481,partition index from there we can create
360.12,3.419,a recursive function called quick sort
361.74,3.6,to divide and conquer both the left and
363.539,3.72,right side of the array this is the more
365.34,3.359,proper way to implement quicksort but we
367.259,2.821,can illustrate the concept A little
368.699,3.121,better by cheating in this more
370.08,3.66,simplified function notice how I'm first
371.82,3.9,determining a pivot point on the array
373.74,3.48,then we divide and conquer by filtering
375.72,3.24,out items that are less than the pivot
377.22,3.3,on the left side and items that are more
378.96,3.54,than the pivot on the right side now
380.52,3.959,call that recursively to sort the entire
382.5,3.9,array that works but it won't perform as
384.479,3.481,well as the previous implementation in
386.4,3.799,any case let's go ahead and watch it on
387.96,2.239,TV
395.34,2.12,thank you
408.79,3.039,[Music]
412.819,4.361,next up we have Radix sort which was
415.44,3.66,created all the way back in the 1800s
417.18,3.959,for tabulating machines it's still used
419.1,3.78,today on values like integers or binary
421.139,3.301,strings because it takes a unique
422.88,3.42,approach where it groups items that
424.44,3.84,share the same significant position or
426.3,3.899,place value the implementation is a bit
428.28,3.84,more complex but basically it works like
430.199,4.381,this it splits the elements of the array
432.12,4.019,into 10 buckets one for each digit 0
434.58,3.48,through 9. it then Loops over those
436.139,3.721,buckets and has a nested Loop for the
438.06,4.02,array itself get digit will then find
439.86,4.14,the number at that place going from 0 to
442.08,3.72,9 which provides a bunch of sorted
444.0,3.419,buckets that are combined back into the
445.8,3.239,original array what's interesting here
447.419,3.241,is that there's no direct comparison
449.039,3.6,going on we're only looking at the
450.66,4.5,underlying digits this implementation is
452.639,4.321,called LSD or least significant digit
455.16,3.42,but it's also possible to work in the
456.96,3.72,other direction with most significant
458.58,4.26,digit that's pretty cool let's check it
460.68,4.82,out
462.84,2.66,oh
468.97,3.059,[Music]
474.72,4.56,and finally I saved the worst for last
476.94,3.659,BOGO sword also known as stupid sword
479.28,3.18,this would be like if you had a deck of
480.599,3.6,cards and kept shuffling them over and
482.46,3.48,over again and just hope that one time
484.199,3.661,they're in perfect order it's totally
485.94,3.659,random to implement it I have a helper
487.86,3.839,function called Shuffle that takes the
489.599,3.901,array and randomizes all the elements
491.699,3.541,with the math random function then I
493.5,3.419,have another helper function that Loops
495.24,3.239,over the array to determine if it's
496.919,3.421,sorted or not then we simply put those
498.479,4.141,two together in a while loop until we
500.34,5.12,get a sorted array not surprisingly it
502.62,2.84,looks pretty wonky
508.86,3.0,to finish things up I made a quick
510.479,2.761,Benchmark just to test these
511.86,3.0,implementations and here's how
513.24,3.179,everything played out bubble sword and
514.86,3.479,cocktail shaker sort were near the
516.419,3.36,bottom well Heap shell and quicksort
518.339,3.181,were near the top but it really depends
519.779,3.18,on what you're sorting this graphic from
521.52,3.06,Top towel illustrates how different
522.959,3.0,types of input data change the
524.58,3.18,performance characteristics of these
525.959,3.421,algorithms a10x engineer needs to
527.76,3.36,understand the trade-offs and implement
529.38,3.72,the optimal algorithm luckily for most
531.12,3.18,of us we can get by with a race sword so
533.1,2.94,basically everything you learn in this
534.3,3.479,video is completely useless on a
536.04,4.94,practical level thanks for watching and
537.779,3.201,I will see you in the next one
