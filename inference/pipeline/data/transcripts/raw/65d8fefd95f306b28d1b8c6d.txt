we've seen sort of compositionality of
programming languages where terms are
made up from sub terms and maybe
semantics are defined by induction on
this subterms structure so so we've seen
this in you know Gordon Stark
Christine's talk many many talks okay
and then there's the other kind of
compositionality that we've seen mostly
for example from people who work in
string diagrams and categorical quantum
mechanics david Spivak stark was full of
stuff like God so is Jamie's and you
know John's and Brandon's and Ross isn't
a lot of lot of people so we've seen two
different kinds of compositionality they
have some things in common but they're
still somewhat different and what I will
tell you about is sort of one one
attempt to marry these two worlds
actually together so five years ago I
was part of a big project for the US
government and we were developing a
quantum programming language the purpose
was not to actually program a quantum
computer because they don't actually
have one we think but of course if they
did it would be classified but as I
understand it the main purpose was to do
resource estimate so implement some
actual quantum algorithms from the
literature and then figure out how many
what powers of ten you know like how
many gates or resources these algorithms
would actually consume so as part of
this project we developed the quantum
programming language quicker quicker
which I will talk more about and we also
had to it was sort of a given sort of
goal of the project to implement seven
quantum algorithms that they specified
okay so they were not trivial algorithms
like teleportation but they were really
complicated algorithms like estimating
the ground state of some molecule or
playing the game of hex one of the
algorithms played the game of hex was a
winning strategy for hex and it's faster
than the classical algorithm and one of
them was solving a linear system of
equations which everyone thinks it's
easy until the equations are until
they're exponentially many equations in
exponentially many variables then again
it's something
you can do on a quantum computer faster
and and there were several other things
like walking around random grab random
walk you know quantum random walks on a
graph and things like that so very so so
this language that we implemented is
scalable in the sense that we have
generated quantum circuits with I think
some of the largest ones was 30 trillion
gates okay so these you know it's quite
scalable compared to say if you do
teleportation all right which has like
five gates one of the algorithms dealt
with doing some computations in number
theory actually computing the class
number of some kind of ring okay and to
do that sort of thing you need to
manipulate sort of in a quantum way
quite complicated data structures like
data structures for example representing
an ideal in a ring okay
so we have in inquire we have quantum
data types similar to sort of data types
in a usual programming language and
among these types of course we things
like lists and trees but also more
complicated types and we actually have a
whole fix point real number computation
sort of we implemented fixed point real
numbers with functions like plus and
times and sine and cosine and the
hyperbolic cosine and so on all in in
sort of this quantum setting so it's
quite scalable in pig and it's high
order so you have functions inputting
other functions this often happens when
some circuit is depending for example on
a family of Oracle's or something like
that and the whole and we had to do this
very quickly so quit was actually
originally sort of designed in about six
months and to implement all seven
algorithms took another year after that
and in order to be able to do it fast we
embedded the whole language in Haskell
which is an existing functional
programming language and when you write
an embedded language you can basically
do it very fast because you don't have
to write a new compiler in your type
checker and you anything just use the
infrastructure of the existing
programming language and one of the
disadvantages of being embedded in
Haskell is that the language didn't end
up being completely type safe
Haskell has many wonderful features but
one thing it doesn't have is linear
types and another thing it doesn't have
is dependent types and if you don't have
those two things it's not going to be
completely typesafe for quantum language
so let me actually show you quicker for
a second here I could probably spend the
rest of the I could spend all the time
just demoing web because it has many
interesting features but I just want to
give you very quickly a flavor okay so
here's a very simple Ripper program for
for constructing a circuit that takes
the and the boolean and you know of a
bunch of bits it's written as qubits
here but these are actually classical
gates you know they're all in the
classical basis so if you want to add
together two bits and I'll put another
bit then what you do is you you generate
a third bit initialize it to false and
then you do a control not gate which
will negate the third bit if and only if
the first two are both equal if if and
only if the first two are both equal to
one okay so that's good that's this
control not gate here and then you
return see so that's as as you can see
it's a functional program okay with me
in a functional programming language and
then when you want to end together a
list of it then you do the obvious thing
if the list is empty you return true if
the list is a singleton you return just
Q which is actually redundant but for
singleton I didn't really want to return
Q and true so as a sort of slight
optimization we have a singleton right
and then if you have a longer list you
just add together the tail of the list
and then you do one more and with the
head of the list and you turned out so
it's functional okay it's just writing
more or less ordinary functional
programs and then there is a bit of
plumbing here print generic preview
means print this quantum circuit as a
graphic and then use the previewer to
display it and this is the function that
that we want the quantum circuit that we
want to view and replicate 10 cubed is a
parameter that tells you because this
function actually will take any list of
qubits as an input but when we want to
actually view it the quantum circuit we
need to pick out a particular
member of the family so here we're
picking the circuit with 10 cubits for
example okay so if I run this little
program so you see at the top of the
page it says import Clippers so that's
that's where the embedded language
actually lives and as as you will so
let's run this and tada you know it
generates the quantum circuit for adding
together ten bits it's not the most
ingenious circuit for doing this you
could do this with logarithmic Li many
ancilla instead of instead of n okay but
it's exactly what the what this program
does and you could write a more clever
program if you wanted to here we're
designing the programming language we're
not trying to write clever programs
another example is the algorithm for the
binary welded tree that's some kind of
walk on a graph you have a graph with
some kind of nodes and you they're
colored and you're trying to find the
unique node with some property by
randomly walking around on this graph
and I just wanted to show it as a quick
example just so you see that you know
relatively large quantum circuits can
easily be generated with these
functional programs so here you have
some kind of Oracle this is some kind of
Oracle implementing like some edge
finding computing whether or not there
exists an edge computing actually the
neighbor of a vertex in the graph then
there's then you do something whoops
kind of hard to let me switch to a
better view here fit fit height okay
it's no keyboard shortcut for that
whoops yeah there is some kind of Oracle
and there's some kind of step that this
all these gates are classical all of
them are just control knob gates you
could apply them to ordinary bits it
wouldn't have to be qubits at this point
then there's a relatively small part of
the circuit where it's actually quantum
that's the actual time step you do a
kind of basis change then another kind
of basis change then you perform a
single quantum gate here which is
actually some kind of tiny rotation but
about about some angle and then you undo
the bases change and then you undo the
whole Oracle and so on this is sort of
how these quantum algorithms work and
okay so that's the idea of crapper you
write a functional program and it
generates the circuit for you now what
could I do with my slides I think I have
quit my slides
again all right now but it wasn't
typesafe okay so what we're currently
working on is making a sort of type save
redesign of paper now five years have
passed we have a bit more time the whole
project doesn't have to be finished in
six months so we want to actually from
the bottom up actually design a
programming language for that does
exactly the same thing that creeper does
but that has some kind of theory some
kind of soundness theorems and hopefully
you do educational semantics okay
and we call these languages proto
creeper all all of the languages that we
might develop that I sort of quicker
like currently are called proto quiver
for prototype creeper okay okay so let
me end and what I want to tell you about
today is we actually have a denotational
semantics for proto quicker now which i
think is quite neat so what is proto
quicker how should we think about it
it's a it's a language for describing
families of quantum circuits not just a
quantum circuit but a family of quantum
circuits you might want you might want
one of the inputs to be a parameter like
the number of bits that this circuit
should have or the number n that you
wish to factor if you want to use a
quantum computer to factor okay or any
other or you know or any kind of
parameter so a per app so when you have
a language for describing the family of
circuits this is very similar to a
hardware description language this kind
of thing exists right programming
languages for specifying hardware and
what all these hardware description
languages or circuit description
languages have in common is that they
have two different runtimes first you
run the program and it generates the
circuit then you run the circuit and it
generates some output okay and these two
levels are separate you cannot change
the circuit after you've already started
running it for example so that's why
there is a distinction between parameter
and state so a parameter is some value
that is known at circuit generation time
such as the number of qubits or
something like that
and a state is a value that's known when
the circuit actually runs such as the
value of an actual qubit in the circuit
or a bit in the circuit also if you have
classical circuit and informally the
state can be a function of the
parameters you
initialize a bit you know from a boolean
but a parameter cannot be a function of
the state and that's basically the
essential thing that our denotational
semantics has to capture so I will start
with a simple model of parameters and
state and this is very surprising
because it's a very simple category
theoretical model here in fact this we
have seen this model sort of as a model
for other kinds of phenomena and it's
interesting that it works here so let to
be a to object category so I mean the
category with two objects and one
non-trivial morphism between them and
there's also two identities so it's a
two object three morphism category and
consider the factor category set to the
two up okay
every category theories knows what this
is most of you are not category
theorists so let's just describe it
concretely an object of this category is
a triple consisting of a set and another
set and a morphism between them like
this vertical this vertical a here is a
morphism is an object of the category
and then a morphism of the category is
just one of the commutative diagrams
okay now why in the world should this
have anything to do with parameters or
state or quantum programming languages
we can think of these so if you have one
of these here's your a1 that's a set
okay I'm just talking about a set a 0 is
a sent okay this set a zero has some
elements maybe set a1 also has some
elements and there's a function between
them mapping you know these elements to
those elements
we if one of these elements here is
called little eggs we think of the
elements of the lower set as the
parameters okay so here's a parameter
little X that's an element of the set a
zero then above this lives a certain
subset of a one namely just those things
that are mapped to a zero right so we
call this the fiber over X and we call
it a sub X okay and here's another
element Y for example and then use the
fiber a sub y sometimes the fiber can be
empty sometimes it's singleton and
sometimes it has more than one element
so we think of these elements as the
parameters and once a parameter is given
then you have a set of states okay think
of the upstairs things as the States but
the set of states is not just a set but
it's a set of states all over X and
another set of states over Y and so on
for example if a parameter is the length
of a list of bits then if you have a if
the parameter is 5 then you have 32
elements which are all the bit list of
length 5 but if the parameter is 6 you
have 64 elements and so on so we
structure so we have a state and per
state and parameters and and I have this
on the next slide but without a picture
okay
so this this fiber is correct and then
the interesting thing is how we think of
the morphisms now so suppose you have
another one be p1 p0 right you another
bunch of states and they also have
fibers you know like B sub Z okay now a
morphism is by definition a commutative
diagram so that means a func first of
all a morphism is a function f 0 from
parameters to parameters and second of
all then for every second we also have a
function here F 1 from States to States
but it's not arbitrary the diagram has
to commute and if you think for a second
about what it means for the diagram to
commute it just means that any state
over X must be mapped to a state over F
0 X so you have a map from parameters
through parameters and then
for each little X you have a map from
the fiber to the corresponding fiber so
that the state Maps must be somehow
compatible with with the parameter part
and now you can see that you know for
example if if this point here we're
being mapped to to a point over here in
one of these fibers then you can see
that that point is somehow a function at
this point but also of a Y in a sense
but at the point that Y Maps who is only
a function of Y like if this is a 0 of Y
F 0 of Y will be the same thing even if
you look at different states if you vary
the state but keep in the same fiber
that does not change F 0 Y and this
formula is this intuition that
parameters the parameter is a function
of parameters but state is a function of
state and parameters ok so that's
basically the whole idea now what's a
simple idea and in fact this is a
well-known model for example in security
where you talk about classified and
unclassified information and you have a
new policy is that classified
information might depend on unclassified
information like you can read something
in a newspaper and then still put it in
a classified document but you cannot
read something in the classical
Declassified document and then put it in
a newspaper so so all the all the
unclassified output should only be a
function of the unclassified input but
the classified output can be a function
of everything so they use exactly this
model actually for in that situation but
but it's a different interpretation ok
go and then what I have in mind but it's
the same model and surprisingly we can
get relatively far with this simple idea
so here's here's some examples of object
so bool is of course the the type of
true and false but viewed as a parameter
so that here I have a two element set
and the identity function that means
there's two boolean parameters to run
false and then over each of them the
state is the the fiber is just a
singleton so the object bowl we can
think of as the boolean that are known
at circuit generation times
and time and they have basically only
parameter and then trivial state and
conversely you have bit which is in some
sense also bullion but this is bullion
state things that will be known at
circuit runtime and you have no
parameter the bit has no parameter but
it has a two different kind of state
okay so the object so I didn't I I think
on the slide I have but I didn't say we
say a generalized element of this object
is just a pair it's just a generalized
element it's just a pair of a of a
parameter and a state such that you know
such that a of the state is equal to
that parameter so so this object has two
generalized elements namely 0 0 and 1 1
which we can identify with false and
true and this object also has two
generalized elements namely star 0 and
star 1 if we think star is the unique
element of the singleton set here and we
also identify these with false and true
and now there is easy it's easy to see
that there's a morphism from rule 2 bit
mapping false - false intruder true but
there isn't a morphism from bit - bool
mapping false or false and true - true
that's because this diagram commutes but
you cannot possibly make this diagram
commute this question mark here doesn't
actually have a solution that this again
sort of formalize is the idea that
parameters should not be functions of
state of course there are functions from
from BigTable there are commutative
diagrams but they're not going to be the
identity up here in fact the only two
existing ones are the two constant
functions indeed you can have a constant
function you know that depends on the
stage okay so it this is not yet a model
for quantum circuits okay I didn't have
any quantum thing in this model this is
sort of a model for let's say well let's
sort of see what kind of programming
language we get in this model actually
my game is I will first define a model
and then I will define the programming
language that fits the model okay so
what kind of programming language would
fit this model here well first of all
it's it
the Cartesian clothes category so
certainly you know vanilla simply typed
lambda calculus can be immediately
interpreted in there with no problems
category also has Co products so I can
have some types you know disjoint Union
types basically bull and bit we've just
seen our objects in this category so
these can be base types my lambda
calculus has a type bool and a type it
also this function in it from bolt AB it
would for example be a morphism that can
be a constant in my lambda calculus and
I have other things here for example
constant story falls and if-then-else
construction as well as built in gates a
gate would be something like a function
from bid cross bid to a bit like which
we think of as a gate in a circuit
rather than when if it were from bull
cross rule to bull then it's like
if-then-else in the programming language
but it's from bit cross bit to bit then
we think of it as a gate okay the sort
of thing that will be evaluated at
circuit run time rather than circuit
generation time so we have all that
moreover the category is complete so we
have initial quality bruh initial
algebra of of continuous factors in
other words we have inductive datatypes
here as well natural numbers lists the
trees you know all the usual types so
that's quite a rich programming language
actually and and so it's a simple
functional programming language for
describing families of boolean circuits
these are ordinary boolean circuit so I
have bit by a fool I don't have qubit
right but you have gates such as and for
example so this this describes ordinary
circuits not the reversible kind and
that's you can actually use this
programming language it's actually quite
convenient and type safe all right
because it has a model but we want to do
oh sorry there's more structure in this
model even that I haven't talked about
yet there are five functors between set
and set to the two up and all of them
are add joins to each other in this way
and from these are junctions so here's
what the functors are there's an imp
there's an obvious embedding from set
where you just take a set and let a 0
and a 1 both be that same set and take
that kind of thing is called a parameter
type a type that has just parameter and
no state like bool is an example of
something of that shape okay and then it
turns out to have both left and right ad
joints and they interns have left and
right joints and of course this is not a
new thing to category theories true for
any pre-shift category that you have you
know such factors but for us it's
interesting because the fact that these
who are are in a junction for example
gives you a comonad on the model and
that common ad will be the bang of
linear logic we are not going to really
use it here because we have sort of
classical circuits and we not are not
worried about linearity but later the
bang of linear logic will come in handy
when we are in a linear setting and then
certain things might be nonlinear
similarly the fact that you have in a
junction between these two factors gives
you all gives you a monad on the object
and that one that also has a
computational interpretation we call it
the shape monad but I will actually sort
of skip that one out in the interest of
time but so we have interesting stuff
and like I said the bang kind of course
the bank kind of Court well I'm going to
skip the bank okay because we're going
to get to the bank again later what I
want to do now is do a model of proto
quicker so reversible circuits of some
kind or quantum circuits should be
synthesized here now my model was very
set theoretic okay absolutely it was
Cartesian and so on it's not clear how
you're going to get linear logic really
in there in sort of a meaningful way so
when we want to make a model for proto
paper we should ask at a fundamental
level what is Pro gripper well it's a
language for describing families of
quantum circuits so what in the world is
a quantum circuit now I could go and
define it okay it's a certain pictorial
diagram made up from boxes or whatever
but actually it's much better to take
the abstract point of view and say a
quantum circuit you know definition let
a symmetric mulato category of quantum
circuits be given okay a quantum circuit
therefore is just a morphism
of a symmetric monado category so this
so we the whole language connect
should be described at this generality
doesn't matter what your category of
quantum circuits is only matters that
it's symmetric monoidal so you take your
favorite gate set take quantum circuits
over Q bits or Q trades or just or have
bits in there also and measurement or
whatever whatever you want to gate set
to be that's your monoidal category so
proto paper the generalized view is that
proto paper is a language for describing
families of morphisms in a symmetric
melodic category no longer even have to
talk about quantum which is nice I think
most people don't like quantum mechanics
for some reason they like to think about
it but yeah anyway so we need so we need
to keep now we need to keep the best
parts of this model that I just
described but we need to make it work
with the monoidal category rather than
set ok so how do you do that turns out
this category is set to the to up has
many properties some of which I already
discussed what what is the property that
we need to generalize now it turns out
the viewpoint is something of it's
surprising set to the to up among all
the other things that it is is also the
freako product completion of set ok as i
think john or someone pointed out that
definition of Korpela completion already
has set built into it because set itself
is the free core product completion of
the one object category that's exactly
what we will generalize so here's the
model on one slide that's the whole
definition everything after that will be
theorems ok more or less fix a symmetric
model category of em of circuits this is
a concrete category we imagine that if
we had a morphism in this category we
could print it out in some way ok or
display it or put it in a data structure
these will be the actual circuit it may
have some distinguished objects such as
bid cubed q trait ok and maybe some
distinguished morphisms called gates
whatever they are is up to the user of
the programming language but let's say
there are some distinguished objects
morphisms called gates so this is given
ok
now we're going to construct the model
in two steps and then after that we're
going to construct the programming
language to fit this model first we're
going to fully embed em in some
arbitrary way in a semantic monoidal
closed category M is only symmetric
monoidal so it has tensor products but
it doesn't have function spaces which
would be appropriate for circuits all
right but we're going to fully embed it
in a symmetric model closed category
that means we add the function we add
the high order structure for example and
and also we want this category m bar to
be product complete as well this can
always be done for example by the UN a
dilemma with the date answer or you
could do it in the freeway or you could
do it the point is in my model
construction I'm not even going to
specify how we're going to do this I'm
just going to specify that we're going
to do this and as a consequence any
theorems that I prove later will be
independent of the particular way in
which I have done this which means I
will never actually compute anything in
a generic category or anything like that
all the theorems will - will be
independent of how you do that so that's
a purely abstract thing it only exists
to support the high order structure at
the end of the talk someone will ask is
the model fully abstract because
everyone feels obliged to ask a question
like that but full abstraction while is
of great theoretical interest has no
practical application whatsoever and the
proof is whether or not it's fully
abstract depends entirely on how you
chose this category m bar if you choose
it freely then it will be fully abstract
if you choose the eunetta I'm I will be
manifestly not fully abstract but the
point is the model will be adequate and
ground fully abstract which means
anything that we can write down at
ground type that will be distinguished
by the model if and only if it's
distinguished in reality all right and
at higher types
it's the abstract question not only do
we not answer it but we manufacture the
definitions so that tough question
cannot have an answer and I think
there's actually a point there you know
so referees beware right
so that's first what we do so that's the
category of state in a sense and then we
add the parameters by letting M double
bar be the freako product completion of
M bar not Coe limit but Co product
competition what does this concretely
mean the objects of M double bar are
going to be families of objects of M bar
essentially sequences of objects of M
bar but could be indexed by a set rather
than just by some natural numbers so an
object concretely is a pair consisting
of a set X and then an X index family of
objects of the category m bar so the set
X is this but rather than saying over
each little over each element of this X
we have a fiber that's a set we're
saying over H X we have a fiber that's
an object of the category m bar the
fibers are object of M bar and then the
morphisms are the appropriate thing so
think of so the picture is the same
right the bottom guy is still an
honest-to-god set but here I have this a
sub X is now an object of the category
it no longer has elements right this a
sub y is an object of the category M bar
and a morphism now we'll be a pair F 0
of a morphism between the underlying set
and then for each X for each little X
sort of a morphism of the category m bar
that's called F sub X which goes from a
sub X 2 to B sub F of X B sub F 0 of X
right and that's exactly the definition
of morphism that's written on the slide
it's the thing that it has to be if you
want to follow you know what we did
before but this category M double bar
has surprisingly many properties
obviously it has Co products because I
added them freely so certainly it will
have Co products okay the fact that it's
monoidal the fact that it's symmetric
monoidal is also not too surprising
because you can sort of imagine the way
you define the melodic structure is
completely straightforward right you
take the Cartesian product of the states
and then for each given pair of states
you take the tensor product of those two
parameters spaces over those states and
it's it's it's not surprising to me
that gives you monoidal structure so the
parameters are the elements of the set X
and the states are virtual right they
would be they live in the object a sub X
but they're not elements of course
because that's not a set but we don't
have to talk about States we're talking
about circuits which are morphisms right
we think of States as sort of existing
but yeah so so these are so we don't
have States but we have state spaces
okay the fact that it's symmetric
monoidal closed is actually surprising
to me at least so you have this semantic
model structures actually close normally
when I freely add co-products to
something I don't expect it to be closed
because that's not one of the structures
I sort of explicitly preserved but there
is you can check there exists these
function spaces and it actually does it
give you give you a right adjoint to the
tensor product moreover there is an
obvious embedding offset in M double bar
which just takes the set X and then the
trivial fiber over each element which is
the the unit of the of the tensor and
that functor again has a right edge
right just like it did before maybe also
surprising and this Junction actually
forms a nonlinear nonlinear model of
intuitionistic linear logic in exactly
the sense of Benton 1994
so there's a model of linear logic right
here so and we don't have cold limits
because I only add a co-product freely
but it turns out usually you need Co
limits to do initial algebra because you
want to do 0 arrow F of 0 arrow F of F
of 0 arrow F of F of F of 0 and then
you're going to take the cool limit of
this whole sequence that's how you
construct the initial algebra for the
factor f this factor this one this
category only has Co products but it
turns out that's enough to compute the
sort of initial algebras that we're
interested in namely if you have
functors that are only built from sum
and product then it turns out the co
limit that you have to compute turns out
to actually be an infinite co product so
so this you can actually interpret
inductive types in here for example list
of qubit is a type is an object in this
category
okay or at least a bit or even the
natural numbers or trees or any of these
other so you have so we have quite a lot
so we have boolean we have natural
numbers an object is a parameter object
if all its state spaces are trivial we
have sort of basic objects for the
category M so these are wire types like
bit and qubit labeled you know objects
of the category M correspond to labels
on wires and then we have gates and and
it turns out the and and we have a model
of linear logic okay and the in the in
the in the model bang of you arrow T if
you and T are objects of M then bang of
you arrow T is actually a parameter
object whose underlying set is exactly
the home set of uart so the elements of
bang you era T or the closed values of a
are you of that type are going to be
exactly the circuits from you to T so
then we define so now we have okay it's
it's mano de close so we can interpret a
standard linear lambda calculus in it
with co-products also we can have base
types like bit cubed bull we have
inductive types and we can and the
variables that happen to be off
parameter type of type bang a can also
be duplicated so even though you have a
linear lambda calculus it's you know for
ordinary lambda calculus for those you
can also have some external operations
like you saw in my quiver example at the
end I printed the circuit for example
and I viewed it in Acrobat Reader so if
you have a function print which takes
you far mahom set to a set of documents
then this actually that's external to
the category M but it would internally
turn into a morphism in my model so even
the print function lives in the model
okay and then you make and now we make
the programming language that basically
contains all this stuff I told you so
these are the types you know we talked
about all these operations sometimes our
parameter types and you can say
syntactically what they are simple types
correspond to objects of the original
category m and sir corresponds to
circuits contexts are as usual judgments
are
as usual and the terms and typing rules
are as usual because everyone knows what
a linear lambda calculus is okay the
only thing that's maybe slightly
different is a further bang bang is a
common ad so you have lift and force
okay so that's really sort of as simple
as it can be and and of course when you
have parameter types then they do
pickable so you can use them in both
hypotheses so Tara now I've made a
language to fit this model now we also
made a operational semantics for this
language I've done alright and then it
satisfies all the usual theorems in
particular it sound so you have a small
step semantics each state denotes a
morphism of the category when one state
reduces to another state they denote the
same morphism therefore the initial
state and the final state denotes the
same morphism therefore the program
therefore the operational semantics
computes the same circuit as the
denotational semantics so that makes the
language sound and as Gordon pointed out
the sound semantics is automatically
adequate I always forget to say this in
my papers I just proved soundness and
forget to say it's adequate and then
later some someone else writes a paper
saying it was not known to be a decrypt
and you know now we've proved it to be
adequate this actually has happened so
the end thank you very much
[Applause]
you're a mathematical abstraction I'm
not disagreeing with you or your
methodology here but I think you're
overstating things a bit okay
as an example of level abstraction is
useful is when people are doing
compositional bubble checking you're
looking at program fragments so knowing
that the semantics of respect to each
other model checking is for the abstract
is actually directly used there in
showing that you're you're in a
verification apply to the open piece of
program is relevant to the observation
you're absolutely correct I was being
political of course there are some good
reasons to want to proof fully up full
abstraction results in these sort of
situations yes however even if it but
often if you have a model for something
and and and you're not fully abstract at
the high order types but as long as you
sort of fully abstract at the
ground-types
for many practical things says
absolutely all you would ever hope for
or even want so of course there are
exceptions like when you want to reason
about all programs in some for example
in an adversarial context like
photography and you want to reason about
all attackers you think of the attacker
as being a morphism in the models
composition I know that the PLC for so
there's yes that based off take it with
a grain of salt right what I said I
don't mean this as a criticism but I
think finally one said that
good thing about quantum computing is to
help us understand quantum mechanics so
might ask what's the best choice for
heaven and far but maybe not ask a
question different choices of M&M bar
give different properties of sugar
different choices of M will just give
you different classes of circuits so we
can use this same language as a language
for describing so the program would
behave in one way semantics right and
that's right
the M is sort of like the signature of
the language usually when you define a
language you say and then there are some
arbitrary base types and constant
symbols for example you might want to
have a language about natural numbers
and then you have one kind of base types
and constant symbols if you want a
language about boolean you have
different kind of base type and constant
symbols so that's a signature the M gear
plays the role of the signature the
given set of gates and types over which
but the interesting thing is that the
rest of the language then works
uniformly you know as the signature was
given embedding into n bar doesn't make
any difference as long as it's full and
faithful I mean it doesn't make any
difference to the theorems that that we
could I may have misheard you but you
rule of d-wave as doing quantum
computing I didn't say anything about do
you buy up to them I mentioned that if
they had a quantum computer be using
will of it up to something
if the NSA had a quantum computer that
could factor then they would certainly
keep that classified I don't think the
d-wave machine can factors so whether
it's a universal quantum device I have
no opinion about relate this question
very well but I'm probably not the first
person to ask it so maybe you can give
Fitbit answers the question I should be
asking fine so in describing this is a
language for producing quantum circuits
and I think when you refer to the
operational semantics the end you were
describing the operational semantics of
the construction officer something a
little bit different here compared with
the way we think about classical
programming languages and so for example
you shows a very enormous circuit at the
beginning so if you imagine using quick
butter to end up actually doing
computation I don't think you're
suggesting the Clipper would construct
this enormous circuit which you don't
physically built and feed data through
it's not these are not Hardware circuits
well this is my this is my question
so I mean by analogy with them so say
when you define a classical programming
language and give it it operational
semantics what you're doing here seems
to be a bit like saying that the
operational semantics of a a Java
program is the process of constructing
an assembly language program but that
does the same computation no no no no
whenever you have a operational
semantics let's say a call-by-value
language because this is call by value
it turns out for example you describe
you have your big step semantics which
somehow evaluates your program to a
value and we consider for it sort of
observable to be values of ground-type
like for example bool in many languages
you just take bulls or integers it
should be the final log you know we have
all your high order programs and so on
but at the end of the day you compare
like whether two programs compute the
same boolean so here what the point of
view is that a circuit is an observable
so the circuit is the thing that you are
actually computing
the circuit itself is just a list of in
list of gates and the list of kids it's
a personal hardware brand it's something
you would pass as a set of instructions
say to a quantum computer so yeah that's
actually that is what what it computes
right this is this is the difference
between clipper and the and the quantum
lambda calculus the quantum lambda
calculus is also a high order language
for quantum computing but we imagine it
running sort of directly on the quantum
computer or with access to the quantum
computer so when you do a measurement in
the language the measurement will be
done when you apply a gate in the
language the gate will be applied but in
fact it turns out one thing when you
want to actually implement quantum
algorithms that are non-trivial there's
a lot of meta operations in the research
paper it might say it is well known that
such-and-such program can be solved in
polynomial time
therefore they exist a boolean circuit
for it now use the standard trick to
make this building circuit reversible
then you know turn it into a quantum
circuit then apply amplitude
amplification which is another sort of
strategy that takes the circuit and
produces another circuit so it turns out
for all these higher operations you want
to treat these circuits actually as data
not just as something that you do on the
quantum computer but the circuit itself
is constructed and then modified so this
you can do in this is sort of the whole
philosophy of crepper for example you
have constructed a circuit and now you
would like to decompose it into a
different set of elementary gates
typically what you can do in propelling
languages okay thank you very much
you
