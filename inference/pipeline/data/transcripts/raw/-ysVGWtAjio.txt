second,duration,transcript
0.03,3.119,in the future quantum computers have the
1.8,2.88,potential to solve certain problems
3.149,4.321,exponentially faster than classical
4.68,4.89,computers but which problems can they
7.47,3.93,solve exponentially faster and which
9.57,3.93,problems would we do just as well to
11.4,3.27,solve using a classical computer so
13.5,2.85,these are the questions that we're
14.67,4.14,really interested in as quantum
16.35,4.08,algorithms researchers now to set the
18.81,3.42,stage it makes sense to talk a little
20.43,3.839,bit about the relationship between
22.23,4.86,algorithms and computer hardware more
24.269,5.01,generally a computer is a programmable
27.09,5.189,machine which obeys the laws of physics
29.279,5.251,an algorithm is a recipe for solving a
32.279,4.05,problem so an algorithm is a sequence of
34.53,4.619,steps that leads you to the solution of
36.329,4.05,course if you design an algorithm you
39.149,3.121,have to make sure that the machine you
40.379,4.68,plan to run it on can execute each of
42.27,6.51,those steps generally speaking this is
45.059,5.401,not much of a problem because algorithms
48.78,3.24,designers like to abstract away the
50.46,4.919,machine and work using a basic
52.02,5.46,instruction set that can then be mapped
55.379,3.631,to the machine afterwards and one of the
57.48,3.599,central principles of theoretical
59.01,4.29,computer science is that if you use the
61.079,4.86,right basic instruction set then any
63.3,5.42,real-world machine you could build you
65.939,5.701,can run that algorithm on it
68.72,5.53,this central tenets of theoretical
71.64,5.1,computer science held up for about 50
74.25,5.43,years but we now understand that there's
76.74,5.309,one exception to this rule and the
79.68,4.43,exception is quantum computers quantum
82.049,4.5,computers use a fundamentally different
84.11,3.82,instruction set than classical computers
86.549,3.271,as a result they can run different
87.93,4.38,algorithms algorithms you could not run
89.82,4.439,on classical computers those algorithms
92.31,4.53,make use of quantum effects like
94.259,4.261,nonlocality entanglement superposition
96.84,3.63,and interference and so when you're
98.52,4.26,designing a quantum algorithm your aim
100.47,4.38,is to exploit those quantum effects to
102.78,4.019,make you get the solution faster
104.85,4.74,generally speaking an algorithm might
106.799,5.28,start by taking your classical input to
109.59,4.5,the problem processing that into a
112.079,4.381,quantum state which is a superposition
114.09,5.4,of an exponential number of classical
116.46,5.04,States you then aim to transform that
119.49,3.87,quantum state which encodes the problem
121.5,4.049,into a quantum state which encodes the
123.36,4.92,solution and from that quantum state you
125.549,4.591,measure and you get the solution now of
128.28,3.75,course to make this work it's a bit of
130.14,3.03,an art and you have to design an
132.03,2.76,algorithm which
133.17,4.38,follows these these steps for a given
134.79,4.38,problem and some of the areas where we
137.55,2.519,have such algorithms where we have
139.17,2.88,quantum speedups
140.069,4.741,include the simulation of quantum
142.05,5.01,systems number theoretic problems like
144.81,4.47,integer factorization and certain types
147.06,4.259,of search problems now one of the
149.28,3.87,caveats is that most of these algorithms
151.319,3.481,are designed for future quantum
153.15,4.32,computers which have many many Cubans
154.8,4.89,and right now we're at a moment where
157.47,4.2,people are building small and modest
159.69,3.51,size quantum computers and so it's an
161.67,3.12,exciting research area to understand
163.2,4.08,what can we do with those devices before
164.79,4.79,we have basically an unlimited number of
167.28,2.3,qubits
