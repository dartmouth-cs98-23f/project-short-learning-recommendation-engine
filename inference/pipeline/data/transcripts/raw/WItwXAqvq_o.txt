second,duration,transcript
0.08,4.88,into this what is functional programming
2.56,3.839,so there's not going to be a lot of
4.96,2.959,code that i'm going to show it's mostly
6.399,2.561,going to be talking about concepts and
7.919,1.921,functional programming there'll be a
8.96,2.88,little bit of code
9.84,3.44,and talking about what people mean by
11.84,5.04,functional programming
13.28,4.64,and how we might uh want to broaden
16.88,2.399,what people mean by functional
17.92,3.04,programming to talk about some other
19.279,4.321,stuff in this meetup
20.96,3.84,so uh first of all if you're going to
23.6,2.64,talk about functional programming it's
24.8,3.92,going to talk about what a function is
26.24,3.84,right so at its base a function is a map
28.72,4.8,between inputs and outputs
30.08,7.84,specifically it's a map so that for any
33.52,6.24,set of inputs you get one output
37.92,3.28,of course you can define you can define
39.76,3.6,this in a lot of different ways
41.2,3.92,you can sometimes you'll see a table
43.36,3.359,like right here you'll have a table
45.12,3.36,where you have inputs on the left and
46.719,2.481,outputs on the right or you'll see it in
48.48,2.399,like a
49.2,3.039,more mathematical setting where you have
50.879,4.481,like f of x and then some
52.239,3.121,transformation on x
56.0,4.8,and then you know this this mathematical
59.44,1.919,definition of a function is a little bit
60.8,2.88,different
61.359,3.281,than the way we use the word function in
63.68,4.16,programming
64.64,5.839,which generally means procedure we mean
67.84,4.72,some place where we're going to run a
70.479,3.761,piece of computation and then bring the
72.56,3.199,results back to
74.24,3.04,the main loop or the main part of the
75.759,3.601,program so
77.28,3.36,when functional programmers say
79.36,3.68,functional programming
80.64,3.519,they mean viewing your computation
83.04,3.439,through this lens
84.159,4.32,through this idea of inputs and outputs
86.479,2.401,and the closer you can get to that the
88.479,3.6,more
88.88,5.12,like um functional programming
92.079,4.08,the more sorry the more functional
94.0,3.759,programming you're doing
96.159,3.521,yeah so like i said what is functional
97.759,3.601,programming common answer
99.68,4.079,the basic unit of computation is a
101.36,2.399,function
106.24,3.68,so that being said when you actually do
108.96,2.32,functional programming
109.92,3.519,a lot of times it doesn't really look
111.28,2.96,like what you're doing is writing down
113.439,3.121,functions
114.24,3.28,and then computing inputs and outputs
116.56,3.44,instead
117.52,4.239,things look pretty crazy and this is a
120.0,3.2,sample of reason
121.759,4.0,i could have just as easily put a sample
123.2,4.08,of haskell or scala or
125.759,3.041,really any functional programming
127.28,3.28,language i've ever used
128.8,3.28,while it's while i can understand how
130.56,3.28,i'm using functions
132.08,3.68,it oftentimes doesn't feel like that's
133.84,2.56,what i'm doing so i wanted to talk a
135.76,3.52,little bit
136.4,4.32,you know about what is it that we're
139.28,2.4,getting if it's not just about inputs
140.72,2.08,and outputs
141.68,3.84,what is it that we're getting out of
142.8,6.24,functional programming
145.52,5.04,but first i was really curious uh just
149.04,3.199,how many of you have actually written
150.56,2.319,programs in a functional setting before
152.239,2.08,i guess
152.879,4.481,raise your hand if you've written
154.319,4.64,functional programs before
157.36,3.76,okay pretty good probably about half the
158.959,5.761,group so
161.12,3.6,that's that's awesome and
165.28,3.12,i guess raise your hand if you'd like to
167.04,4.24,do it again
168.4,4.24,i guess judging from you know being here
171.28,2.88,that's really great
172.64,3.44,um you know a lot a lot of people
174.16,3.2,haven't a lot of people don't really
176.08,2.48,know what it is that
177.36,3.28,uh functional programmers are talking
178.56,4.399,about if they've ever heard of it at all
180.64,4.16,um so i'm gonna try and go through some
182.959,4.081,of what it is
184.8,3.2,so before i was talking about you know
187.04,2.24,what a definition of functional
188.0,4.319,programming is and i'd say it's
189.28,4.56,computation as a base unit of a function
192.319,4.081,but to try and be a little bit more
193.84,4.16,intuitive maybe it'd be better to stop
196.4,4.96,and think about like what do functional
198.0,5.92,programming languages have in common so
201.36,3.12,also what do people who do functional
203.92,2.56,programming
204.48,4.72,what do they seem to want out of the
206.48,4.24,languages they're using
209.2,3.2,and then if you're not a functional
210.72,2.239,programmer why might you want to learn
212.4,2.559,about it
212.959,3.601,whether you you know go and get a job as
214.959,3.041,a functional programmer or not
216.56,3.2,you know you might still want to know
218.0,4.159,about it for
219.76,5.28,for several reasons and then lastly you
222.159,6.561,know what kind of problems are really
225.04,3.68,does this stuff really work well for
230.239,5.36,all right so first what do functional
232.239,3.36,programming languages have in common
235.84,4.16,so i would say even above mapping inputs
239.28,2.8,to outputs
240.0,3.92,the idea that functional programming
242.08,2.56,languages really have in common is
243.92,2.72,separating
244.64,4.319,the transforms of data from the data
246.64,3.84,itself
248.959,3.2,compare that to an object-oriented
250.48,3.839,approach where you're
252.159,3.761,defining a class and then that class is
254.319,3.92,going to have methods
255.92,3.76,so in fact you define your data first
258.239,3.441,that's the class and then you define the
259.68,3.76,methods that operate on the data
261.68,3.6,in functional programming instead you're
263.44,5.44,going to define
265.28,5.12,a set of functions that take data
268.88,3.28,and then it's up to those functions to
270.4,2.239,define whether that data is acceptable
272.16,2.56,or not
272.639,3.84,either through a type system or through
274.72,4.479,a set of you know conditional checking
276.479,2.72,and contracts
279.28,3.199,but they the reason that you would want
281.36,3.04,to isolate
282.479,4.081,the transformations of data from the
284.4,4.48,objects is
286.56,4.4,maybe subtle does anybody maybe have a
288.88,5.039,thought of why you might want to split
290.96,6.88,your data from the objects transforming
293.919,3.921,the data
299.919,3.601,so yeah so he said you don't know what
301.68,4.079,data you have and um
303.52,3.84,i think that that's uh that's a really
305.759,3.28,good point and
307.36,3.04,what that might mean is you do know what
309.039,3.121,data you have right now but you don't
310.4,4.88,know what data you're going to have
312.16,4.8,so what
315.28,3.6,what you can do with a function if
316.96,2.72,you're if you're dealing with just a
318.88,3.039,transformation
319.68,3.519,you can extend that transformation in
321.919,2.72,the face of a lot of different data
323.199,4.801,without having to modify all the
324.639,3.361,different definitions of that data
329.52,6.16,so another reason that you might want to
332.88,5.2,separate data and transforms is it makes
335.68,4.48,it easier to write correct programs
338.08,3.76,so a lot of the rest of this is going to
340.16,3.599,be about program correctness
341.84,3.28,and at least when i was in school
343.759,3.44,learning about programming program
345.12,3.519,correctness was almost an afterthought
347.199,3.28,i felt like you know like there was
348.639,2.481,maybe you maybe had like one proof class
350.479,2.0,maybe had like
351.12,2.639,just a little bit of talk about it and
352.479,1.921,then the rest of time was hey go out and
353.759,1.841,write there
354.4,3.2,if your program does what it's supposed
355.6,3.599,to do it's correct right like what else
357.6,3.2,more do you need and
359.199,4.081,i think that that's i think that's a
360.8,5.36,pretty decent
363.28,3.28,way of thinking about programming until
366.16,2.159,you
366.56,3.12,hit more complicated systems and more
368.319,3.361,difficult problems
369.68,3.68,and then suddenly it starts to fall
371.68,3.44,apart and you really want to know that
373.36,5.52,your program is going to be robust
375.12,6.96,to varied inputs and is going to behave
378.88,4.319,in an expected manner and i think that
382.08,2.559,that more than anything is what
383.199,2.081,functional programming allows you to
384.639,2.4,have
385.28,5.039,is are programs that behave how you
387.039,3.28,would expect them to behave
391.68,3.6,yeah so what do programmers seem to want
393.68,3.92,so i'm going to answer
395.28,3.199,that for me at least the thing i care
397.6,4.08,most about
398.479,6.481,are programs being correct
401.68,3.92,obviously i need them to run fast but if
404.96,2.959,i wanted
405.6,3.12,just speed i'd be writing in c which
407.919,3.12,i've done and
408.72,3.919,didn't like so here i am writing
411.039,2.401,programs in languages much slower than
412.639,4.0,that
413.44,4.0,um what you know what are some other
416.639,2.321,things that
417.44,3.599,you guys think that you know functional
418.96,5.359,programmers like what do you care about
421.039,3.28,or what do you find valuable
428.24,4.399,yeah so he said transparency in your
430.08,5.04,code and i think that's a really big
432.639,4.161,big thing is being able not just to have
435.12,3.519,a correct program but to make it so that
436.8,4.0,everybody can tell that it is right like
438.639,6.081,those two things are very important
440.8,5.44,um so in fact like my next slide is
444.72,3.039,this is all very going very well
446.24,4.16,everybody's answers just lead me right
447.759,4.56,into the next thing so that's awesome um
450.4,3.44,yeah so like obviously functions make it
452.319,3.041,easier to determine inputs and outputs
453.84,2.799,that's actually in the definition of a
455.36,2.8,function right so it should
456.639,4.321,should at least be able to do that very
458.16,4.96,well and
460.96,3.04,in addition to that it makes it easy to
463.12,3.04,see what your code
464.0,3.44,is doing and i have an example coming up
466.16,4.479,to show that
467.44,6.08,so i say that functional programs
470.639,4.721,make it easier to write correct code
473.52,4.72,because it makes it easier to determine
475.36,4.8,what's coming into your program what's
478.24,3.76,going out of your program
480.16,3.599,it's easier to demonstrate that your
482.0,3.52,program is correct either in the form of
483.759,3.041,a proof or just casually just like
485.52,2.799,walking someone through it
486.8,4.959,because you have inputs and outputs it
488.319,19.521,becomes much easier yeah jordan another
491.759,16.081,reason is
512.959,3.921,because the function does exactly what
515.279,4.801,it does and it's not touching much of
516.88,3.2,other things
520.13,3.06,[Music]
525.36,5.039,oh yeah i i uh so so jordan
528.56,3.6,jordan was saying that the the fact that
530.399,5.841,functional programs tend to
532.16,5.84,um they they tend to discourage
536.24,3.12,side effects so when you write a
538.0,2.959,functional program most functional
539.36,2.88,programmers tend to write their code so
540.959,2.641,that the inputs and outputs of their
542.24,1.76,program are the only things that are
543.6,3.76,going
544.0,4.08,on so because of that you don't have to
547.36,3.039,worry about
548.08,3.6,some encapsulated state changing on you
550.399,4.401,that you didn't know
551.68,4.56,was going to change possibly by some
554.8,5.12,other
556.24,5.36,part of the program that's a huge thing
559.92,3.76,and that that property of things not
561.6,4.88,changing on you without you
563.68,4.0,expecting it it allows the composability
566.48,2.16,and allows so many of the nice
567.68,4.08,properties of
568.64,3.84,functional programming in fact i have a
571.76,3.92,whole
572.48,5.2,slide dedicated to composition so
575.68,3.279,yeah so you know i think this really
577.68,2.08,shows like people who do functional
578.959,2.56,programming like
579.76,3.519,we're all wanting the same things like
581.519,4.961,we're all wanting our code
583.279,4.641,to be easy to read easy to reason about
586.48,2.96,and then the composition is really
587.92,2.08,important because it's no good to just
589.44,3.12,have one
590.0,3.839,small piece of a program easy to read
592.56,3.04,and easy to reason about
593.839,3.761,in fact i'd argue you can get that in
595.6,3.12,just about any dynamic like you can
597.6,3.12,always
598.72,3.359,come up with a way of writing one piece
600.72,3.2,of a code
602.079,3.44,and make it so that people can follow it
603.92,3.359,what becomes difficult is whenever you
605.519,3.601,have multiple developers
607.279,3.521,or complex systems and you're trying to
609.12,3.52,compose those pieces together
610.8,4.56,and still feel good that each piece
612.64,5.84,independently and as a whole is correct
615.36,4.4,i mean i i don't want to act like
618.48,2.799,functional programming is a silver
619.76,2.4,bullet to that problem i think that is
621.279,3.841,the problem
622.16,4.48,in uh computer software i would say
625.12,4.56,functional program is a great
626.64,6.4,tool to help with it um
629.68,5.12,but if if you have a if you have a
633.04,4.64,better idea for how to do it i'm
634.8,4.08,i'm all ears but that i think is a very
637.68,2.64,very powerful
638.88,3.04,property of functions because you're
640.32,3.199,mostly dealing with inputs and outputs
641.92,3.84,where you don't have side effects
643.519,3.521,you can compose sets of inputs two sets
645.76,5.44,of outputs
647.04,4.16,to develop more complicated behaviors
653.04,3.52,so i'm going to do a very very simple
655.76,4.56,example of
656.56,6.64,proving a function so
660.32,3.28,um raise your hand if you ever had to do
663.2,4.4,any
663.6,5.76,proofs in uh your c either cs courses or
667.6,3.919,on your own
669.36,3.52,yeah yeah so i see like four hands up
671.519,2.961,which i mean i never
672.88,4.16,i think i did in i think i had to do
674.48,3.359,horror logic proofs in one class in a cs
677.04,2.72,theory class
677.839,3.601,let me tell you this isn't going to be
679.76,2.639,that you're going to be very happy with
681.44,4.48,this proof
682.399,5.44,so it's really silly
685.92,3.52,so first we have we have several suits
687.839,2.961,so we have clubs spades hearts and
689.44,3.92,diamonds and then we have a color
690.8,3.12,red and black and we're going to write a
693.36,3.84,program
693.92,6.56,that tells you what color your suit is
697.2,5.84,based on what suit it is so its input is
700.48,4.24,going to be oh i have this backwards
703.04,4.16,that's so bad
704.72,3.84,uh this should say this should say suit
707.2,2.879,so you can't prove your name is right it
708.56,3.279,can only improve your structures right
710.079,5.2,which i actually have a slide about
711.839,5.361,but um yeah so suit and then the case
715.279,3.921,of suit is going to either be a club a
717.2,4.079,spade a heart or a diamond
719.2,4.0,right there can be no other input
721.279,3.281,because we've defined our input
723.2,3.28,there can be no other output because
724.56,5.44,we've defined our output
726.48,5.919,so the proof
730.0,4.24,is unbelievably easily easy right it's
732.399,3.68,just a proof by termination you just you
734.24,3.76,just prove termination by exhaustion
736.079,3.44,you have all your inputs you just simply
738.0,3.2,work through every single input and then
739.519,4.081,you have all your outputs
741.2,3.84,that might seem like a little thing but
743.6,3.2,i mean
745.04,3.599,the fact that you have completely bound
746.8,3.2,your input for that problem and then
748.639,2.561,completely bound your output
750.0,3.68,means you never have to worry about
751.2,4.639,something like that being wrong
753.68,3.52,you can imagine taking this and adding
755.839,3.761,more complexity maybe
757.2,3.439,it's a club with a number and a spade
759.6,2.96,with a string
760.639,3.921,but in each case you can you can work
762.56,4.48,through the same sort of idea
764.56,5.36,and be very very sure that that part of
767.04,4.479,your program is correct
769.92,3.44,there's no way that side effects can
771.519,3.361,happen there's nothing in here that can
773.36,3.52,mutate something else
774.88,4.72,and i made it a ridiculously simple
776.88,4.079,example on purpose
779.6,3.12,and there are you know plenty of
780.959,3.281,examples where it does get just too hard
782.72,3.84,to prove something
784.24,4.32,but the fact that you can decompose the
786.56,4.959,pieces where you can prove it
788.56,4.56,you can decompose the uh program into
791.519,3.201,pieces that you can prove and then just
793.12,2.399,leave as a kernel the part that's really
794.72,2.72,hard to prove
795.519,4.081,and then write tests around that piece
797.44,3.68,or monitoring that around that piece
799.6,3.12,instead of having to consider all these
801.12,2.56,other pieces and test through all those
802.72,4.4,other pieces
803.68,6.64,i think that's a really powerful and
807.12,3.2,worthwhile technique
810.56,3.04,but yeah so if you're looking for
811.92,3.2,something more than this for the proof
813.6,3.2,then there there isn't anything like i
815.12,2.959,mean i could i could write like a qed i
816.8,3.92,could write qed at the bottom
818.079,3.76,i guess and then that would be in proof
820.72,2.4,land for sure for real
821.839,2.56,but that's what i want to say like when
823.12,2.8,you know when functional programmers
824.399,2.88,talk about proving things it's
825.92,2.8,i mean sometimes you know you're using
827.279,1.92,things like structural induction and
828.72,2.479,like
829.199,3.44,complicated methods but i mean that's
831.199,3.281,not that complicated but
832.639,2.961,um but a lot of times it's just this
834.48,2.719,it's the fact that you can actually read
835.6,2.799,your inputs and outputs and because you
837.199,2.561,can read your inputs and outputs you
838.399,3.44,already know what the function does
839.76,3.439,it's a very it's a very short argument
841.839,2.321,if you're talking with another developer
843.199,2.0,and you read through your inputs and
844.16,2.799,your outputs and
845.199,3.281,you guys all see what it does and
846.959,2.801,usually you discover that somebody typed
848.48,5.76,color instead of
849.76,4.48,uh suit in your function
854.839,4.761,yeah so um
858.32,3.36,if you're not a functional programmer
859.6,5.28,why might you care about these things
861.68,6.399,um and this is kind of what i
864.88,4.72,uh what i would go back to is like all
868.079,2.641,programmers when they're writing code
869.6,3.28,have to decide
870.72,4.32,when their program is correct the
872.88,3.44,standard that you use to define that
875.04,3.12,depends on the kind of code you're
876.32,3.04,writing and you know the environment
878.16,2.479,that you're writing a lot of times
879.36,3.039,deadlines and
880.639,3.281,schedules make it impossible for people
882.399,3.921,to prove every single part of a program
883.92,2.4,correct
886.48,4.159,so you have to answer that question in
889.12,3.279,some way or another and it's good to
890.639,5.281,have a good definition
892.399,4.641,of that you should also know what parts
895.92,2.8,of the program
897.04,3.359,what parts of your system you don't know
898.72,3.359,the answer to that question like
900.399,3.041,what is correct behavior what is not
902.079,3.2,correct behavior and that's
903.44,3.199,surprisingly common too especially in
905.279,3.041,microservice systems
906.639,3.44,there are lots of microservices that are
908.32,3.6,defined where parts of the system
910.079,3.361,are just undefined like you don't you
911.92,2.64,don't really have a good answer to what
913.44,3.36,that behavior
914.56,3.12,should be it happens the behavior
916.8,3.36,happens but
917.68,3.279,you know like why it happens is often
920.16,4.08,left as an
920.959,5.201,exercise for the user um
924.24,3.44,and then i think another part of this is
926.16,3.2,okay so you have your you have your
927.68,2.079,business deadlines you have all that
929.36,3.44,stuff
929.759,5.76,but can you
932.8,3.2,confidently say that over time the code
935.519,2.641,that
936.0,4.56,is in your system is getting better and
938.16,3.28,not worse so as you add features and add
940.56,3.04,pieces
941.44,4.079,are the things that you're writing
943.6,2.72,making your code base better do your
945.519,3.201,refactors
946.32,3.519,actually reduce bugs you know things
948.72,2.96,like that
949.839,3.601,i think that the answers in functional
951.68,3.519,programming are all very solid for all
953.44,4.079,these things especially the last one
955.199,3.601,you know at our company we do a lot of a
957.519,3.841,lot of fast development
958.8,4.719,very fast development and i think it's a
961.36,2.399,huge benefit that we can then go back
963.519,3.361,and
963.759,5.121,iterate that the code that we've written
966.88,5.36,and make it better each time and feel
968.88,3.36,more and more confident in it
974.8,5.12,yeah so i think a lot of the times
978.24,3.12,the answers to the questions about how
979.92,2.159,do you prove a program correct or
981.36,3.36,cultural
982.079,4.081,right so you write tests you use test
984.72,3.919,test driven development
986.16,3.679,you check for code coverage and i think
988.639,2.401,those are great answers i think
989.839,4.721,everybody should be doing that
991.04,6.64,you know you definitely should what
994.56,5.519,what i feel like is that
997.68,4.079,we can have a little bit more but i do
1000.079,3.68,want to talk you know specifically i
1001.759,3.52,want to talk about ruby people because
1003.759,3.361,uh you know that's a community that i've
1005.279,3.761,never been involved with um
1007.12,3.279,but i listen to a lot of podcasts and
1009.04,2.4,one of the podcasts to listen to is a
1010.399,3.12,ruby podcast
1011.44,3.759,i'm always impressed with uh the way
1013.519,3.601,that they
1015.199,3.361,they talk about naming and they pay a
1017.12,2.399,lot of attention to the way you name
1018.56,4.079,things and the way you
1019.519,4.401,write your code i think a lot of that
1022.639,3.121,has to do with the fact that it is
1023.92,3.44,completely untyped and so much is
1025.76,2.559,changeable and so much is flexible in
1027.36,3.04,the ruby language
1028.319,4.161,so you have to be very careful about
1030.4,3.919,cultural things
1032.48,3.04,like you know naming conventions and
1034.319,4.64,testing conventions
1035.52,4.159,stuff like that um but i guess this is
1038.959,2.0,where
1039.679,2.721,the reason i want to bring this up was
1040.959,2.88,to talk about like why you might care
1042.4,2.72,about functional programming even if
1043.839,2.48,you're not going to be a functional
1045.12,2.959,programmer it's like
1046.319,3.521,i find value in learning about other
1048.079,3.921,programming languages even though i'm
1049.84,3.92,you know i probably am never going to
1052.0,2.24,write any ruby code i never say never
1053.76,2.88,but
1054.24,4.24,i've never written any but um it's still
1056.64,5.2,very interesting and i learn a lot
1058.48,3.36,learning about that language
1062.72,7.199,um yeah so i think that to write
1066.88,4.799,good systems you have to use everything
1069.919,4.481,that you can possibly use so
1071.679,4.24,great culture is important and you know
1074.4,3.519,managing complexity
1075.919,3.441,technically also is important and i
1077.919,2.481,think that the technical management of
1079.36,2.48,complexity is where functional
1080.4,4.639,programming really
1081.84,4.64,shines so that's
1085.039,2.801,that leads me into the next part of what
1086.48,4.079,i what i want to talk about which is
1087.84,5.839,what i want this to be
1090.559,6.561,i would like to see us
1093.679,5.12,take this meetup and turn it into a
1097.12,4.48,meetup where we're talking about tools
1098.799,2.801,and techniques
1101.76,6.08,to write better code that are not
1106.4,3.76,sort of on the culture side that are
1107.84,4.16,more on the technical side
1110.16,3.6,um and especially ones that are outside
1112.0,3.44,of the mainstream so you know i think
1113.76,3.52,choosing an alternate programming
1115.44,2.88,language for this is definitely outside
1117.28,2.56,of the mainstream
1118.32,3.599,i think theater improvers would be
1119.84,3.6,outside of the mainstream
1121.919,3.441,some languages are kind of like right on
1123.44,3.359,the border like rust rust is becoming
1125.36,4.88,pretty mainstream so
1126.799,3.441,but it's still really interesting
1130.64,5.52,and then fp adjacent subjects just like
1133.679,3.281,uh just like the core of functional
1136.16,3.12,programming
1136.96,3.44,our functions well once you introduce
1139.28,3.12,the idea of a function there are all
1140.4,5.12,these other concepts in mathematics
1142.4,5.04,that are related to functions logic type
1145.52,3.519,theory category theory and then linear
1147.44,3.52,logic
1149.039,3.52,that's a sub display of logic but i want
1150.96,2.4,to call out specifically because of rust
1152.559,4.24,and so
1153.36,4.4,um i would love for us to start doing
1156.799,2.561,some talks
1157.76,3.12,about each of these categories i know
1159.36,2.72,jordan's done a few on category theory
1160.88,4.0,we've had a few of those
1162.08,4.32,i'd love to see um a type theory talk or
1164.88,3.6,if somebody is a rust
1166.4,3.279,rust expert i'd love to see a talk about
1168.48,2.72,that i think that would be a really
1169.679,5.601,interesting
1171.2,5.68,topic um and then other languages like
1175.28,2.24,i've mentioned rest a couple times but
1176.88,2.88,uh
1177.52,3.84,prologue and data log are two other ways
1179.76,3.76,of approaching this problem
1181.36,3.6,so they have a really a very different
1183.52,2.88,approach from functional programming in
1184.96,2.24,a lot of ways because you talk about
1186.4,3.2,outputs
1187.2,3.52,and then you let the computer determine
1189.6,4.16,the correct way of
1190.72,4.64,resolving those outputs resolving to
1193.76,4.4,capture those outputs
1195.36,4.24,but um it's a different sort of
1198.16,3.519,transparency but again it's about
1199.6,3.92,writing correct programs you know you
1201.679,3.041,you write a program where if you the
1203.52,2.48,only thing you're specifying is the
1204.72,2.88,output then you know you have the
1206.0,3.12,output so i think that's a really
1207.6,4.079,interesting property as well
1209.12,4.96,and then theorem provers i'll probably
1211.679,4.721,have someone do a talk on tla plus
1214.08,3.839,we've we've started using it at our work
1216.4,2.32,and have been very happy with the
1217.919,4.321,results and
1218.72,6.959,it's a way of specifying um
1222.24,4.64,specifying a program regardless of
1225.679,2.801,whether the programming language you're
1226.88,2.799,writing in has the tools to do that kind
1228.48,3.199,of specification
1229.679,3.681,so something i could see be very
1231.679,2.321,valuable if you're working say at like a
1233.36,2.48,data science
1234.0,3.44,shop and you're writing a lot of python
1235.84,2.16,you don't have some of the advanced type
1237.44,1.92,tools
1238.0,3.76,writing a specification can be really
1239.36,3.76,nice of course we we use haskell and i
1241.76,2.64,still find it incredibly valuable
1243.12,1.919,because you can then actually write a
1244.4,4.639,one-to-one
1245.039,7.201,mapping between tla plus and haskell
1249.039,4.88,but yeah and then also i
1252.24,3.439,i kind of like to try a few different
1253.919,4.321,kinds of talks you know
1255.679,3.921,this is great but you know if somebody
1258.24,2.319,doesn't feel like they want to come up
1259.6,2.24,here and stand and
1260.559,2.24,have everyone stare at them i can
1261.84,2.24,understand why it can be a little
1262.799,2.161,intimidating i know i feel a little
1264.08,3.36,intimidated
1264.96,4.079,when i do it i'd be glad to first of all
1267.44,3.359,come up with someone and just talk to
1269.039,2.88,them about their topic like if you want
1270.799,4.88,to do like an interview
1271.919,4.961,style thing or if you don't want me to
1275.679,2.48,talk to you because you don't like me
1276.88,3.12,which i also understand
1278.159,3.281,we can have a bring a buddy so you can
1280.0,3.36,have somebody else talk with you about
1281.44,3.92,it or if you want to do a group talk
1283.36,3.52,i'd love to see that show and tell is
1285.36,2.88,really nice too so if you have some
1286.88,2.799,super cool project that you've been
1288.24,3.6,working on
1289.679,3.12,you know that you're allowed to show or
1291.84,1.92,if you're not allowed to show and you
1292.799,3.601,don't care and you want to show it
1293.76,4.96,anyway i guess i don't care but
1296.4,3.68,yeah bring it up here and then show it
1298.72,4.88,off and we'll make sure we ask
1300.08,4.64,questions and you know we won't let you
1303.6,5.199,just swim and
1304.72,6.319,drown so yeah uh also solve a problem i
1308.799,4.161,i i think we're going to do a couple
1311.039,3.201,talks where maybe we propose a problem
1312.96,2.56,and then look at different
1314.24,2.72,different ways of solving it in
1315.52,3.519,functional programming languages and
1316.96,3.44,other languages i think
1319.039,3.12,hopefully you know i don't intend to
1320.4,2.48,pick very complicated problems so it's
1322.159,4.0,going to be like
1322.88,6.48,finding the you know i don't know
1326.159,5.361,the prime you know decomposition of a
1329.36,3.84,number or something like that or
1331.52,3.279,you know reading a string and finding
1333.2,2.08,all the f's in the string you know i
1334.799,1.521,don't
1335.28,2.8,because it's hard to do anything more
1336.32,3.04,complicated than that in a talk but
1338.08,3.12,that's a great way of like say if we
1339.36,4.16,want to do a language comparison like
1341.2,4.08,maybe comparing a solution in oak camel
1343.52,3.44,to a solution in python
1345.28,2.96,i think that would be fun i actually
1346.96,3.839,wrote a couple of those that i'll show
1348.24,2.559,after this
1351.2,5.04,but yeah and then i'm also open to any
1352.96,6.88,other suggestions about ways to do stuff
1356.24,4.799,but i i think that it's really neat that
1359.84,3.199,we have something like this
1361.039,5.12,and i'd like to see it grow and become
1363.039,3.12,more more interesting
1367.28,3.92,so um there's a few more things after
1369.12,4.0,the thank you i got my slides out order
1371.2,4.479,there we go so i'll come back to the
1373.12,4.559,thank you
1375.679,3.441,so uh yeah jordan right before this
1377.679,4.0,started he reminded me that
1379.12,4.72,maybe it'd be useful to put some links
1381.679,4.161,to things and i'll slack them in the in
1383.84,2.4,the channel but one really good resource
1385.84,2.88,for
1386.24,3.679,learning about goings-on in functional
1388.72,4.16,programming communities
1389.919,4.401,there's a haskell newsletter um i
1392.88,3.36,subscribe to that's the main way i learn
1394.32,3.52,about stuff that like summarizes what's
1396.24,2.64,going on in haskell and
1397.84,3.6,a lot of times we'll talk about other
1398.88,3.76,programming languages too
1401.44,2.96,and then if you're looking for something
1402.64,2.96,fun to do and you're looking for a
1404.4,4.639,functional programming product
1405.6,4.319,project there's this icfp con contest so
1409.039,3.281,that's
1409.919,4.961,uh i don't know ic whatever that stands
1412.32,5.28,for and then functional programming
1414.88,3.44,so so we do this contest at my work
1417.6,4.64,every year
1418.32,5.2,uh for i think four years now and
1422.24,2.799,oh yeah see i didn't want to say it
1423.52,1.84,because i was like maybe it's french and
1425.039,3.361,so
1425.36,4.08,i'm not gonna just say that um
1428.4,2.8,international conference that's what
1429.44,2.8,jordan says it was i couldn't take i
1431.2,3.76,could have guessed that
1432.24,5.36,and then but the contests are really
1434.96,4.88,interesting so one year there was a uh
1437.6,4.48,you had to they gave you this they gave
1439.84,4.16,you these files for 3d printers like a
1442.08,4.88,magical 3d printer they made and you had
1444.0,4.0,to verify that you could build the build
1446.96,2.64,the object
1448.0,3.2,that they said that you could build i
1449.6,3.679,mean obviously it's all just virtual
1451.2,3.52,but it was really neat another one was
1453.279,2.801,there was like you had to find the
1454.72,4.8,shortest path
1456.08,5.44,for a gondola going through venice
1459.52,3.279,and that was really interesting because
1461.52,2.72,you learn a lot about shortest path
1462.799,4.561,algorithms and
1464.24,4.96,how like you know
1467.36,3.12,that's a really hard algorithm i mean
1469.2,2.479,you probably already know that but you
1470.48,2.16,really feel it when you try and build
1471.679,2.161,something that has to run in under a
1472.64,4.0,minute so
1473.84,3.92,and it's got 40 000 nodes to compute and
1476.64,4.399,it fails
1477.76,3.76,so uh one was we folded origami so like
1481.039,2.481,you
1481.52,3.2,had to you had to fold all these
1483.52,2.639,different shapes they gave you like a
1484.72,3.199,map and you had to try and fold that
1486.159,4.161,shape
1487.919,3.921,we managed to fold a piece of paper in
1490.32,3.92,half i called it half a gummy
1491.84,5.12,and that's as far as we got but i was
1494.24,2.72,pretty proud of that
1497.279,3.681,yeah so it'd be really neat maybe we can
1499.279,2.88,maybe we can try and do one of that if
1500.96,1.44,everyone's interested we could try and
1502.159,1.841,do
1502.4,3.759,some of that as a group and like not
1504.0,5.919,just be like like
1506.159,7.12,all isolated um all right ready
1509.919,5.12,thank you i got it in the right order
1513.279,3.921,now does anybody have any questions for
1515.039,2.161,me
1526.84,3.0,um
1532.559,6.401,okay uh so yeah so
1535.6,5.04,in your own workshop do you use utilize
1538.96,2.48,all the functional programming concepts
1540.64,3.919,in a
1541.44,6.08,production sure yeah uh so
1544.559,5.12,uh company i work for is plow and we um
1547.52,5.12,we use haskell
1549.679,4.88,for something like 90 of our backend
1552.64,5.6,code
1554.559,5.681,and then we use um reason now
1558.24,4.319,for something like 90 of our front end
1560.24,4.96,code so we have functional programming
1562.559,3.921,uh all the way up and down the stack we
1565.2,4.8,use a little bit of c
1566.48,5.76,for some stuff and we use nicks now
1570.0,3.2,for doing uh for doing uh builds and
1572.24,3.12,deployment so
1573.2,3.599,that's a functional uh programming
1575.36,4.24,environment for
1576.799,4.561,um sort of building configurations to
1579.6,3.679,deploy software
1581.36,3.679,we're very we're all in on the
1583.279,3.28,functional thing um
1585.039,3.52,you know for better for worse we're all
1586.559,5.041,in okay
1588.559,5.36,so was that um
1591.6,3.6,was your first exposure to functional
1593.919,2.561,programming then through
1595.2,4.719,your current position or was this
1596.48,5.84,something that you sought out because
1599.919,3.041,plow was known for embracing those
1602.32,3.12,concepts
1602.96,3.76,yeah so so i'm one of the founders of
1605.44,4.64,plow and so
1606.72,6.4,we um we selected it because i liked it
1610.08,6.24,they were using
1613.12,6.0,they were using php and c-sharp
1616.32,3.599,and mysql and they were running the
1619.12,4.4,mysql
1619.919,5.601,on a windows server and it was
1623.52,3.6,um look i mean the programmer who did it
1625.52,2.0,before me i like him a lot he's a good
1627.12,3.28,guy
1627.52,4.0,i was just i didn't know those languages
1630.4,4.56,i knew
1631.52,6.48,let's see i knew haskell and lisp
1634.96,5.36,um scheme and c
1638.0,4.159,and the idea of developing a website in
1640.32,4.959,c sounded like the worst thing
1642.159,4.721,in the world um so i
1645.279,3.12,i decided i was going to rewrite it all
1646.88,4.64,in haskell and
1648.399,5.201,i did that um
1651.52,3.68,but i happy happy with that decision
1653.6,4.24,that was seven years ago so
1655.2,2.64,it's been a while
1658.799,3.6,no further questions for me anybody else
1663.44,5.04,all right well thanks guys uh you know
1666.799,3.12,also i guess another thing is that if
1668.48,3.439,anybody has talks feel free to
1669.919,3.681,uh message me on slack or just message
1671.919,4.161,in the channel but i would really
1673.6,4.24,i'd really love a rest talk if anyone's
1676.08,3.199,doing any reason i'd love a reason talk
1677.84,4.719,or haskell talk
1679.279,4.88,um really just anything
1682.559,2.561,we had an erlang talk a long time ago i
1684.159,3.041,feel like maybe it's another time for
1685.12,3.84,another erlang talk so
1687.2,10.64,all right guys that's all i have thank
1688.96,8.88,you so much
1709.84,2.079,you
