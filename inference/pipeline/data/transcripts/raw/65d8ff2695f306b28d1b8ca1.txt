each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
um this is kind of a strange talk for me
to give two years ago I've done a lot of
things that Microsoft had been here a
long time and two years ago I got asked
to join the quantum computing effort and
I thought that in itself was kind of
strange because I'm not a researcher I'm
not a physicist I'm not a mathematician
I ship products you know I built a lot
of stuff and I write code I'm an
architect and wasn't quite sure what I
would do so I started looking around and
the first thing I look for tools I build
tools I try to make people more
productive and I started looking around
this whole field at what tools were
available and the answer was none there
was basically nothing out there
everybody would write what they needed
for their thesis get it done ship it and
throw it away so I started building a
platform and then I went around talking
to all the top names in the field what
would they do with a quantum computer if
they actually had one and it gave him
some sizes gave him some reason ille
technology and they all had things they
would do some pretty surprising but none
of them had an idea of how they would do
it so they knew they had problems to
solve but no one really had ways of
doing it so this talk is about trying to
fill some of that void it's a tool that
we've built that is evolving that we've
done some things further than anyone
else has ever done in the field I've
thrown back some slides that I've been
haven't used for the rest of this trip
because there's the first computer
science based group I've talked to
they've all been mathematicians and
experimental physicists and theoretical
physicists and I get to put some comp
side back in so hopefully some of those
slides will be interesting to the
audience but liquid is designed so that
we can create a simulation environment
um to make it easy to really complicated
quantum circuits and you'll see how
complicated in a little bit efficiency
a real problem if I could do quantum
simulation easily I would need a quantum
computer so how big can you go what can
you do on conventional hardware and how
efficient can you be and actually those
are the slides I threw back in to give
an idea of how hard that is circuits
have to retarget about for many purposes
um what I did is started in the middle
pretty much how you would for
conventional computer science I started
with an abstract idea of what a quantum
computer is logic gates that level and
then work my way up into circuits into
if you will assembly code equivalence
going up and find that we hit a language
at the top that you can actually express
in and compile down into that abstract
model we did that first now we're going
the other way from the abstract model
down into target hardware so noise what
things fall apart communications
limitations only certain things can talk
to certain things how do you compile
down into that how do you optimize for
actual experiments you're going to do in
the lab and machines are going to build
it turns out there's different ways you
can attack this because again you can't
do it all on conventional machine you
can pick specific things you're good at
you can be good at noise you can be good
at physical modeling you can be good at
circuit modeling so we've built
different simulators that all plug into
the same environment so you can write it
once and then run two different
simulations and trade things off and
then flexibility I'm an architect I like
platforms so how do you make it so you
can plug in your own modules change the
definitions extend this over time I
don't like things that are right and get
thrown away six months later so let's
talk about the platform itself yes
simulating go away how far away is the
real computer the one time where's about
we're going to talk a little bit about
one we can buy today okay so we're not
that far away in terms of what people
will tell you is a quantum computer and
the question is it is a paper that just
came out that we just did but
realistically to a real universal
quantum computer minimum 10 probably
closer to 20 years that's about the time
frame
talking about now pieces already exist
experiments exist demonstrations exist
but the real thing that lets say i put
up in the cloud you're going to connect
with azure and use it as a service and
run you know big simulations on 10 years
minimum the yuhl/goel here is the by the
time of their lives we want to be ready
to program well plus I need to program
it so I'd use this as the front end to
program it that's why there's the back
end right so by time you get used to
running the simulation you could also
instead target the real machine so we're
gonna start with the language I spoke to
don last night he said you've got to
push f sharp gotta push after Don always
says I've got to push so I've got my F
sharp mug here I'm one of the few people
he has to tell that to I've been using
since before it was version one
everything I've written in the last many
years has been in f-sharp and I'm a
functional programmer from way way back
so preaching to the choir here but I'll
show you why it's good why it works well
this is also why its language embedded
quantum operations think link this is a
monad that's been implemented inside of
the language and we've extended the
language in some nice ways but again
it's a dotnet language so you can come
it well it for F sharp can come from
scripting level in fact you don't have
to compile anything the whole thing
would be run from scripts which means we
can put this service you can just submit
the script you can come from C sharp or
any other language that can link with
the library so the whole thing is
contained in a library you can get to it
from any language you like it's just for
me the most natural and basically
designed for F sharp as the top level
everything compiles into gates when you
see gates think function so everything
has a definition a logical gate is just
you know a function that implements an
and or an oar or specific quantum gates
that we're going to talk about once this
all gets compiled it's gets sent to
simulators we have three simulators
currently the first is a universal
simulator this will do anything any
quantum computer we might build will do
but it comes at a price you can only do
on a typical 32 gigabyte laptop about
thirty cubits it's 2 to the 30th just
complex numbers to store
and then you have to operate on that so
you do the math you actually do pretty
well fitting into 32 gigabytes you want
another cubit double the memory you know
the cubit double the memory so i have a
simulation running right now this we're
going for 16 days that's running in a 96
gigabyte machine and that's nowhere near
big enough we actually have a bunch of
machines ordered that are a terabyte to
do a lot of the problems we want to do
but there's another way to go don't make
it universal get rid of a lot of the
gates that make it that complex to
simulate and there's a version of us of
the simulator uses only Clifford group
operations don't have to worry what that
is but they're called stabilizers the
interesting part is every quantum error
correction code only uses stabilizers so
you can do research into very
sophisticated quantum error correction
we'll talk about that a little later but
I can do tens of thousands of qubits as
soon as I don't make it Universal so
this is where you can trade off the
number of qubits versus the operations
you're allowed and then there's a
Hamiltonian simulator this lets you do
actual physics and it turns out a lot of
the types of machines we're talking
about depend very much on the actual
physics you can't just abstract it away
and are times you don't want to there
are things problems you'd like to set up
especially in machine learning that
require the actual hamiltonians again
this is universal again takes about
thirty cubits in 32 gigabytes but it's
slow so now you've traded off from the
universal to make it more physically
accurate now you have to run much slower
because you have to fix up all the
problems of basically doing a
differential equation that you're
solving along the way it buys you
physical modeling so for instance I can
actually do time derivatives I can
actually watch the times I actually say
spin glass problems we can do some of
these where I actually have to be
flipping key i'm doing a kneeling and to
do a kneeling up the drill to drop a
temperature and to drop the temperature
i have to actually do not each gate but
between each the the interactions
between all the gates over time as we go
from gate to gate
most physical simulation of the machine
yes but that doesn't change the appt
with each other well no it's not too I
the way no no if I'm doing annealing
right when you do a kneeling do similar
to kneeling on a regular classical
machine you have to break it up to do
time simulation right you're actually
going that's what the Hamiltonian will
do as opposed to saying if I just went
from here at a to be I lose all the
dynamics in between I won't get the
right answer right is doing the voltage
is actually different problem in coding
completely right and so we actually have
different ways of looking the problem
and liquid will let you write it once
and then send it to different ones and
see how they operate and how they work
yep whatever you'd like to define if you
know the physics you're doing a Trotter
ization and you get to pick the Trotter
number so if you want a thousand twenty
four steps between each and you want to
do the problem is I don't want to go too
far down this track but and we can do it
offline but the problem is the terms
that are in this equation aren't
commutative and you don't know what
order you actually have to have to
compute them in because they really want
to all be done in parallel so you have
to do is do five enough time steps to
get rid of the come utility the anti-com
you tivity problems and that's the
Trotter ization so by picking a finer
and finer cauterization get a more
accurate answer but each one is x is
twice as slow every time you had a
charter number it's twice as slow so
everything in this game is exponential
and you have to trade off very carefully
because things can take literally
forever run time so have 31 times
currently the client runtime this will
run on your laptop your desktop you just
bring it up put it in the script or
write the code it works service it's a
virus on purpose you sit there here in
the lab and you say I have accounts on
all those machines on my land it'll self
install itself across all of them it'll
become a windows service they'll all
look up and talk to each other now you
can run ensemble simulations across all
the machines in the lab and they have
them take themselves down and D install
nobody knows you were there there's
nothing to tune other than
xml file that says here are the machines
i have accounts on and here's where to
run the executable from everything else
is automatic and since we can do that we
can go to the cloud you have a cluster
you want to run an azure you hear you
submit a script it goes off pence ends
the script across to I don't know five
thousand machines does your ensemble
brings it back I'm using the word
ensemble because you don't ever break up
a computation across machines you'll see
why in a few minutes it's just too
inefficient there's no way you can
afford it but most of these are
statistical computations so you want to
run thousands of them anyway so you
might as well put one per machine and
then use all the threads available on
those machines but nice thing about F
sharp its introspective we have
reflection so we go download through all
these functions instead of running them
we have them describe themselves back we
build the AST we read the AST and we
actually create a data structure which
is now the circuit that r is represented
by all those functions once you have a
data structure we can do anything we
want to it we can optimize it and then
send it back down through the simulators
again we can do quantum error correction
we can apply just like you would do in
the classical case replace each one of
these gates with a error corrected
version that runs on multiple bits or in
this case qubits at the same time does
voting does correction fixes things up
based on error models we could do some
examples soul of a cat I of this most
your computations are rotations there
are things you want to move and the
problem is physical Hardware can only
let you usually move in certain discrete
rotations this lets you build equivalent
circuits that gets you to any exact
rotation you want by doing these course
ones along the way and so this will say
I need a 10 to the minus sixth accuracy
angle and this will put the thousand
gates together necessary and replace
that one angle with the gates you
actually have on the physical machine so
this is going down now from the abstract
level saying here the gates I actually
have replaced them all as needed noise
noise is a big problem we'll talk about
that in a little bit but if you look at
something quantum it falls apart
looking at it doesn't mean you looking
at it it means the environment
interacting with it things d co here no
matter what you do and so you have to be
able to handle that noise is the quantum
error correction but you also have to be
able to model it the simulation won't do
you much good unless you know what's
happening so there are different types
of noise bit flips phase flips just
bleeding of energy off to the
environment as things slowly d cojiro
over time all of that's modeled in the
system and you can apply that to all of
your circuits will show you what that
looks like oh yeah oh I'm going to be
doing details I need this is just to
show the architecture okay let's get
there okay so I'm going to just quickly
finish this export just let you take
these data circuits and send them to
backends we have two types classical we
have people of giant super computers and
want to be able to run this so we give
them in a form they can do linear
algebra and say go run and then quantum
as I mentioned you have a lab experiment
you actually want to output to control
that lab experiment and finally
rendering everybody hates drawing all
these circuits for technical journals
this draws them for you and you'll see
examples okay let's actually get into
things I'm going to skip the bit of F
sharp syntax I'm going to shoot su most
people in the room have an idea but you
know / ends our association arrays lists
how you call things you can pipe what no
looks like and then we've added some
operators so we've overloaded all the
usual math operators do complex
arithmetic nothing you wouldn't expect
we have chronic or products we have
vector matrix multiplies all these are
full precision complex operators there
are convenience operators that let you
for instance map one gate to a bunch of
qubits they do this gate on all these
qubits just things that make your life
easier um there's just some nice things
that say no matter what I have it's a
bag of stuff look in there four cubits
turn it into a legalistic cubits to use
so again convenience functions when I
talk gates this is what I'm talking
about so these are our bottom level
logical operations that we've been
talking so an X which is a flip in one
dimension so we're in three dimensions
here we can flip an X flip and why flip
and z so he's just saying flip this
state it's a vector in on a sphere and
we're flipping wherever it's pointing in
the X direction the Y direction of the Z
it is well it's a unit it's yes it's a
it's it's always unit and so it's only a
2 angles basically right where it sits
and so there's two complex numbers and
what the arch your pointing at is the
North Pole is 0 the South Pole is one
that's the basis here and you're just
giving the magnitude in each direction
in between those two complex which gives
you the phase as well and that's how
everything in the entire system looks is
this collection of complex numbers that
describe a state with all the qubits are
pointing in the 01 sphere in effect it's
actually gets more complicated as soon
as you have two of them you can't
actually visualize it but one that works
um but the matrix is what you have to do
that's what you multiply your your two
complex numbers by and if it's a one
cubit gate to get the output of applying
that gate so one of them flips it in one
direction one room flips it along the
imaginary axis one flips it along the in
the other case the z axis the Z is the
North Pole and South Pole so zero is
this way and one is that way um
everything including Z down z str4 our
examples of rotations that are going
half an angle further each time so Z
we're flipping the whole way as for
moving half t one quarter one-eighth and
you can do as many as you want but just
showing that's what the rotations
they're just the bottom corner going
higher and higher or smaller and smaller
in terms of the value identity why do
you need identity you multiply you get
the same thing out for noise things that
just sit there go bad over time so you
want to be able to insert identities and
watch them going bad hadamard is what
gives you super position if I put in
somebody who is pointing at the North
Pole his value is zero and I run them
through a hadamard I get somebody who's
half pointing at zero half pointing at
one he's in superposition so the
difference here is think of as a
probabilistic bit you can have it
anywhere between zero and one with a
probability the reason it's more than
just that it also has a phase so you can
point to anywhere
the sphere we're straight-up would be
zero straight down would be one they are
yes okay and in effect they're actually
in all that it's when you read when you
try to look at it you get a probability
of seeing the zero or seeing the one
they become probability when you look at
them they're actually wave functions if
you want to be exact the equivalent of
in-class compute you have an and gate
and build everything out of NAND gates
here you have a see not so controlled
not if the top is a zero the bottom goes
through unchanged at the top is a one
the bottom gets flipped that's the
controlled not but remember it's some
probability in some directions it's a
combination of 0 1 and that passes
through and get a combination of the
controlled not out the other end swap
flips the values measure is how you get
actual conventional data out you put a
qubit in you measure it and with those
probabilities you're either going to
only get a 0 or a 1 out you get a bit
and that's how you collapse everything
down to a bit you can of course use a
bit to say whether or not to do a gate
so what you'll see when you see the
double bar that means it's a bit so
there's a bit on top of that X that says
if it's a 1 do the X if it's a zero
don't do the X and then finally I want
to create a qubit i put in a binary
value in this case 0 and I get a qubit
back out the other end so these this is
pretty much with the zoo at the bottom
looks like you just want to give a feel
for what you're going to see on other
diagrams all of these are unitary
operators except for the last three
unitary means when I pass them through
in one direction I can play them back in
the other direction and I get the same
thing I started with so every quantum
circuit you see outside of when we
measure is playable all the way from the
beginning to the end and from the end
all the way back to the beginning always
and there are a number of things that
does for you in natural physical side
there's no heat dissipation it actually
takes no energy to do this you're
running super conductive and everything
stays in a superposition but what it
also means if I had an and gate can't
actually do an and gate because you lose
information when you go through the end
so you have to do two wires one is
actually the end and the others the
information
it back if you go the other way and
that's why all of these look like this
with the matrices because you can run
them in either direction okay hello
world is what we would do for the
canonical example for conventional let's
do the canonical hello world for quantum
which is called teleport Alice and
tangles two qubits so we have two qubits
on the Left starting in zero we're going
to superimpose the one qubit so he's
between zero and one the controlled not
entangles them together so this is
called an epr gate or an epr circuit
Einstein Podolsky Rosen I always get it
wrong but all it means we have two
qubits that are maximally entangled at
this point they completely share mutual
information we somebody wants all flat
explain all the math and how it all goes
together but Bob is going to take one of
the cuba's to the other side of the
universe ok Bob walks away with this guy
alice is given a qubit with a message on
it it's somewhere on that that sphere we
talked about a vector pointing somewhere
she entangles it with the qubit she
still has and then she's going to
measure both qubits know what I should
mention is as soon as she entangled it
Bob's qubit changed no matter where he
is in the universe and he actually has
the answer but it turns out he can't see
it the answer is encoded in a way
there's no way so we didn't it looks
like we broke relativity that we can go
faster than the speed of light and take
this thing from one end of the universe
and send it to the other but the
information hasn't been transferred yet
the state of the qubit changed but you
can't do anything with it until she
actually reads out the state of her two
qubits trance them but transmits them by
a classical channel which means now
she's got to send these two bits across
the universe we're back to the speed of
light and then Bob can use it to decode
the qubit those two bits are enough to
get back an infinitely accurate
representation of what was put in so he
was able to transfer a lot of
information but he still needed those
two bits to get it back out don't worry
about what it all means what I'm trying
to show is the way these circuits work
they look like a staff of music each one
is a qubit you
gates on or between them along the way
and everything moves left to right this
is how you draw a circus this is how the
gates look in them and this is believe
it or not about the simplest example you
can do our Bob recovers the sent message
and everybody's happy let's actually
look at the f-sharp code okay again I'm
not going to detail this isn't a course
on quantum computing I'm trying just
give a feel for what this looks like
when you play with it I should also
mention I didn't draw this circuit when
you write the code the circuit comes out
automatically so everything gets
rendered for you as you go so that epr
circuit is just an f-sharp function it
takes a list of qubits for it's a
hadamard on the first element in the
list and a controlled not on the first
two elements of the list so you can hand
in variable lists and all the gates
operate on however many qubits they need
from the top of the list the actual the
rest of the algorithm teleports a
function I'm going to name the first
three cubits in the list I'm do an epr
function on q1 and q2 see not the first
two and how to marred measure it by a
control it measure it binary control it
and there's the circuit so it's not a
lot of code you can very quickly build
these up and of course each one of these
you build is a gate or is a function and
so you can build them all the way up as
deep as you like there's also some soo
degay pseudo gate so I can put little
labels like the source and the zero and
the destination on there I can do some
simple optimization fold says move
everybody to the left that doesn't hit
someone else this is things you could do
in parallel in a machine and now
everything lines up nicely looks
prettier if you're doing a journal
article instead of saying giving me SVG
code in HTML you can say now give me
latex source and so this is Q circuit
output inlay tech so every paper we've
been publishing it just auto generated
by the simulator all the circuits we do
now this is this the slides I threw back
in for this audience just to show you
what it takes to do this on the computer
science side so we have these gates the
gate is a unitary operator that's 2 to
the N by 2 to the N and so if you have n
qubits that's 2 to the 30th by 2 to the
30th it's big the state vector
keeping track of all of these qubits is
also 2 to the 30th in size you multiply
each of these gates by that so if you do
this it's extremely inefficient takes
ridiculous amounts of memory it's not
pretty you run out of simulation address
quickly you run out of memory quickly
everything just goes bad the state
itself only gets that big when qubits
are entangled like we showed in the
teleport example so if things are in
registers they're separate from each
other you really don't need that big a
vector you'll have to keep the things
that are entangled together other things
that are separated or very small when
you start out with 30 cubits it only
takes 30 memory elements the entangle
two of them those two just became for
entangle that with another two that
becomes 16 and so that if you keep track
of the entanglement you can be very
efficient about the size but you can't
compress it further it's dense at that
point there's nothing else you can do
with it the operator is really sparse
may just have these yep probabilistic
way and when we're doing inference and
machine learning context in very large
state spaces somehow we always never try
and actually represent every possible
state exactly and I guess it's certainly
if there are known in dependencies
between the levels of qubits and we
factor that's a way of reducing and the
state start easy but then nice people
often use approximations that can be
extremely accurate can't do it here and
the problem is it's not probabilistic
it's fully deterministic until you
measure it and those effects can be
extremely fine grained you don't know to
the end what you can approximate there
is nothing you can approximate is where
you fall apart here let me I did large
scale you know machine learning for
years and that was great now I can take
massive problems and you know the size
of the web right and bring them down and
here you don't have the luxury you
actually have to keep every you know
full precision complex number all the
way to the end and then you can actually
measure it out probably in throat
away but you don't know until the end
because you're actually keeping all the
fine grain interactions you don't know
which ones are important and so it's
frustrating as hell but if you really
want to similarly what goes on in the
machine you can't throw it away that's
sort of the bottom line we can talk
about it if you like okay yeah so the
prop you have a really sparse operator
but again it's its massive and it's hard
to keep track of and remember even if
I've got a little gate I have to expand
it out to the size of the state vector
to multiply the two so I have even for
little gates I have the same problem so
when act to the standard talk this is
just F sharp code so we put it in a
classical rapper you call the function
just like any other phone classical
function in here every top initial one
is a random state vector we started with
Simon's question there's your magnitudes
on the complex number on zero the
complex number on one saying where that
vector is in the sphere we go through we
read out the bits that says whether do
the X or the Z flip and lo and behold we
get the same vectors back out you know
hello world works this is the equivalent
of you run it through comes out you get
in hello world everything worked your
simulator actually does something useful
this can also be run as a script so
you've got multiple options you can just
run FSI directly on the script and say
do it you can do a use which lets you
stay in the simulator after it runs you
can look at the states and the values
and all of that you can have liquid run
it for you which will take the script
compile it into a dll and then reload
the dll back in of course now you have a
dll s you can also run the dll directly
it's got lots of options from a script
level if you don't want to actually get
into visual studio environment i said i
wanted to make this fully extensible
here's the actual controlled not gate
this is all the code for it everything
that's in here can be rewritten by the
user can be extended they replaced and
so you have a name for it some help you
have a sparse matrix definition that
says here are those elements of the
matrix I showed you on the earlier slide
and drawing is the latex commands for Q
circuit parameterised so you can say
put this on this cubic but this here
here's how I want to drawn and that's it
so that's all you need to do to do a
gate I also said you could take those
same functions and turn them to circuits
this is how you do it into a data
structure a circuit compile of the
teleport function give it some cubits if
I say dump the data structure back out
you get back out a definition of all the
different gates that were in teleport
what matrices what wires there on and
then from this you can go to anything
you like and go a supercomputer you can
go to actual control of a system you
just want to show you how compact this
can be this is an entanglement test that
says superimpose one cubit and then
entangle it with everybody and then
measure them all well since everybody's
fully untangled if I look at one of them
they're all going to collapse to the
same thing so if you look we get with
about fifty percent probability
sometimes we'll get zeros sometimes we
get ones no matter which one you looked
at first all the others collapse to the
same thing to generate that circuit we
created a function that just said
Hadamard the first qubit remember him
mapped to the tale a scene up between
him and everyone else and then map a
measurement across all the qubits so you
get very complex very quickly with very
small amount of code parallel version
this is a little more complicated
version that I said fold it and now
everybody moves in time the 48th time
steps really only takes ten time steps
to execute so you do analyses of
sequential versus parallel times on a
target computer and see what it would
look like this is the actual F sharp
code not going to go into it in waiting
is interested I can I can explain the
lines but that's how we generated the
previous circuit and this is it running
so this is 20 entangled qubits takes
about two seconds that's in the brackets
each time we get all zeros and all ones
as we'd expect this is running on my
cluster so anywhere from 80 to 100
percent utilization that took a thousand
runs of 22 entangle qubits in three and
a half minutes so now we're starting to
get into some more interesting scaling
it yeah yeah this is all Universal only
talking Universal at this point so this
you can do anything in this one um well
let's do some
thing that everyone knows Shor's
algorithm let's factor okay that's it
soon as you say quantum everybody says
oh we're going to break our essay and
not so much but this is a simple circuit
I should say the biggest number you see
in any of the published papers factoring
is the number 15 okay four bits four
cubits in this case as a 4-bit number
takes eight nine ten eleven cubits to do
the circuits actually 8200 gates one of
the nice things about the circuit
renderers you can say give me different
levels like this is a more abstract
level i have mutt modular multipliers
here as units I could say go inside of
those show me the circuits go inside of
those and go at any level you like but
like I said four bits ad tourniquet
that's about what everyone's done we've
done 13 bits which was the number 8189
it's about half a million gates and the
one running at home I think I mentioned
at the beginning we'll go for 28 days
and he's doing for a 14 bit number at
the moment just to show you what the
circuits look like this is the modular
adder you have sharp code I won't do it
in detail but there's a controlled
controlled Adgate so here's the problem
you want to add two numbers together and
you want to keep them from overflowing
it's a modular adder simple except the
entire circuit has to be reversible as I
said earlier everything has to be kept
unitary so here we do the controlled
control dad and we're actually doing
this in Fourier space so now that we've
done the ad we have to bring it back out
we do an inverse excuse me this is the
yeah this is the inverse of the no it's
not the QFT this is an ad oh I'm sorry
we're going to subtract off the number
that we're modding to see if we over
float or not so we subtract the number
off now we take it out of Fourier space
we do an inverse QFT quantum Fourier
transform and we remember the top bit if
the top bit overflowed we know we have
to go back the other way otherwise we
don't so we remember the bit in an Ansel
ax or the qubit in this case now we put
it back in the QFT now we really do the
ad based on whether we would have
overflowed if we had done the ad so this
did the modular ad and now the whole
rest of the circuit we're going to an
inverse add inverse QFT we're going to
clear
top cubit we have to leave everything
back the way we found it so he's got to
go back to being a zero now we QFT now
we add again and now we're done and you
can run this circuit forward and
backward and everything is left in the
right state and everything works
correctly but this is why it's not as
trivial as just say take your classical
algorithm and drop it into a quantum
algorithm either we are working on that
also someone else has a simulator
they've written where you take a
classical algorithms say make this
reversible then take that reversible
algorithm make it quantum so we're going
to be adding that that's higher level
things we're adding to the simulator
over time okay so what do we get when we
do this here's an example of factoring
all sorts of numbers times they took
probably much easier to look on a graph
the blue diamonds are the first version
of the simulator we wrote second version
is the red and the orange is as of two
weeks ago so we went from three years to
four months 24 days to do that 13 bit
number and as I said the one that's
factoring at home the red line would be
a month it looks like this will be about
28 days to factor for the last one and
that's not anybody cares that's you know
my dog can talk not how well my dog can
talk but again most everything published
to this date has been way down all the
way at the lowest on the left is the
biggest anyone's done before this so
this just gives you an idea the
complexity of the full Universal
simulator what you're able to do the
promise of factoring big numbers my
using gotomeeting we could do it way
faster than we could an orderly computer
mm-hmm however I was here factoring a
yahoo could be done really fast so
there's a really very normal slow down
factor for so between so the promises
the corner beauty is going to be
fantastically much faster yes here it's
kind of like taking months to do
something oh no no but this is do this
is doing a simulation of a simulation of
a simulation so the real quantum
computer will do this blindingly fast
okay I'm doing all half a million gates
and having do them on a classical
machine to simulate them if I actually
was doing this I can do this on a
quantum computer that's actually not the
prime very fact I can break our essay on
a chronic Peter the problem is the
number of qubits it takes
number of gates it takes to fix up all
the noise along the way to get there and
on and on us when you actually yeah and
so for some and i'm going to show you
places where it's not where we actually
do get an exponential win but factoring
works but the actual technology you need
to build the machine is a good 20-30
years away before you could really build
the machine to break our essay and by
then RSA is bigger or whatever you're
going to use for cryptography there is
also quantum cryptography by the way you
can really nicely entangle those qubits
like we just showed you with Bob and
Alice and if anyone eavesdrops on it you
destroy it so anybody trying to look at
the channel will destroy the channel so
you can't get the information without
somebody knowing and then they can't get
the key because the key was moved
quantumly and on and as a whole quantum
key cryptography area to UM so let's
talk about noise a little bit I'm not
going to go again into detail it's one
get of a field there's an abstract class
you derive from and say I have a quantum
error correction code I want to try this
happens to be what's called a steam 7
code and this guy generates a circuit
that says given one logical qubit
replace it with 7 physical qubits and
this encodes the seven into that code
space so I now have a nice encoded value
that I can check for errors as we
compute this is the guy that actually
does the checking so the bottom seven is
the encoding of the logical qubit the
top six are the ones who read everything
on the qubit measure it out and then
decide to apply x and z flips depending
on what went wrong and so this will
actually fix all one qubit errors will
detect all 2 cubed error sounds just
like you do normal coding classically
but this keeps everything quantum this
lets you actually apply this throughout
the system and this is what our friend
teleport looks like once you run it
through this quantum error correction
application it goes through and rewrites
the circuit with and of those syndromes
and then every place you had an ex gate
you now have seven of them or the C
knots or any of those other gates you
saw you now have seven copies that
happen at once and then you check if we
got what you expected so yes your number
of gates blow up very quickly and the
number of qubits blow up very quickly we
also finished a brand new noise
model that's much more physically
accurate what's nice as you can say
specific gates have different noise
models you can say how many qubits are
going to operate on how long in physical
time the gate takes to work a see not a
to cuba cape may take a lot longer than
you know in 20 to 50 nano second stead
of 10 nanoseconds for an X gate and then
you provide a noise model for what you
want to use so now for different types
of qubits different types gates even in
the same system they may be hybrid you
can apply your own noise models the
system gives you back events this noise
event happened at this time on this
qubit on this gate and this is what it
did also your error correction circuitry
is also going to be noisy and that's a
problem it turns out if your gates
aren't good enough about the threshold
the error correction makes it worse
because you've added more gates and the
gates are noisy and everything gets
worse so you actually wind up coming up
with a threshold value of at what point
to your physical gates have to be how
good are you qubits before you can even
fix them and so there's a whole
interesting area Christus evora who
heads the research group that's her
expertise that's her main area is noise
modeling and correction but the one
that's new that again nobody has is we
actually do non unitary noise we do
what's called amplitude damping so if
you read in the papers you know IBM now
has a qubit that lasts one or two
milliseconds sometimes you hear t1 there
t1 time for decoherence that's this you
can we can now model actual decoherence
of the individual qubits as you're going
you can actually put different
probabilities on different qubits so you
have semiconductor cubed you have
quantum dots various other technologies
you can put different decoherence in so
here's a simple circuit again I've got a
how to Marge some super putting a
superposition two cubits and I'm see
nodding together and then a bunch of
idols infinite number of idols what
happens well here's what the damping
probability what happens we start out
with twenty five percent probability for
each of the four possible states because
you could read out the other at 0 0 0 1
1 0 1 1 when I measure it but you'll
notice everything with a 1 and it starts
falling off and the zeros start climbing
and then we get this non unitary event
the thing just d cohered and so two of
them drop the 0 2 of them popped up a
little basically the first qubit went to
0 so the 10 and the 11 state disappeared
and now you can see the 10 keeps keeps
bleeding way to the environment is the
00 keeps going up until he d coheres now
everybody is 00 you've lost your qubits
they're gone so this first time that i
know of anyone's actually built a
simulator that will actually let you do
the physical modeling of what's
happening with the qubits and for sanity
check we took our friend teleport added
quantum error correction on top of it
the steam 7 code put in some
probabilities that were published by
others for actual physical qubits and we
going to fall off at about 3 minus 3
where the whole thing can't keep up the
code can't keep up and there's this
threshold and it turns out that's
exactly what steam predicted the
threshold would be right in that area
for when you have physical qubits and
they look like this this is about where
everything would stop working so about 3
D minus 3 has to be your your t one time
for your qubits if you want to be able
to correct them if you can't keep them
at least in this millisecond range
you're not going to be able to fix them
um yeah kind of honorees of how these
you busy ever again I mean let me let me
let me give you hope the reason
Microsoft is in this at all is we have
an area we're working in and our focuses
is called topological quantum computing
and I can talk to people separately
about it I wasn't going to do it in this
talk about Meyer Ana's and these
quasiparticles we're using but it turns
out instead of having say a single
electron that you're flipping the state
on you actually have a particle that two
of them make up the electron or the
Fermi on actually and they're really one
item but they're separated in space so
these decoherence of X effects if they
hit one of them they don't hurt the
other one you have to hit both at the
same time extremely unlikely the times
for these look like they could be in the
years you don't have the equivalent of
computer
memory where these qubits can last
virtually forever it also means your
error correction now became easy because
they don't go away you can you actually
the gates are done by braiding them
around each other so as long as you
braid them and you don't get them near
each other you can actually do all of
these gates and you have fully fault
tolerant computing now there's lots of
caveats I'm gonna leave all of that out
for now but the point is this is why
Microsoft is so interested we have the
only fields medalist working in industry
Michael Friedman who's down in Santa
Barbara and it's station Q and this is
what we focus that whole effort around
is these topological qubits now in
semiconductor cubicin like you up into
the milliseconds range no reason it
can't go higher and that's enough you
know as soon as we get into the tens of
milliseconds and a little beyond we can
correct them we can keep them alive
forever so we're on that the verge even
for the more traditional or conventional
qubits so it looks pretty good oh it's
all done superconducting let these are
20 millikelvin most of this is run at I
can talk about fridges too i got lots of
pictures on my phone that people want to
see i've been i've been going to all of
our labs and europe is why I'm here and
so we've got some very cool experiments
going on I'm just going to mention the
stabilizers these the ones we can do
tens of thousands of qubits you can take
your normal circuit you compile it into
stabilizers this is teleport again
running and stabilizers I'm not going to
do any detail here but for people who do
this work you can also get statistics
out of where you are in the stabilizers
and what the space looks like but all of
those error Corrections we were looking
at only we're flipping X and Z and turns
out stabilizers know how to do X and Z
and so you can do all your error
correction let me do a machine learning
ok page rank we're going to start with a
standard stochastic probability matrix
the G matrix or Google matrix if you
like but we're going to turn it into a
Hamiltonian I think the identity minus G
adjoint it and identity minus cheat
turns out that gives you a Hamiltonian
that represents those stochastic
probabilities converted to a unitary
this is gets back to our Hamiltonian
simulator we were talking about so now
remember the unitary czar
and we have all their from a starting
state of static probabilities you know
the one over n you would use for
pagerank type thing and then we do an
adiabatic evolution I won't describe the
term unless somebody wants at the moment
but there's a way to do these
hamiltonians and guarantee you can get
to the lowest energy state we accumulate
the average probabilities so here I do a
synthetic web graph using recursive
matrix generation so it's a nice power
law graph 256 pages by the way takes
eight cubits so I can do two billion
pages and 32 cubits and shows you very
quickly we can do big problems on tiny
machines in here you can see regular
page rank and quantum pagerank we get
the same answer this is good I can do
extremely dense encoding and I can pull
pagerank off ah there's a bunch of
caveats you'd never do this in real life
and I can tell you all of them but let's
just say it takes you exponentially long
to actually get this answer out it's
there it works but you wouldn't do it
this way and the problem I have with a
lot of the papers out there everyone
leaves the real costs out and so what
we've been doing a lot is i won't i'll
use the word here debunking a lot of
thee this is exponentially faster no it
isn't you know this is quadratically
faster well only if you ask the question
once and only want one bit of accuracy
out you know that type of thing but
don't worry I'm going to end on a
positive note you know it's not all bad
news this is talking about the
Hamiltonian simulator now one of the
most popular or useful techniques is
called spin glass so what you've got
think of Boltzmann machines think think
of just standard simulated annealing I
have something that can flip up or flip
down I'm going to hook them together
with strengths positive and negative and
I say go and everything flips around and
I'd lower the temperature until
everything stabilizes out okay standard
technique the way we label it here or do
we do it here the first term in the
x-direction basically is think of it as
your temperature if I have that really
strong I turning off all the other links
or I'm overriding by saying push
everybody in one direction I'm going to
make everybody go in the X direction I'm
going to lower the X direction and
increase the H eyes are saying I'm going
to clamp somebody up or down so this
would be like the inputs to your prob
right you'd say these are my input ones
that are a 1 0 1 1 0 and then the ji j's
are connecting them with everybody else
you let this thing cool down and all the
others flip to an interesting state and
some of them you defined as your outputs
and this is normal simulated annealing
miss known as a spin glass problem
there's a company in Canada called
d-wave who ships a quantum computer back
to the question of when we're going to
see quantum computers at least that's
what they say and we can reproduce on
the simulator everything they've
published in nature and science and all
the rest give an example using
ferromagnetic chains we turn this into a
circuit so what you're seeing is the
first column or all the X's then I'm
clamping the left and the right because
the ferromagnetic chain and say they're
up there down there opposite and then
I'm going to link them together those
are the ji J's and finally at the end
I've got the ex's again because we're
doing a higher order approximation back
to the other question on Trotter ization
you can ask for higher order Trotter is
a shins as you break the differential
equation apart be more efficient and we
get all the answers that everybody's
published and we can do noise modeling
and tangle Matt entropy all sorts of
other things on here you're interested
this is going into nature it's being out
for review right now but they let us put
this up there's been so much buzz they
let us put it up on the archive and
there's a link there if anybody wants to
read it there's a big big paper on this
and all the details traveling salesman
here's an example of a Hamiltonian for
traveling salesman what you're doing is
encoding the edges so you're going to
say I want to drop down edges between
cities oh they are I know we've reached
eleven o'clock so it's okay okay I'm
getting to the end here and anyone who
wants to leak out feel free it's okay i
just want to mention the same problem
with doing this classically is we've
just naively put in traveling sales when
you start getting problems where you get
disconnected roots instead of the full
because there is no higher order
constraints we can do eight cities
twenty eight cubits other people publish
papers saying oh a higher order
constraint lets me do more like a four
body instead of a two bodies simulation
yeah I get a doubling in the speed this
solves at butts four times the amount of
work and that's the part that gets left
out of the papers
and egopay poems in terms of what no no
no no no no never said that all I'm
trying to do is reduce the prefactor
okay I never made a claim that you know
P equals NP or b QP is P or any of that
no no no okay I'll finish fast
unfortunate this is probably the best
part of it but we'll just leave it I
took too much time on the other there's
another Hamiltonian model second
quantization this lets you do molecular
chemistry um this is H to two hydrogen's
together this is simulating it the blue
is our simulator compared to publish
results we actually get more more
accurate results we're actually telling
you naturally where the two nuclei will
come together to balance out the energy
you can run the whole thing from script
mode you can run this on a cluster this
is all of water being simulated so this
actually is doing bond lengths and
angles to show you what a water molecule
this is we're back to what Fineman said
you'd use a quantum computer for is
simulating quantum physics again we get
different numbers and the traditional
approaches but you solve it exactly what
we get is exactly the right answer to
the precision we asked for the problem
here this takes thirty four thousand
gates then you got to run a two to the
14th times get 14 bits back to see then
another two to the 10th time to get rid
of the cognitive ed problems and then
about 50 samples per point to make sure
you got the ground state and 546 points
for the plot this is 10 to the 16th gate
ops we can cheat and so we do with the
quantum chemist oh I'm not going to go
into this now everyone interested this
is a linear algebra you can do to get
your two to the 15th by 2 to the 15th
matrix down to 441 by 441 oh and by and
once you've done that your exponential
powers of two just become matrix
multiplies times themselves and that's
how I solve this actually okay I can't
actually run the gates for the length of
time it would take these are all the raw
numbers for if you now add oh I don't
have all the rotations oh I have errors
all high oh this gets very big and in
fact there's an IRP challenge using a
molecule called ferredoxin which takes
about 10 to the 23rd gate operations
that's a century and a half at current
technology speeds back to when will we
have this however we've come up with a
new technique that will let you take the
scaling down from n to the fourth where
n is the number of orbitals of the
molecule down to n squared with no
reduction in error and in fact if you're
interested this isn't out yet but
there's a paper coming that if you
notice at the bottom there's a 5.8
billion gate operations needed for
ferredoxin we've got it down to
thirty-seven thousand which took your
century and a half down to a week and a
half now it's reasonable and that's with
today's cubed technology in terms of
speeds so we've now reached a point
where we can do it you build a machine
that can do this you can do much further
than chemists can do today they can get
to maybe a hundred orbitals if they're
lucky we can get the hundreds above that
and solve very complex molecular
problems I'm going to give you one more
example that I'm also working on right
now with Matthias you can also do
simpler Hamiltonians you effective
models and when you do that this is
called the Hubbard model this scales
linearly with the size of the problem so
I can actually simulate entire sheets of
superconductors and design
high-temperature superconductors this
way so in fact on the right is from a
paper he previously published on the
left is liquid simulation of the
material these r coupe rates which are
high-temperature superconductors and by
the way the numbers aren't the same
because again we went built it did the
simulation and found their numbers were
wrong so in lots of cases here when you
actually implement it give you one
example Shor's algorithm when we
implemented it we found the paper was
completely wrong they left a gate out
that all you get is random answers you
will actually get the real solution and
no one ever knew it because no one ever
simulated it and there's lots of
documentation i can give anyone who
wants this paper we're actually going to
put it up externally which is just an
overview of what this talk talks about
it's also an 80-page user's manual
there's msdn documentation and that's
probably enough for today so i'm here
for two days anybody wants to talk my
schedule right now is wide open and I'm
at your disposal
questions sure in the remark and you
were saying you need to keep track of
the whole space them either no Theory
around you know getting inside from what
you're going to query in the end and get
some variation of bounds profitez your
entangled as soon as you have
entanglement you can't even look at the
state I'm one of the things we didn't
talk about in here at all these
debugging how do you figure out where
you are in all of this even before you
can do it variation else I even have to
understand the system and I can't and I
have there a bunch of techniques we've
started putting quantum debuggers
together but you can't like single step
and ask what are the values of the
variables because it's distributed
across two to the 30th elements what do
you do well it turns out there are ways
you can make believe you measured we can
do things you're not allowed to do
quantumly but that's a whole separate we
can talk about but it's really it's it's
terrible you can't buy that you also
can't clone these are linear types if
you prefer once you've read it you can't
read it again and it's gone from where
you read it so you can't copy anything
you can't look at it without destroying
it on and on and on and on now again
we're simulating which means we can
cheat so things we can do you copied all
the state vector and do stuff to it
that's illegal and then keep the rest of
it going okay but even so the analysis
is such that I said if they weren't
entangled I could bring this thing down
I don't know when things aren't
entangled you have to tell me as a user
I've just separated these the circuit
did the right thing there now
disentangled but you can say check that
I'm right which is extremely expensive
and it goes through and figures it out
and lets you know if it is then it
really disentangled otherwise it says
you have a circuit bug that type of
thing so we do have all of that
implemented but automatically in any
efficiency being able to do that is
virtually impossible frustrating it's
fun but it's frustrating yeah
for the results age talked about at the
end of your talk on molecular
simulations how much of that is done
using your current simulation and how
much of it is waiting for actual quantum
computer all events with the current
simulator all of it now should let me
caveat everything through water water
h2o I can fit in under thirty cubits the
others I can compile the circuits and
get all that all the numbers in those
tables are from the simulator but I
can't run them right but we verified the
techniques we're doing this
multiresolution Trotter ization that we
can actually throw away ninety-eight
percent of the matrix this is again do
it's basically doing a multiresolution
decimation of the matrix so we
precondition the matrix to figure out
what doesn't matter and throw them away
below the accuracy you care about and by
doing that these are a lot of its
standard linear algebra techniques or
HPC techniques that have never been
applied in this field so but in answer
to your question all everything you saw
up there of h 2 h 2 o those have all
been fully simulated and actually water
only takes about a minute for me to do
once i've done all of those classical
tricks on a quantum computer it would
take longer actually because that's do
all the games give the transition from
the gaze to the amazonian a gate is a
summary of a time step of a hamiltonian
so e to the i HT is the unitary so over
a period of time when you run those
gates they go to a steady-state so the X
the Y the Z that the Hadamard see not i
will steady-state solutions to apply in
the hamiltonian that so the Hamiltonian
is the transition to get from one to the
other normally that's fine if i'm doing
digital operations then i'm fine i'm
saying i want to flip this bit well i
have to move it after actually moved the
qubit and flip it and that's the
hamiltonian doing that the unitary is
the effect of that as as simon was
saying that you know the whole point is
why can't I just do that well the
problem is if I'm doing spin glasses and
things they're all flipping and while
they're partially moving they're talking
to each other and so now I actually have
to go
down into the Hamiltonian actually do
traveling salesman or or whatever the
machine learning type problem and
mapping on to it PageRank is like that
for example you are solving trig
equation yeah the Hamiltonian does is
full Schrodinger wave equation basically
yeah April like I said I'm available
