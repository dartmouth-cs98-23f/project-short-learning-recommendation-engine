second,duration,transcript
0.56,3.84,hello my name is jeff messier i'm a
2.24,3.76,professor in electrical and software
4.4,4.0,engineering in the schulich school of
6.0,4.32,engineering at the university of calgary
8.4,5.04,and in this lecture we're going to talk
10.32,3.92,a little bit about programming languages
13.44,2.64,to
14.24,4.16,start out with i want to talk a little
16.08,3.68,bit about how a micro architecture runs
18.4,4.4,a program
19.76,5.2,and a micro architecture runs a series
22.8,4.0,of very low level instructions or
24.96,3.6,commands called machine language
26.8,4.319,commands and
28.56,5.12,basically if you look at sort of the the
31.119,4.561,logic design at how a microarchitecture
33.68,4.16,works it basically
35.68,4.24,reads one of these
37.84,3.6,low-level machine language instructions
39.92,3.68,out of memory
41.44,5.36,feeds it into the processor and executes
43.6,5.36,it then it reads the very next one out
46.8,4.399,of memory and then it feeds it to the
48.96,4.32,processor which executes it then it
51.199,4.321,reads the very next one out of memory
53.28,4.24,and then it executes it and so on and so
55.52,4.48,on and so on so basically
57.52,4.08,all a micro architecture is doing is
60.0,3.199,reading and executing reading and
61.6,2.8,executing
63.199,3.92,and so
64.4,5.84,one of the things that i'm going to try
67.119,5.601,and address in this module is how does
70.24,6.08,a high level program written in let's
72.72,6.88,say c or python get translated down to
76.32,4.64,this very sort of simple
79.6,4.48,um
80.96,5.36,abstraction for for running or executing
84.08,3.84,a program
86.32,3.439,so in this module i'm going to be
87.92,4.64,talking about something i'm going to
89.759,4.481,refer to as the big three and the the
92.56,3.44,big three different kinds of programming
94.24,4.48,languages are
96.0,4.24,high-level programming languages
98.72,3.6,machine
100.24,3.6,language and
102.32,3.439,assembly language
103.84,4.08,and so to
105.759,4.481,start out with
107.92,4.879,high level languages are
110.24,4.159,things like c python the kind the kinds
112.799,4.241,of languages that you're probably
114.399,4.72,already familiar with with using from a
117.04,4.48,programming perspective
119.119,5.841,machine language on the other hand are
121.52,5.32,the actual binary commands that we feed
124.96,6.48,directly into
126.84,6.6,the processor's digital logic structure
131.44,3.84,so these are the ones and zeros the
133.44,4.72,digital voltage levels that literally
135.28,5.56,get fed into the the circuitry that
138.16,5.92,makes up our processor
140.84,4.759,and these are very very low level
144.08,3.84,commands
145.599,4.961,the third type of
147.92,4.399,language is something that we're going
150.56,3.12,to refer to as assembly language or
152.319,3.841,something that is referred to as
153.68,4.96,assembly language and you can think of
156.16,5.92,assembly language as an intermediate
158.64,5.599,language that humans can read but is
162.08,4.64,very very tightly
164.239,4.961,tied or very very closely related to
166.72,5.04,machine language there's almost but not
169.2,4.399,quite a one-to-one mapping between
171.76,3.92,assembly language instructions and
173.599,3.601,machine language instructions
175.68,2.96,and
177.2,2.72,again this is maybe something that we
178.64,3.84,take
179.92,6.08,for granted today but it's worthwhile
182.48,5.52,pausing here and to just appreciate what
186.0,4.56,a significant innovation
188.0,3.84,human readable programming languages
190.56,3.599,were so
191.84,5.36,back in the very early
194.159,4.961,form of computers
197.2,4.8,but back when people were using the very
199.12,5.119,first generation of computers humans had
202.0,4.799,to actually by hand
204.239,5.041,encode the ones and zeros that made up
206.799,3.841,the machine language instructions that
209.28,3.2,were
210.64,3.76,fed into the processor this is basically
212.48,3.679,what punch cards were if you if you've
214.4,2.88,heard of punch cards
216.159,3.121,and so
217.28,3.84,the idea of having a programming
219.28,3.599,language that humans could read that we
221.12,3.039,could type in using alphanumeric
222.879,4.0,characters
224.159,5.681,was a big innovation and actually
226.879,5.121,assembly language was the first
229.84,4.479,form of human readable programming
232.0,3.519,language and as you're going to see
234.319,3.12,because we're going to talk a lot about
235.519,3.761,assembly language in this class as
237.439,3.36,you're going to see assembly language
239.28,4.48,while you know you can get the hang of
240.799,7.121,it it isn't quite as intuitive as for
243.76,6.479,example a python program so as soon as
247.92,5.28,people started to work with human
250.239,5.601,readable languages the race was on to
253.2,5.2,develop languages that were more and
255.84,5.44,more intuitive for humans but at the
258.4,5.519,same time were
261.28,4.8,mappable down into the low-level machine
263.919,4.0,language instructions that
266.08,4.08,processors needed in order to take
267.919,3.84,action on something
270.16,3.84,so starting off with high-level
271.759,4.481,languages again these are the languages
274.0,5.36,that probably you are most familiar with
276.24,4.8,at this point and they include
279.36,4.96,basically almost every programming
281.04,7.04,language you can possibly name c plus c
284.32,6.72,perl python ruby matlab
288.08,4.88,awk javascript java all of these things
291.04,3.599,are considered high level
292.96,3.92,programming languages
294.639,4.721,in this
296.88,4.8,series we or in this class we are going
299.36,4.16,to be using primarily c and there's two
301.68,4.0,reasons for that
303.52,4.88,the first reason is that c
305.68,4.4,in general is relatively of all the
308.4,4.639,high-level programming languages it's
310.08,5.119,probably the easiest to map to assembly
313.039,3.841,language and machine language and so
315.199,2.961,i'll be using that in a lot of my
316.88,2.4,examples
318.16,3.039,and
319.28,4.0,it's also the primary language we're
321.199,4.161,going to be using in our hands-on work
323.28,3.359,with our microcontrollers when we start
325.36,3.2,to implement designs using
326.639,3.921,microcontrollers
328.56,3.04,now
330.56,2.96,many
331.6,4.319,not all as we're going to see but many
333.52,4.08,high-level languages are translated into
335.919,4.401,machine language using something called
337.6,5.12,a tool j tool chain and a tool chain is
340.32,5.28,basically a series of specialized
342.72,5.199,programs that convert a high-level
345.6,4.159,language down to the low-level machine
347.919,5.601,language instructions that can be fed
349.759,7.041,directly into a processor and we usually
353.52,5.28,refer to this conversion as compiling a
356.8,2.959,program so when we compile a program we
358.8,2.32,take
359.759,3.521,a
361.12,4.88,a c program for example and we compile
363.28,4.96,it down to an executable file or a
366.0,4.08,binary file that contains the actual
368.24,3.679,ones and zeros of the machine language
370.08,3.679,instructions that can be fed into the
371.919,4.72,processor as we're going to see
373.759,5.44,compiling is even though that's the term
376.639,5.761,that we use compiling actually refers to
379.199,4.881,just a one specific part of this
382.4,3.6,conversion process and we're going to
384.08,3.44,see that in a second
386.0,3.68,however
387.52,4.16,it's worthwhile just at this point
389.68,4.799,pausing for a second and talking about
391.68,4.239,interpreted high-level languages because
394.479,3.041,many of the languages that you may
395.919,3.601,already have
397.52,4.32,experience with are not actually
399.52,4.32,compiled languages they're interpreted
401.84,4.56,languages and probably the most common
403.84,5.12,example of that these days is python so
406.4,5.12,you don't actually compile a python
408.96,4.959,program instead you write a python
411.52,6.16,script we refer to generally python
413.919,6.241,programs as python scripts and then that
417.68,4.959,program gets read by an interpreter
420.16,5.28,program and the python interpreter
422.639,5.041,basically reads the scripts and then
425.44,4.4,sends commands to the processor based on
427.68,4.88,what's written in those scripts so the
429.84,4.639,interpreter is a compiled program so
432.56,4.639,somebody had to program
434.479,5.601,the interpreter and compile it
437.199,5.041,but when you actually execute your
440.08,4.16,python script you're not actually doing
442.24,3.679,any compiling and that's why maybe if
444.24,3.44,you have programming you may have a lot
445.919,4.961,of programming experience but you have
447.68,5.28,never actually compiled anything before
450.88,3.28,and um
452.96,4.239,we're going to as i said we're going to
454.16,5.12,focus on c in in this in this class so
457.199,4.081,we're going to be dealing with a
459.28,3.68,language that is compiled and so we're
461.28,4.08,going to be talking about
462.96,5.44,the tool chain and how that process of
465.36,6.08,conversion to machine language works
468.4,5.919,so as i mentioned assembly language was
471.44,4.8,the original human readable
474.319,3.6,language and
476.24,4.0,there is an almost but not quite
477.919,4.161,one-to-one mapping between an assembly
480.24,3.44,language instruction and a machine
482.08,3.679,language instruction as we get into
483.68,3.84,assembly language you're going to see
485.759,2.961,um
487.52,2.32,you're going to see why i make that
488.72,2.159,distinction
489.84,4.4,and
490.879,4.481,you know there was a time when humans
494.24,3.92,would
495.36,3.839,write assembly language programs from
498.16,4.319,scratch
499.199,4.641,and the original reason for this was
502.479,4.081,back in the day
503.84,5.039,it was relatively common for humans to
506.56,4.0,be able to write more efficient assembly
508.879,4.321,language than could be generated
510.56,4.24,automatically by a tool chain however
513.2,4.0,these days that's not really true
514.8,4.479,anymore most modern tool chains are
517.2,4.56,pretty good at generating highly
519.279,3.921,optimized assembly language and so you
521.76,3.759,don't really get much of a speed up
523.2,4.639,advantage when a human tries to write
525.519,4.561,assembly language from scratch however
527.839,4.721,if i talk to my friends who work in
530.08,4.56,firmware and embedded design
532.56,4.32,they say that they do work with assembly
534.64,4.56,language quite a bit still
536.88,4.56,not so much to write assembly language
539.2,4.72,but to look at it to understand why a
541.44,5.2,processor is behaving the way that it is
543.92,4.64,and this is relatively common for very
546.64,4.08,high speed you know quote-unquote
548.56,4.719,real-time applications so imagine if
550.72,6.16,you're writing a processor to control a
553.279,6.161,self-driving car or maybe even a drone
556.88,5.2,or a fighter jet that processor has to
559.44,5.28,be able to receive input make a decision
562.08,4.56,and take action
564.72,4.32,quickly enough to
566.64,3.92,you know not crash the car or fly into
569.04,3.44,the side of a mountain if you're if
570.56,3.2,you're piloting a drone
572.48,3.2,and
573.76,4.079,sometimes with these very time critical
575.68,3.68,applications the processor maybe take
577.839,3.841,may end up taking a little longer than
579.36,4.0,you expect and it's nice to be able to
581.68,3.839,sort of look at the assembly language
583.36,4.08,and sort of see the exact instructions
585.519,5.041,kind of figure out what's happening and
587.44,4.8,then see if you can change or optimize
590.56,4.8,the program to
592.24,5.68,to reduce bottlenecks
595.36,4.88,another reason and really the primary
597.92,5.84,reason why we study assembly language is
600.24,4.159,that it is absolutely oops
603.76,3.28,it
604.399,4.961,must be understood by the designers of
607.04,5.919,tool chains and micro architectures it
609.36,6.4,is impossible for you to understand
612.959,5.281,the hardware design of a computer
615.76,4.8,processor or a micro architecture
618.24,4.4,without also understanding assembly
620.56,4.56,language that's fundamental you need to
622.64,4.08,understand these low-level commands that
625.12,3.36,are being executed by your micro
626.72,3.359,architecture and if you're ever
628.48,4.08,fortunate enough to work in a job where
630.079,4.88,you're developing a new processor a new
632.56,3.68,gpu a new arm core processor or
634.959,2.241,something like that
636.24,4.08,then
637.2,4.48,you know how you design your digital
640.32,4.32,hardware
641.68,4.88,to support your app um your your machine
644.64,4.8,language instruction set goes hand in
646.56,4.8,hand and you may choose to
649.44,4.16,make certain choices
651.36,4.159,when developing your instruction set
653.6,4.4,that will have certain implications on
655.519,5.361,how simple or complex the hardware is to
658.0,5.2,actually support that instruction set
660.88,2.32,and
663.279,3.68,hopefully that will become clear as we
664.8,4.0,work through this
666.959,4.961,as we work through this class because as
668.8,4.88,i said we're going to you know get
671.92,3.599,right down to the digital logic level
673.68,5.12,when we start to build up our micro
675.519,5.361,architecture but hand in hand step
678.8,3.68,by step we're going to also be talking
680.88,4.399,about assembly language and machine
682.48,4.88,language as we develop the hardware so
685.279,4.081,we're going to be simultaneously talking
687.36,4.719,about hardware and software all the way
689.36,2.719,through this course
693.6,3.12,so
694.399,5.521,when we talk about machine language so
696.72,6.08,machine language commands are the binary
699.92,5.76,instructions read from memory and dumped
702.8,4.8,directly to the processor for execution
705.68,3.279,and so these are very very low level
707.6,3.28,commands
708.959,3.601,and
710.88,2.8,you know as we
712.56,2.48,talked a little bit about in the
713.68,3.76,introduction
715.04,4.32,the machine the family of machine
717.44,4.24,language commands
719.36,4.4,that can run on a micro architecture in
721.68,4.24,many ways defines the architecture
723.76,5.04,itself and so the digital
725.92,4.56,design of the micro architecture like
728.8,2.839,the actual digital hardware blocks will
730.48,4.24,be developed
731.639,5.721,simultaneously with the notion of what
734.72,4.32,kind of instructions we want to run on
737.36,3.599,those digital blocks
739.04,4.56,and
740.959,4.32,there are basically when we when we look
743.6,4.56,at architectures from the machine
745.279,5.68,language perspective we can divide
748.16,4.32,architectures into two very broad
750.959,3.841,categories
752.48,5.52,complex instructions like computers or
754.8,7.36,cis computers and reduced instruction
758.0,4.959,set computers or risk computers
762.16,3.679,so
762.959,6.641,risk architectures tend to use fixed
765.839,5.44,length machine language instructions and
769.6,2.799,the
771.279,2.881,architectures that we're going to be
772.399,4.321,talking about in this class
774.16,6.72,arm and the avr architecture are both
776.72,6.799,risk architectures so arm processors
780.88,3.68,use 32-bit instructions
783.519,4.241,and
784.56,6.24,the avr architecture
787.76,4.48,mostly uses 16-bit instructions but
790.8,3.92,sometimes
792.24,5.2,for very complicated commands we'll have
794.72,3.919,we'll also use 32-bit instructions but
797.44,2.24,most of what we're going to be talking
798.639,2.801,about in this
799.68,3.839,class we'll focus on the 16-bit
801.44,4.24,instructions
803.519,5.921,sisk machine language instructions are
805.68,7.44,variable length and the most common
809.44,7.04,example of cis architectures are the x
813.12,5.6,the intel x86 architectures
816.48,3.79,a machine language command contains two
818.72,2.88,types of information
820.27,3.49,[Music]
821.6,3.52,the first is a field
823.76,3.68,sometimes called the funct field but
825.12,5.04,usually called the opcode field that
827.44,5.519,specifies the type of instruction
830.16,5.44,being executed so the opcode will say
832.959,3.841,this is a multiply instruction or this
835.6,3.44,is a
836.8,4.479,load memory instruction or this is a
839.04,4.239,store memory instruction so these op
841.279,4.161,codes are basically labels that indicate
843.279,3.68,what kind of instruction the processor
845.44,3.68,needs to execute
846.959,4.481,and in addition to the opcode typically
849.12,4.88,the machine language
851.44,4.639,instruction contains arguments or the
854.0,4.32,operands of the instruction so for
856.079,4.401,example if we're adding two numbers
858.32,4.319,together we would the op code would say
860.48,4.159,this is an add command and then the
862.639,4.0,operand part of the machine language
864.639,4.081,instruction would tell us exactly which
866.639,4.721,two numbers we're adding together and
868.72,4.479,where we should put the result
871.36,4.4,machine language commands are ultimately
873.199,3.521,placed in some kind of executable file
875.76,4.72,and so
876.72,6.32,when you create an executable file
880.48,4.799,when you compile a program
883.04,4.159,the executable file is a binary file and
885.279,3.92,it literally contains a whole bunch of
887.199,4.32,machine language instructions one after
889.199,2.32,the other
891.76,3.68,okay so i want to conclude this module
893.6,4.239,or finish it up by looking a little bit
895.44,4.8,more closely at the tool chain and the
897.839,6.641,operation of a tool chain can actually
900.24,6.32,be divided into four different stages
904.48,4.08,the preprocessor the compiler the
906.56,3.68,assembler and the linker so you'll see
908.56,5.36,that you know while we usually use the
910.24,6.56,word compiling to refer to the complete
913.92,5.359,process of taking a high level language
916.8,5.76,and creating an executable file it
919.279,6.161,actually refers to just a very specific
922.56,4.8,portion of that process
925.44,4.16,so the first thing i want to talk about
927.36,4.64,is a preprocessor now preprocessor
929.6,3.919,doesn't necessarily exist in all tool
932.0,5.12,chains but it is something that does
933.519,6.641,exist in c and c plus and it basically
937.12,4.32,converts c code to c code which is a
940.16,2.4,little bit confusing but i'll show you
941.44,2.639,an example
942.56,4.639,and
944.079,5.361,the reason why a preprocessor exists is
947.199,4.08,to basically allow
949.44,3.839,more
951.279,4.48,a more efficient programming style
953.279,5.36,without sacrificing
955.759,4.961,without bringing in a lot of overhead
958.639,5.041,and so for example you can make things
960.72,5.6,that kind of look like functions but
963.68,4.159,aren't full function calls and
966.32,4.8,they tend to perform a little bit better
967.839,5.36,or a little bit faster than um than
971.12,4.32,actual function calls and the output of
973.199,4.08,a preprocessor is a translation unit and
975.44,4.319,so there's a bunch of different
977.279,4.48,functionality in the preprocessor so if
979.759,4.32,you've worked with c or c plus plus
981.759,5.041,macros for example that's
984.079,6.481,a structure made possible by the by the
986.8,7.44,preprocessor but most people
990.56,3.68,are most familiar with
995.199,4.08,using the preprocessor to define
997.839,3.36,constants
999.279,5.92,and to
1001.199,5.921,include header files into different c or
1005.199,5.041,c plus plus source files and so
1007.12,4.8,basically whenever you see a hashtag in
1010.24,5.039,front of a command
1011.92,6.479,in a c or c plus plus file that's a
1015.279,5.041,preprocessor command and so all
1018.399,4.161,commands will start with hashtags are
1020.32,4.4,interpreted by the preprocessor and so
1022.56,3.04,we start with a c
1024.72,3.76,or c
1025.6,4.239,source file and then we translate the
1028.48,3.199,preprocessor
1029.839,5.281,creates something called a translation
1031.679,7.28,unit and so for example we can use the
1035.12,5.04,um the capital word const to represent
1038.959,3.761,33
1040.16,6.24,and then you know we can if we have an
1042.72,5.44,argument here we can add const to it and
1046.4,4.0,by giving it a name rather than just a
1048.16,3.519,value of 33 that helps make our program
1050.4,4.24,more readable
1051.679,3.761,but the preprocessor will take
1054.64,2.64,the
1055.44,4.0,we'll look for all
1057.28,4.96,occurrences of the keyword const and
1059.44,5.119,substitute in the value 33. so when we
1062.24,4.88,look at the translation unit the keyword
1064.559,3.921,const is gone and it's been replaced by
1067.12,3.61,33.
1068.48,3.76,also if we have
1070.73,3.11,[Music]
1072.24,3.76,you know in our header file if we have
1073.84,4.48,any function declarations
1076.0,3.919,those are
1078.32,5.76,you know in this case the function
1079.919,5.921,declaration is removed and the full
1084.08,5.12,you know source code definition of the
1085.84,6.4,function is placed in the start of the
1089.2,5.2,uh in the start of the c file and so
1092.24,5.04,it again it's a it's a subtlety it only
1094.4,6.08,exists for c and c plus plus it it
1097.28,6.0,translates c to c so we haven't really
1100.48,4.0,even started along the journey to
1103.28,3.68,um
1104.48,4.72,creating our machine code just yet
1106.96,4.24,but it is
1109.2,4.08,you know an important part of cnc plus
1111.2,4.16,plus tool chains
1113.28,4.48,so the next stage is the compiler and
1115.36,4.48,the purpose of the compiler is to
1117.76,3.84,convert our high-level language in our
1119.84,4.079,case our c
1121.6,4.56,into assembly language that is written
1123.919,4.561,to an assembly language file now for
1126.16,3.759,those of you who have compiled c and c
1128.48,3.12,plus plus
1129.919,4.0,programs before you probably don't
1131.6,3.92,remember having assembly language files
1133.919,4.0,just kind of lying around in your
1135.52,5.039,development directory and that's because
1137.919,4.64,they are intermediate and even though
1140.559,4.961,assembly language is generated it's
1142.559,4.881,immediately deleted by default by most
1145.52,4.72,compilers these days you have to sort of
1147.44,4.0,enable certain options in your compiler
1150.24,3.36,so
1151.44,4.72,in order for the assembly language to
1153.6,2.56,hang around
1156.32,4.239,and so here's an example
1158.08,5.12,the compiler operates on our translation
1160.559,5.041,unit so this is our c code and it
1163.2,4.24,converts our c code into assembly
1165.6,3.12,language and this is
1167.44,5.68,a mips
1168.72,6.56,assembly language implementation of that
1173.12,3.679,c translation unit and don't worry about
1175.28,4.16,understanding what all these commands
1176.799,4.88,are just yet we are going to get into
1179.44,4.8,this in a lot of detail as the course
1181.679,2.561,progresses
1184.559,5.041,now the assembler
1186.88,4.64,then is responsible for taking the
1189.6,4.319,assembly language produced by the
1191.52,4.399,compiler and translating it into the
1193.919,3.76,actual machine language instructions
1195.919,4.401,that will run on the processor
1197.679,4.88,and the output of an assembler is stored
1200.32,4.64,in an object what's known as an object
1202.559,3.921,file and so an object file is a binary
1204.96,3.12,file that literally contains a whole
1206.48,2.8,bunch of binary machine language
1208.08,4.079,instructions
1209.28,5.519,and an object file can be divided into
1212.159,5.52,kind of three parts there's what's known
1214.799,4.641,as the text segment which contains the
1217.679,3.921,machine language instructions of the
1219.44,5.359,program there's also something called a
1221.6,6.079,data segment that is used to initialize
1224.799,4.961,variables that are stored in memory on
1227.679,5.601,the microarchitecture
1229.76,4.96,and then there's a third area
1233.28,4.24,that contains
1234.72,3.839,a bunch of information that helps with
1237.52,2.56,linking
1238.559,4.321,and
1240.08,7.12,as a segue into that linking
1242.88,5.84,is the final stage of the tool chain and
1247.2,3.359,it is
1248.72,4.72,what makes it possible to use
1250.559,4.881,programming libraries now
1253.44,4.479,reusing other people's code is
1255.44,5.119,fundamental to programming efficiency
1257.919,3.841,we've all written programs where we've
1260.559,3.681,for example
1261.76,4.81,used printf to print to the screen or
1264.24,4.64,we've used functions to
1266.57,5.27,[Music]
1268.88,4.159,take input in from the keyboard or
1271.84,3.0,you know generate a little bit of
1273.039,5.921,graphics on the screen
1274.84,6.76,and to do all of that we use
1278.96,4.8,pre-written functions that are stored in
1281.6,3.68,something called libraries and without
1283.76,3.279,libraries programming would be
1285.28,3.44,incredibly inefficient because every
1287.039,3.12,time anybody wanted to do anything they
1288.72,2.959,would have to write all of their stuff
1290.159,3.52,from scratch
1291.679,3.441,and so
1293.679,3.201,we make use of lots of standard
1295.12,3.36,functions as i said you know printing as
1296.88,2.88,simple as printing out to the screen
1298.48,5.04,with printf
1299.76,6.24,and as complex as using gpu accelerated
1303.52,4.8,machine learning algorithms and so part
1306.0,4.08,of my research is machine learning and i
1308.32,4.16,use pre-written machine learning
1310.08,4.32,functions all the time i don't you know
1312.48,3.52,write rewrite all of the machine
1314.4,2.72,learning algorithms that we use for our
1316.0,3.919,work
1317.12,4.799,and the machine code for all of these
1319.919,5.441,pre-written routines are stored in
1321.919,6.561,special files called libraries
1325.36,6.559,and the purpose of the linker the final
1328.48,5.92,stage in our tool chain is to basically
1331.919,4.24,take the object file that contains the
1334.4,2.639,machine language of the code that we've
1336.159,3.201,written
1337.039,4.561,and connect it to
1339.36,5.199,machine language instructions that exist
1341.6,7.12,in libraries in order to produce our
1344.559,6.641,final executable file that can actually
1348.72,6.24,run as a completely
1351.2,5.92,atomic program on our processor
1354.96,4.16,and
1357.12,3.84,the result is stored in sometimes we
1359.12,4.32,refer to these as executable files
1360.96,3.76,sometimes we refer to them as as binary
1363.44,3.52,files
1364.72,4.56,and so again the linker sort of takes
1366.96,5.16,our object file and then pulls object
1369.28,4.879,code out of libraries depending on what
1372.12,3.72,pre-pre-written functions we want to use
1374.159,4.321,in our code
1375.84,5.36,so this notion of taking machine
1378.48,4.88,language code from our executable and
1381.2,4.16,connecting it with
1383.36,3.92,machine language code from a library is
1385.36,4.64,referred to as linking
1387.28,5.36,and linking can actually be done in two
1390.0,5.12,different ways we can use what's known
1392.64,4.8,as static linking and we can also use
1395.12,4.799,what's known as dynamic linking and so
1397.44,3.52,first of all static linking
1399.919,4.0,is where
1400.96,5.52,all machine language code from a
1403.919,5.441,particular library is copied over into
1406.48,6.319,the executable
1409.36,4.799,this is the type of linking that's done
1412.799,3.12,for
1414.159,4.88,very simple microcontrollers so for
1415.919,4.64,example when we program the avr
1419.039,2.961,chip
1420.559,4.081,um
1422.0,3.52,for the hands-on exercises in this class
1424.64,3.279,we
1425.52,5.44,our tool chain will always use static
1427.919,5.12,linking so if we use a library function
1430.96,3.839,for example if we take the square root
1433.039,2.88,of something and we use the square root
1434.799,2.48,function
1435.919,2.561,that
1437.279,3.041,the machine language code for
1438.48,4.799,implementing the square root will be
1440.32,5.04,copied into our executable
1443.279,4.0,it's basically or what we would often
1445.36,3.199,refer to as a hex file
1447.279,3.361,um
1448.559,4.081,when using this particular tool chain
1450.64,5.6,and then that executable or that hex
1452.64,6.72,file is completely copied over or loaded
1456.24,6.16,into the the avr chip
1459.36,5.12,so the advantages of of static linking
1462.4,4.399,it's easy to understand it's easy to
1464.48,4.0,port software between machines because
1466.799,3.281,everything you need all of the machine
1468.48,5.76,language instructions are contained in
1470.08,6.4,your executable um the disadvantage
1474.24,3.52,is that you can create very big
1476.48,3.04,executables
1477.76,3.84,there's really no way to avoid this when
1479.52,4.08,you're doing firmware development for
1481.6,3.24,for embedded devices like programming
1483.6,3.679,our little
1484.84,5.64,microcontroller but it does sometimes
1487.279,5.121,come as a surprise you know like if we
1490.48,4.48,use a whole bunch of library functions
1492.4,4.639,we might compile and then find out that
1494.96,4.319,our program doesn't fit on the flash
1497.039,5.12,memory in our device and it's because
1499.279,7.121,we've used so many libraries
1502.159,7.601,in contrast dynamic linking
1506.4,5.68,doesn't copy in all the machine language
1509.76,4.96,code from the libraries instead it only
1512.08,4.079,copies in the locations of the libraries
1514.72,4.4,and
1516.159,4.321,the operating system
1519.12,3.12,then
1520.48,4.48,is responsible for
1522.24,4.799,connecting our executable to those
1524.96,4.88,libraries in real time and so the
1527.039,6.321,executable will start to run
1529.84,5.36,and when it hits a library function
1533.36,4.96,the operating system actually connects
1535.2,5.28,our program to the machine language in
1538.32,4.8,the library in real time
1540.48,4.559,and allows our program to execute that
1543.12,4.4,code
1545.039,5.281,this only works for devices that have
1547.52,5.44,operating systems and so we won't be
1550.32,4.4,using dynamic linking in our hands-on
1552.96,3.28,exercises for this course but it's just
1554.72,2.8,important to know that it
1556.24,3.36,exists
1557.52,3.84,the advantages of dynamic linking i
1559.6,3.52,think are kind of obvious
1561.36,4.799,smaller executables since we're not
1563.12,5.52,copying in all of that code
1566.159,5.281,allows programs to take advantage of
1568.64,4.8,library upgrades so for example if some
1571.44,3.04,improvements were made made to a library
1573.44,3.2,function
1574.48,4.4,our executable can then jump to the
1576.64,4.88,upgraded library and hopefully run in
1578.88,4.399,exactly the same way
1581.52,3.6,this is more efficient for multitasking
1583.279,3.601,operating systems as well but the
1585.12,4.24,disadvantage is is it's harder to
1586.88,3.919,understand and can cause some software
1589.36,3.12,installation problems if you're trying
1590.799,3.681,to run a program
1592.48,4.079,on a computer that doesn't necessarily
1594.48,6.04,have all of the
1596.559,3.961,all of the required libraries
