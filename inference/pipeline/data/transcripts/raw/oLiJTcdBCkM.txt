second,duration,transcript
0.0,5.76,"Do you want to make some cool visuals effects 
for your games? For most games you don't need  "
5.76,4.32,"to think too much, but if you want some cool 
lighting effects or to make a nice looking  "
10.08,5.52,"3D game or some post-processing effects or 
stylized art you would need, at some point,  "
15.6,5.4,"learn the rendering pipelines. I can't say it's 
easy, but who said it would be? The whole game  "
21.0,4.92,"development process is very complicated, but 
this video will try to explain rendering in  "
25.92,5.82,"the most basic words possible and will gradually 
dig in deeper, so hopefully this knowledge will  "
31.74,4.74,"let you understand not only specific aspects of 
the chosen game engine, but the whole process  "
36.48,5.4,"used similarly in most of the engines and 
frameworks out there. So let's overcome the  "
41.88,6.0,"fear of getting into rendering by diving into the 
heavily inspired by OpenGL Rendering Pipeline."
56.88,5.82,"Render Pipeline is a whole process of making your 
visual components visible on a screen, but don't  "
62.7,5.7,"worry! Modern frameworks and game engines simplify 
the process. For example Defold takes care of  "
68.4,4.92,"a tremendous amount of stuff that is needed for 
each pixel to be displayed on different devices.  "
73.32,5.58,"You can interact with rendering on some very top 
layer, but also have the possibility to dig in  "
78.9,7.02,"to achieve really cool things. Render Pipeline 
answers 3 crucial questions: What to render?  "
85.92,7.5,"Where to render? and When to render? By answering 
them one by one you will see the whole picture.  "
93.42,7.38,"In Defold ""What to render"" is defined by Render 
Predicate - a kind of group of visual components.  "
100.8,5.16,"Where to render"" is defined by the view of the 
game's world through some kind of projection,  "
105.96,6.36,"like you would see the word through a camera, but 
on a flat screen. And finally ""When to render"" is  "
112.32,5.88,"controlled by the Render Script. So what you 
can render? Simply all visual components, but  "
118.2,4.92,"additionally, in Defold, you can group them. You 
can use the mentioned Render Predicates for this.  "
123.12,5.7,"Those are kind of filters allowing you to control 
what to render on screen. Visual components like  "
128.82,6.42,"for example Sprites, Tilemaps and 3D models are 
all rendered on screen separately, GUI nodes are  "
135.24,5.04,"drawn separately on screen or even some debugging 
lines and texts. You can create more such  "
140.28,5.4,"predicates to control what you are drawing, for 
example you can disable drawing GUI at all, you  "
145.68,6.18,"can enable drawing lights or 3D models separately. 
Such grouping give you more control over where  "
151.86,5.82,"and when you will be rendering different visual 
components. So imagine Render Predicates as just  "
157.68,7.86,"names, tags, filters in materials for each visual 
component. Material? Yes, each visual component  "
165.54,6.3,"has a material assigned to it. Material is a 
nice abstraction defining how to render a given  "
171.84,6.6,"component and thus answering part of the question 
""Where to render"". How? Because it defines special  "
178.44,6.66,"programs also called shaders that define how given 
geometry will be rendered. So ""where"" you would  "
185.1,5.16,"see components looking at the game's world through 
camera seeing some kind of view and projecting  "
190.26,5.58,"this view on your flat screen and then after 
""rasterization"", which I will explain later on,  "
195.84,6.48,"where"" to draw each pixel on screen. There are a 
lot of concepts in a few statements, so they all  "
202.32,5.52,"need to be explained, but before this, we'll focus 
more on the last question: ""When to render?"". This  "
207.84,5.52,"is defined in Defold in Render Script - the heart 
of the Render Pipeline, which describes the whole  "
213.36,5.64,"process of producing frames on screen. This is 
the one and only script in Defold that defines  "
219.0,5.58,"the whole rendering process. Take a look at your 
""game.project"" - 2 most important things are in  "
224.58,5.64,"one tab: the main collection that will be loaded 
at start of your game and the special render file,  "
230.22,5.4,"which contains simply 2 informations: the Render 
Script and the list of materials that could be  "
235.62,6.66,"used in it. That's all! Before we analyze the 
Render Script let's imagine how we produce pixels  "
242.28,6.72,"on our screens. Imagine each visual component 
in your game as a bunch of triangles. Even for  "
249.0,6.24,"2D Sprites those could be drawn on two triangles 
forming a rectangle. It's easy to imagine when  "
255.24,6.48,"looking at polygons in 3D models or a synthwave 
retro graphics. There's much mathematics involved  "
261.72,5.76,"behind it, because the graphics are calculated in 
a few steps. Each triangle consists of three lines  "
267.48,7.26,"connecting three points. Those points are called 
""vertices"". Each vertex is a point, a coordinate  "
274.74,6.12,"in 3D space, so one of the first steps in graphics 
pipelines are regarding operating on those  "
280.86,6.24,"coordinates, those vertices. So the program making 
calculations on those is called a Vertex Program  "
287.1,6.24,"or a Vertex Shader. Graphics cards are powerful 
in such calculations and don't even sweat making  "
293.34,5.82,"complex matrix operations on millions of points. 
After all those overwhelming calculations we  "
299.16,5.82,"have a nicely defined 3D geometry. There are few 
important, but more complicated steps in between,  "
304.98,5.88,"but at first, imagine you only get those triangles 
somehow and everything is very simple, and you  "
310.86,6.9,"get all this data projected into a flat screen to 
finally get you to the point of Rasterization. And  "
317.76,6.42,"this - is simply a slicing of all this geometry 
into small pieces, very well known as Pixels.  "
324.78,6.0,"For each of those pixels at the end we need to 
assign a color, so each diode on your device  "
330.78,7.26,"could be lit according to this and as whole form a 
frame. A color of each pixel is described as a mix  "
338.04,7.5,"of a given amount of Red, Green and Blue colors 
and additional transparency value. Graphics cards  "
345.54,6.0,"perform calculations for each pixel - a tiny 
fragment on your screen, utilizing a Fragment  "
351.54,6.06,"Program, also called Fragment Shader. At the 
end some additional work could be performed by  "
357.6,5.7,"the graphics engine which goes through some tests 
and blending stages. Are you with me? Could we go  "
363.3,6.66,"deeper into how those 3D triangles are actually 
projected on a flat 2D screen? There are a bunch  "
369.96,6.66,"of steps to transform each point in 3D into a 
point on the 2D screen, so we would go through  "
376.62,4.62,"them and name the steps and the coordinate 
systems that are produced after each of them.  "
381.24,6.36,"First we have a primitive, example geometry, 
let's say a 3D cube, which could be described  "
387.6,6.6,"with 8 points in 3D space. When you make such a 
cube in, for example Blender, it will be created  "
394.2,6.18,"in its local coordinate space and all points will 
be described in such a coordinate system. So each  "
400.38,5.7,"visual component in 3D games has their own Local 
Space, but you want all those objects to be put  "
406.08,6.3,"into our game world, so they need to be included 
in some common global coordinate system - the  "
412.38,6.72,"Word Space. You have a Model Matrix in-between 
that converts local points on our 3D cube and  "
419.1,5.82,"each other model to the world coordinate system. 
We won't analyze the mathematics behind it, but  "
424.92,5.46,"you might note that multiplying data by special 
matrices allows us to convert translations and  "
430.38,6.12,"rotations to different coordinate systems and this 
is what this Model Matrix is for. So when you have  "
436.5,5.34,"all the data in one World Space you then watch 
the world through the lenses of the camera or the  "
441.84,6.12,"player's virtual eyes. What you see is depending 
on where the camera is and at what it is pointing,  "
447.96,4.92,"right? So it's the view of the camera and so 
such a view has its own coordinate system,  "
452.88,5.88,"whose origin is commonly located at the middle of 
the view. To convert the World Space coordinates  "
458.76,6.48,"to View Space you perform a calculation with View 
Matrix. So the View Matrix is really describing  "
465.24,6.54,"your in-game camera. For example, in First Person 
Shooters you can feel how directly you rotate the  "
471.78,5.7,"camera around. And in 2D games you usually can't 
rotate the camera, but can move it around showing  "
477.48,5.94,"different pieces of the world. But defining only 
a view is not enough. We can't see the game's  "
483.42,5.76,"camera in three dimensions, because we need to 
somehow project this view to flat screens. We do  "
489.18,6.06,"this using a special Matrix called Projection 
Matrix and this step converts View Space to  "
495.24,5.88,"a so-called Clip Space. It is a projected view 
of what the camera sees and it's called ""Clip"",  "
501.12,5.4,"because all the coordinates that are outside 
such a projected view area are clipped and  "
506.52,5.82,"not shown on screen. The remaining coordinates 
will end up as Fragments visible on screen and  "
512.34,5.1,"what's funny - when some triangles on the edge 
of view are cut in half because of such clipping,  "
517.44,5.28,"the graphics engine automatically creates new 
triangles on the edges to actually fit inside  "
522.72,6.06,"and fill the whole screen. Finally such a clipped 
view is then very quickly converted into another  "
528.78,5.82,"convenient space, which is a Screen Space with 
its origin commonly in a corner of the screen. And  "
534.6,5.52,"this is done with the use of a Viewport Matrix. 
You don't need to actually always use the whole  "
540.12,4.74,"screen making fullscreen games, but you can draw 
everything in a window that could have different  "
544.86,5.94,"dimensions - and this is exactly what the Viewport 
is for. You define the dimensions of a rectangular  "
550.8,6.84,"space, on which you will be drawing all your 
pixels. OK! Another level of diving in! We  "
557.64,5.04,"barely mentioned how the pipeline projects the 3D 
View to a flat screen, but you might be aware that  "
562.68,5.76,"there are different kinds of projections. Each 
projection could be defined by a special 3D shape:  "
568.44,6.18,"a sliced lump or most simple cuboid or even 
a cube - called professionally ""Frustum"".  "
574.62,6.78,"It has two important sides, called Near and Far 
planes that are actually parallel to the screen  "
581.4,5.16,"and the rest of the sides just connect them. 
Especially, very simple kind of projection,  "
586.56,6.48,"such that Near and Far planes have the same area 
is called an Orthographic Projection. Its name is,  "
593.04,4.38,"because the lines describing the view 
then are orthogonal to the view plane,  "
597.42,5.82,"so the Frustum is a simple Cuboid. So 
effectively you don't scale 3D objects to screen,  "
603.24,5.76,"like you think the objects far away from you are 
perceptibly smaller than the ones closer to you,  "
609.0,6.36,"but see them in a way that imaginably are far, 
far, infinitely far away from you (but you have an  "
615.36,5.64,"eagle sight!) Orthographic Projection is commonly 
used in 2D games, because it's simple, very clear  "
621.0,6.48,"and because you have flat sprites that don't look 
good in perspective projections. Yeah, I mentioned  "
627.48,5.52,"it without explaining, but very easily you imagine 
that Perspective Projection is an opposite. It's  "
633.0,6.0,"an effect, where you see objects far away from you 
actually smaller than the ones close to you. It's  "
639.0,4.92,"very useful for 3D games, because it really 
is corresponding to our actual perception,  "
643.92,6.3,"to how our eye see. In such projections the lines 
connecting the Near and Far planes are actually  "
650.22,6.78,"meeting at one point in space and an angle between 
them is called Field of View (FOV). This angle,  "
657.0,6.78,"for realistic projection like our eyes work, is 
usually around 45 degrees, but it's maths and  "
663.78,5.88,"nothing stops you from making Field of View of 60 
degrees even, like in Doom games! It will be kind  "
669.66,6.54,"of deformed, but you will let players see more on 
a flat screen. All those coordinate systems are,  "
676.2,7.14,"by OpenGL convention, right-handed, because, 
well, take your right hand and look at its inner  "
683.34,6.54,"side with all fingers pointing up, in the positive 
direction of the Y-axis. Let your thumb point to  "
689.88,5.76,"the right, to the positive direction of the X-axis 
and bend some of your fingers to the front of you,  "
695.64,5.88,"to point in the positive direction of the Z-axis. 
You might, at some point, take advantage of such  "
701.52,5.34,"knowledge, so thank me later! That really 
is a lot of information for one video,  "
706.86,6.84,"so for even more thorough explanations I invite 
you to check out Learn OpenGL website, where Joey  "
713.7,6.6,"explained in the most affordable and detailed way 
how OpenGL works. And I mentioned OpenGL a few  "
720.3,5.34,"times already without saying what it is, because 
it's not so simple. It's not a language, it's  "
725.64,6.06,"not an implementation of rendering - it's just a 
Specification, a Standard describing how functions  "
731.7,5.7,"should communicate with graphic cards to produce 
desired results. It's generally the graphics card  "
737.4,6.24,"manufacturers that implement drivers for this. 
And game engines are usually an abstraction of  "
743.64,6.54,"using raw OpenGL functions, more thin or less, but 
in the end, they simplify this. Defold is running  "
750.18,5.7,"on OpenGL and therefore its render pipeline 
is heavily influenced by OpenGL workflow,  "
755.88,5.64,"but thanks to offering such an abstraction layer 
over OpenGL - the underlying renderer could be  "
761.52,6.06,"replaced and for example many engines, including 
Defold, also offers support for Vulkan and WebGL  "
767.58,5.22,"render pipelines. Such possibility is crucial to 
support different devices, because, for example,  "
772.8,6.96,"Apple devices use Metal, while HTML5 builds run 
on WebGL. But you don't care about it - it's a job  "
779.76,5.7,"of Defolf! You build one rendering pipeline and 
could release on many platforms simultaneously and  "
785.46,4.8,"that's what makes a game engine multi-platform. 
You will find a similar approach in most of the  "
790.26,5.34,"engines. Community is also fiddling with renderers 
and for example there is a possibility to make a  "
795.6,5.46,"game in Defold, but with RayLib renderer. For 
now, please digest the amount of information  "
801.06,5.52,"provided here and in the next video we will dive 
into the render script of Defold. And by the way,  "
806.58,5.4,"if you want to help creating such videos - leaving 
a traditional like, a comment and subscribing to  "
811.98,4.68,"my channel with this ""ding dong"" ringing helps 
me be encouraged to continue and make more  "
816.66,6.18,"videos! And for even more support - I already run 
Patreon, Ko-Fi and soon - GitHub Sponsors - sooo,  "
822.84,4.86,"you know - my kind of pig bang for future is 
there :) Have a nice day and see you soon!"
