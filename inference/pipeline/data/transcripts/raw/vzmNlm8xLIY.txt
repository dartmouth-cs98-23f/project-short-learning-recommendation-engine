second,duration,transcript
0.089,6.721,click the Bell icon to get latest videos
2.669,6.6,from Akira how the friends today we'll
6.81,5.07,talk about the implementation of an atom
9.269,4.981,a city and durability in the transaction
11.88,4.38,that means we have described the
14.25,5.49,properties of atomicity and durability
16.26,6.06,now today we will know that how we can
19.74,5.789,implement these two properties in the
22.32,5.16,transaction using some procedures we
25.529,5.921,will discuss the shadow copy as a
27.48,7.04,procedure to implement this two features
31.45,3.07,[Music]
38.57,5.41,atomicity and durability are two
41.28,5.49,inseparable features from each other on
43.98,5.849,which the transaction is built on that
46.77,6.09,means a transaction is performed at all
49.829,5.491,of its entirety or not performed at all
52.86,5.129,that is the atomic feature and the
55.32,5.669,durable feature is the data that we are
57.989,5.761,using for the updation is inconsistent
60.989,5.7,and durable data that means when it will
63.75,6.57,be stored in the disk then it will be
66.689,6.031,affect the update and also the data that
70.32,5.79,we are storing it back to the disk will
72.72,5.93,not lose any of this contents so that is
76.11,6.06,the feature of atomicity and durability
78.65,6.1,now to implement these two features in
82.17,5.16,any of the transactions there are many
84.75,5.22,methods today we will talk about the
87.33,5.28,most simple but also an extreme
89.97,5.43,inefficient method we will go for the
92.61,5.52,inefficiency later but first discuss the
95.4,5.94,procedure of having implemented this
98.13,6.5,atomicity and durability the process is
101.34,3.29,called Shadow Copy
107.43,7.56,the shadow copy of a database extract if
111.78,6.18,there is any transaction that is taking
114.99,5.58,care of a particular access to a portion
117.96,5.4,on the database then it considered that
120.57,5.97,the database is having only that file on
123.36,7.02,which the transaction is best say for an
126.54,7.29,instance if TI belongs to the
130.38,7.23,transaction part on any fi that belongs
133.83,7.14,to the database DB now the transaction
137.61,7.08,TI that is taking care of fi now it will
140.97,7.65,consider that if I for all parts of this
144.69,7.14,TB so now the DB is divided into in any
148.62,6.75,area then we can say that if is in part
151.83,6.21,of that area so now we are having a
155.37,6.33,database and a file that is considered
158.04,6.3,to be a part of that database now when
161.7,4.83,the transaction is pointing to this file
164.34,4.26,that means the transaction is accessing
166.53,5.34,this file as a part of its database
168.6,6.33,access so there will be an shadow copy
171.87,5.339,of this file so what is in shadow copy
174.93,5.13,before that we will introduce a term
177.209,5.401,called pointer now our transaction ill
180.06,7.46,have a pointer that is known as a DB
182.61,4.91,pointer so now my DB pointer
188.489,6.511,will point to the copy that the database
191.579,8.36,the transaction will axis say that the
195.0,4.939,database is considered to be copy the FI
201.2,5.84,so now my fi has the old copy
208.2,5.13,of this database so my DB pointer is
211.5,4.47,pointing to the old copy of this
213.33,4.89,database now whenever the transaction
215.97,5.64,needs to access this particular portion
218.22,7.799,fi then what happens it just copy this
221.61,6.81,shadow copy into a new portion now for a
226.019,6.421,transaction this copy will be made
228.42,7.039,entirely to a new file so now a copy of
232.44,3.019,fi will be made
244.72,5.58,so now we have made a new copy now when
247.57,4.89,there is any update or any modification
250.3,4.53,or any access from the transaction to
252.46,4.89,this database then it will be made to
254.83,5.46,this new copy not this Shadow Copy
257.35,6.51,anymore now it weakens the Shadow Copy
260.29,5.91,of that database why we are calling this
263.86,5.73,an Shadow Copy we'll introduce a little
266.2,6.0,much later now when this new copy is
269.59,5.37,being made all this entirety of the
272.2,5.16,database now the updation or the
274.96,4.71,modification will be made to it and now
277.36,4.44,my DB pointer or the database pointer
279.67,5.04,will point to this part of this copy
281.8,6.74,while leaving the database of this old
284.71,3.83,copy as the Shadow Copy
294.15,8.6,so now my DB pointer will point to this
297.09,5.66,new copy instead of this old copy
304.469,5.55,now we can say that when the updation is
307.439,5.93,made to this new copy so we consider it
310.019,3.35,as an updated copy
314.1,5.22,now that if we are having this updated
316.83,5.67,copy so this old copy of database will
319.32,5.91,be deleted and now this one becomes a
322.5,4.98,shadow copy of that database see this
325.23,4.77,one will be deleted as the old copy of
327.48,5.04,database this one is a new copy of the
330.0,5.22,database that will be updated and this
332.52,6.03,one becomes a shadow copy which is just
335.22,5.28,left behind this pointer now what
338.55,4.17,happens and how the transaction is
340.5,4.11,performed to this which can main is
342.72,4.56,atomicity and durability
344.61,5.31,now when the transaction is performing
347.28,5.76,it has started and it gets completed or
349.92,6.06,committed it execution then the new copy
353.04,5.61,of this if I will be made written back
355.98,5.22,to the database on this disk to have
358.65,5.52,affected the transaction is completed by
361.2,6.24,its own so it is supporting this old
364.17,5.7,copy and now as we are maintaining the
367.44,5.22,DBA pointer first made and shadow copy
369.87,4.44,and now then the new copy of the updated
372.66,3.99,copy will be written back to the
374.31,5.37,database now in the midst of this
376.65,5.76,transaction if there is any problem then
379.68,5.25,it can get back this old copy which is
382.41,5.07,to be deleted but the shadow copy will
384.93,5.61,remain there too as a part of the
387.48,6.0,durable data that means if the updated
390.54,6.15,copy is lost in that way we can refer to
393.48,6.24,this shadow copy to get reference to the
396.69,5.4,old data so now we are having the shadow
399.72,5.16,copy concept now let us describe the
402.09,4.89,transaction in elaborative leaf for
404.88,4.92,these three cases so now we will
406.98,5.85,consider our DB pointer in each of these
409.8,5.79,cases the first year is that the
412.83,4.95,transaction is committed so where my TB
415.59,5.28,pointer will point to it will point to
417.78,5.1,my disk back to the database where it is
420.87,5.49,having the entire database with an
422.88,6.38,updated copy so for the committed
426.36,2.9,transaction
432.26,10.36,DB pointer will point to the disk on
438.93,6.24,which the FI is there now in the second
442.62,5.07,case say for instance that the
445.17,5.79,transaction has started but cannot
447.69,5.4,commit its operation so now my TP
450.96,6.35,pointer will point to the shadow copy
453.09,4.22,that is the old copy of the database
460.689,5.641,as we know that the atomic property of a
463.749,5.46,transaction doesn't support any partial
466.33,5.309,commitment of the transaction so now it
469.209,5.07,will not take in consideration the
471.639,4.44,optician it has made to the new copy the
474.279,5.15,DB pointer will now point to the
476.079,3.35,original shadow copy
482.78,6.51,now the third cases is divided into two
486.05,6.18,section first ad that commits is made to
489.29,6.63,this new updation but it is not written
492.23,6.89,back to the disk then what happens now
495.92,3.2,in the third case
505.469,5.85,so now my update is on the new copy but
508.769,4.68,not on the disk if I that means the
511.319,4.41,commitment or the log has not been
513.449,4.89,written to the disk so now we're my
515.729,5.79,Dibby star will point to so according to
518.339,6.36,the atomic nature even if the data is
521.519,6.36,completely updated on to the new copy it
524.699,5.551,will not be back on to the disk then we
527.879,5.041,cannot have the transaction considered
530.25,4.8,as committed until and unless it is
532.92,4.83,written back to the disk using the write
535.05,4.589,ahead logging rule also we will now
537.75,4.069,point to this shadow copy of the
539.639,2.18,database
546.829,5.531,now let us consider the third case on
549.829,5.441,this section two
552.36,5.64,that the update is made on the new copy
555.27,6.18,and the data is ver Tritton on the disk
558.0,6.09,copy but the disk is lost then what will
561.45,5.79,happen that we are having the old copy
564.09,5.85,that it is deleted and now the Shadow
567.24,5.22,Copy that it is pointing to and now the
569.94,4.38,new copy that is being updated is being
572.46,4.89,written to the disk that means the new
574.32,5.22,copy is also we are having so in the
577.35,4.89,Shadow Copy technique the DP pointer
579.54,5.58,will point to this new copy until on
582.24,5.85,unless we're having a final disk copy of
585.12,6.54,that update see the disk has written
588.09,6.66,this update but not the disk is affected
591.66,5.85,on this update so now my DB pointer will
594.75,5.06,point to this new copy not the Shadow
597.51,2.3,Copy
606.559,5.16,now see that the dis written to the disk
609.229,4.32,but as lost so which nature it is
611.719,5.37,satisfying it is satisfying the
613.549,7.02,durability that whoever having this new
617.089,6.39,copy on this disk it can now be taken to
620.569,5.36,another non-volatile storage of this law
623.479,5.28,step it is performed on this disk copy
625.929,5.83,so now that the Shadow Copy is being a
628.759,5.76,procedure to provide the first two cases
631.759,5.82,for this atomicity and the third case of
634.519,5.07,this a and because of the durability so
637.579,4.71,now we have implemented that immensity
639.589,4.68,and durability both but the main
642.289,4.74,disadvantage of the Shadow Copy
644.269,6.18,technique it is extremely inefficient in
647.029,6.0,whatever it is inefficient rather than
650.449,5.1,it is producing an implementation of
653.029,5.55,this atomicity and durability we are
655.549,6.06,considering copying the entire database
658.579,6.54,into as a new copy where the pointer is
661.609,6.72,pointing to because the database is now
665.119,5.19,considered to be the file so now we are
668.329,5.16,having the file as this particular
670.309,5.88,database so we need a larger memory area
673.489,6.57,for each of the transaction that the
676.189,6.68,database pointer will point to and the
680.059,5.76,second one is it will not consider any
682.869,6.07,transaction that is completed on the new
685.819,6.09,copy but not updated on this disk also
688.939,5.1,it is considered as the non commitment
691.909,4.89,of this transaction and point to the
694.039,5.79,Shadow Copy now the shadow copy itself
696.799,6.18,becomes an redundant storage but the new
699.829,5.16,copy it is being made that means it
702.979,5.07,could have made the update in the Shadow
704.989,5.88,Copy but then it will not be implemented
708.049,5.88,with this atomicity and durability so
710.869,5.851,now the next bus that we will need to do
713.929,4.98,is this term next expensive and also
716.72,4.679,some more efficient data storage
718.909,5.19,mechanism so that we can implement this
721.399,5.7,atomicity in a much more efficient way
724.099,6.24,Shadow Copy is generally considered big
727.099,5.46,very popular in a smaller database but
730.339,5.64,for a larger database where we need to
732.559,5.7,store every file in the database and for
735.979,3.611,small portion of the file we need to
738.259,4.031,restore the database
739.59,5.22,at its entirety will become a difficult
742.29,4.86,task for us so that is all for
744.81,5.58,implementing atomicity and durability
747.15,5.4,using this shadow copy technique thank
750.39,6.32,you for watching this video stay tuned
752.55,4.16,with Akira and subscribe to Akira
