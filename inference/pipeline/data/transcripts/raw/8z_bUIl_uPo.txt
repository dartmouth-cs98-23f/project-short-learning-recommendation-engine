second,duration,transcript
0.0,3.12,[Music]
1.079,3.421,this video is intended for those who do
3.12,4.199,not know what functional programming is
4.5,4.139,with an assumption in order to be aware
7.319,3.481,of the fact that you don't know what
8.639,3.661,functional programming is I suppose you
10.8,3.24,must be familiar with some other
12.3,3.539,programming Paradigm that is you should
14.04,3.659,be familiar with some language similar
15.839,3.36,to one of these
17.699,2.941,great now
19.199,3.541,one thing that you'll have probably
20.64,3.479,realized by now is that despite having a
22.74,3.119,few things in common
24.119,3.42,these languages also have lots of
25.859,3.781,differences I'm not talking about
27.539,4.801,differences in syntax syntax doesn't
29.64,5.099,matter I'm talking about semantics the
32.34,5.46,meaning and behavior of your programs
34.739,5.701,let's take C you may know that c doesn't
37.8,5.279,have classes or objects unlike C plus
40.44,4.68,plus Java and python
43.079,4.261,we say that c is an imperative language
45.12,5.279,since its instructions are shaped like
47.34,5.699,commands unless it is procedural since
50.399,5.311,it is based on procedure calls usually
53.039,6.18,improperly referred to as function calls
55.71,5.489,[Music]
59.219,4.14,you will disagree about the improperly
61.199,4.32,but I'm also sure that you all know that
63.359,4.681,procedure means different things in
65.519,4.561,different contexts sometimes it's used
68.04,4.86,to denote a piece of code that does not
70.08,5.46,return a value as opposed to a
72.9,5.34,function which does
75.54,4.619,in this video by procedure I mean any
78.24,5.1,sequence of instructions which may well
80.159,5.28,contain a return while a function in the
83.34,4.319,functional programming sense is a much
85.439,3.371,more abstract idea which we will explore
87.659,4.7,later in the video
88.81,3.549,[Music]
92.64,3.479,on the other hand are called
94.159,4.061,object-oriented languages
96.119,4.801,but the instructions inside their
98.22,4.92,methods are still commands so these
100.92,4.32,languages are still based on the same
103.14,3.96,imperative paradigm
105.24,3.54,one of the things that make functional
107.1,4.08,languages most different from the ones
108.78,5.159,you're probably used to is the fact that
111.18,5.64,the instructions are not commands but
113.939,4.5,expressions and a program is not a
116.82,5.339,concatenation of declarations and
118.439,6.241,commands but a composition of functions
122.159,4.801,we'll call this property one
124.68,3.66,there's also another big difference the
126.96,3.28,biggest one probably
128.34,4.619,and I'll introduce it later in the video
130.24,5.12,[Music]
132.959,4.441,when we refer to functions we mean it in
135.36,5.76,the mathematical sense of maps between
137.4,5.339,sets such that the output depends solely
141.12,4.259,on the input
142.739,5.881,a procedure can be a function for
145.379,5.461,example this python procedure is a
148.62,4.38,function that takes an integer and
150.84,3.96,returns an integer
153.0,4.98,in mathematical notation we would write
154.8,4.98,this function as F from integers to
157.98,6.839,integers
159.78,7.8,such that X maps to x squared
164.819,6.901,this symbol here means Maps 2 and
167.58,7.5,writing F such that X maps to x squared
171.72,6.659,is equivalent to writing F such that f
175.08,5.76,of x equals x squared
178.379,5.041,I prefer to use the map 2 notation here
180.84,5.42,since it allows for a better transition
183.42,2.84,later in the video
186.3,3.299,let's look at another example that
187.86,3.48,should bring us a little bit closer to
189.599,3.901,the functional paradigm
191.34,4.319,if we wanted to define a python function
193.5,3.54,that Returns the sum of the squares of
195.659,3.121,two numbers
197.04,3.9,we could either write the following
198.78,3.9,procedure
200.94,5.6,or if we wanted to separate the
202.68,3.86,operations write something like this
207.18,4.199,now remember what we said about the
208.86,4.68,functional Paradigm property one
211.379,4.561,rather than using a concatenation of
213.54,4.02,declarations and commands we want to use
215.94,5.28,function composition
217.56,6.0,so we can rewrite the function like this
221.22,4.5,this is closer to satisfying the first
223.56,4.319,property
225.72,4.68,there is still a problem though
227.879,3.541,that return thing over there is a
230.4,3.18,command
231.42,5.399,and one command is enough to make this
233.58,6.299,computation a concatenation of commands
236.819,5.101,thus violating property one
239.879,3.42,we can solve this by introducing a
241.92,2.64,second property of functional
243.299,4.8,programming languages
244.56,5.879,the presence of anonymous functions
248.099,3.901,Anonymous function is a function without
250.439,3.72,a name
252.0,4.32,we will represent Anonymous functions at
254.159,2.711,least for now by means how the maps to
256.32,2.699,notation
256.87,3.95,[Music]
259.019,2.821,instead of writing our function like
260.82,2.76,this
261.84,4.139,we will stop using python for a while
263.58,6.0,and represent our function in a weird
265.979,6.241,mathematical to the language like this
269.58,4.32,notice that we use the same equal symbol
272.22,4.62,that we might have used to assign the
273.9,5.579,value 3 to an integer variable X
276.84,4.5,this is a hint that a most important
279.479,3.78,property of all
281.34,3.66,Anonymous functions can be assigned to
283.259,4.561,variables the very same way that a
285.0,4.86,number can be assigned to a variable
287.82,4.62,numbers can be the inputs and outputs of
289.86,5.7,functions so I guess the next obvious
292.44,7.74,step would be using Anonymous functions
295.56,7.32,as the input of other functions like so
300.18,5.22,and also as the result of other
302.88,5.52,functions
305.4,7.32,in this case the function Foo is a
308.4,7.079,function that returns a function so this
312.72,6.12,Returns the function that multiplies the
315.479,6.781,input by 2. hence the following
318.84,4.799,computes the value 2 times 5.
322.26,4.02,[Music]
323.639,3.9,should we call this property three I
326.28,3.66,guess
327.539,4.081,this is I think the most important
329.94,3.9,property of functional programming
331.62,4.2,languages
333.84,3.48,these may or may not surprise you but
335.82,3.54,several languages you may already know
337.32,3.719,like Python and JavaScript
339.36,3.96,already have the possibility of writing
341.039,3.961,programs that satisfy these three
343.32,3.599,properties
345.0,3.18,for example you can write synonyms
346.919,4.861,functions and pass them to other
348.18,5.76,functions in Python by using this syntax
351.78,3.84,and in JavaScript by using these other
353.94,3.3,syntax
355.62,3.96,this is because these languages are
357.24,5.28,multi-paradigm languages
359.58,4.74,but what about purely function languages
362.52,4.5,Python and JavaScript allow us to use
364.32,5.52,functional tools while still having the
367.02,5.58,possibility to concatenate commands
369.84,6.5,how do you like iteration without table
372.6,3.74,Z to concatenate commands
376.5,4.38,in purely functional languages we don't
378.479,3.78,have iteration but it's not really
380.88,3.78,necessary
382.259,5.22,functional languages use recursion as
384.66,5.159,their equivalent of iteration
387.479,3.901,as you may know every while loop can be
389.819,3.72,transformed into a tail recursive
391.38,4.74,function by moving the variables you're
393.539,3.861,checking from the god to the base case
396.12,2.579,of the recursive function
397.4,3.1,[Music]
398.699,3.601,if you're familiar with recursion and
400.5,3.96,you're using it already in your Paradigm
402.3,5.82,of choice the transition to any
404.46,5.28,functional language will be quite smooth
408.12,5.579,another thing you may be asking yourself
409.74,5.579,is what about conditionals well I'm sure
413.699,4.801,you've used some sort of inline
415.319,6.72,condition already or a ternary operator
418.5,5.52,so it's basically the same
422.039,3.6,and this is already most of what you
424.02,3.6,need to know in order to have a vague
425.639,2.821,idea of what functional programming is
427.62,4.019,like
428.46,5.34,but you want the good stuff Danny the
431.639,5.101,Lambda juice the color the Purity the
433.8,4.679,platonic world of ideas
436.74,4.62,the python Syntax for anonymous
438.479,5.401,functions contains the word Lambda
441.36,4.92,this is derived from notation introduced
443.88,3.42,by Alan turing's color friend Alonso
446.28,2.759,Church
447.3,3.48,he wrote the functions I represented
449.039,2.821,with them of stew with a different
450.78,3.45,notation
451.86,3.959,that features the Greek letter Lambda
454.23,4.83,[Music]
455.819,5.581,actually this is a bit wrong
459.06,4.62,since in Lambda calculus which is what
461.4,5.04,we're doing right now functions have a
463.68,5.22,fixed erity of 1 which means they only
466.44,4.44,have one parameter
468.9,4.44,functions with more than one parameter
470.88,4.5,can be simulated by doing something like
473.34,3.84,this
475.38,4.02,If the previous function was in
477.18,4.919,mathematical notation a function from
479.4,5.16,the integers times the integers to the
482.099,4.681,integers which means a function that
484.56,5.1,takes couples of integers as its input
486.78,5.58,and returns a single integer
489.66,4.74,this new function is from the integers
492.36,5.839,to the set of functions from the
494.4,3.799,integers to the integers
499.08,3.839,it is quite simple to show that these
501.0,3.539,two functions call in these two
502.919,4.441,different ways
504.539,6.541,are in fact equivalent
507.36,6.66,this property is known as currying
511.08,5.16,to be even more precise Lambda calculus
514.02,5.34,does not even have an explicit notion of
516.24,5.4,numbers or operations or booleans or
519.36,4.799,even recursion
521.64,3.78,for example numbers are represented like
524.159,4.74,this
525.42,6.419,and this thing called the Y combinator
528.899,4.921,makes recursion
531.839,4.381,luckily for us we don't need to use the
533.82,4.5,Lambda calculus in its original form
536.22,6.559,just like we don't need to use Turing
538.32,4.459,machines or general recursive functions
543.24,4.14,modern functional languages are very
545.16,5.96,rich of features that make them very
547.38,3.74,suitable for some tasks
551.7,4.86,the functional language I'm most
553.26,5.1,familiar with happens to be okamo
556.56,4.32,the most powerful tool in the kennel is
558.36,4.14,one called pattern matching
560.88,4.62,the simplest way I can describe pattern
562.5,5.399,meshing is it's like a switch but rather
565.5,4.62,than checking the value of a variable it
567.899,3.38,checks whether an expression matches a
570.12,3.899,pattern
571.279,5.201,these used together with algebraic data
574.019,4.091,types makes writing interpreters in a
576.48,3.72,camel almost trivial
578.11,4.25,[Music]
580.2,3.78,a lot of verification tools and proof
582.36,2.64,assistance are based on functional
583.98,4.14,programming
585.0,4.8,and some of them are written in a camel
588.12,4.02,apparently there is also at least one
589.8,4.26,company that uses a camo for their
592.14,4.379,services
594.06,4.62,but why am I saying all this
596.519,4.38,why do I have to point out that there
598.68,4.44,actually are areas in which functional
600.899,4.801,programming is much more suitable than
603.12,4.86,other paradigms well because you may
605.7,4.74,have heard some people claim that her
607.98,5.22,functional programming is useless I mean
610.44,5.82,computation without state is so elegant
613.2,5.16,but no collateral effects how can a
616.26,3.62,programming language be useful if it
618.36,3.36,can't even print a screen
619.88,3.459,[Music]
621.72,4.799,so apparently there is one thing I
623.339,5.641,forgot to mention collateral effects
626.519,4.561,if you cannot concatenate commands you
628.98,4.44,cannot do something like this
631.08,4.439,printing raising exceptions and other
633.42,3.24,things like these cannot be done in a
635.519,2.701,standard way
636.66,3.359,there are several ways to have
638.22,2.64,collateral effects in a purely function
640.019,2.76,language
640.86,3.5,one of which is
642.779,4.671,Moana
644.36,3.09,[Music]
649.019,3.06,how the languages like camel simply
651.0,3.18,include the possibility to have
652.079,4.26,collateral Effects by breaking the first
654.18,4.2,property and allowing the user to
656.339,4.44,concatenate a function of return type
658.38,5.04,unit which is basically a call to avoid
660.779,5.881,function to your expression so basically
663.42,7.28,no you do have ways to print in function
666.66,4.04,languages even impure ones
670.86,4.8,in general I think it's a good thing
672.839,4.68,that basically old modern languages have
675.66,3.9,functional features
677.519,4.081,apart from java introducing languages in
679.56,4.44,Java was a bit of a mistake but Java as
681.6,4.38,a whole was a bit of a mistake so that's
684.0,3.66,not a story
685.98,3.9,the more paradigms a language can
687.66,3.78,support the more we can adapt it to our
689.88,4.56,needs and use the most appropriate
691.44,5.1,Paradigm each time
694.44,3.839,I hope I gave you a decent overview of
696.54,2.76,the main characteristics of function
698.279,2.881,languages
699.3,5.84,let me know what you think in the
701.16,3.98,comments see you next time
705.47,2.789,[Music]
