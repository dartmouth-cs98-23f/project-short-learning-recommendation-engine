so theres not going to be a lot of code that im going to show its mostly going to be talking about concepts and functional programming therell be a little bit of code and talking about what people mean by functional programming and how we might uh want to broaden what people mean by functional programming to talk about some other stuff in this meetup so uh first of all if youre going to talk about functional programming its going to talk about what a function is right so at its base a function is a map between inputs and outputs specifically its a map so that for any set of inputs you get one output of course you can define you can define this in a lot of different ways you can sometimes youll see a table like right here youll have a table where you have inputs on the left and outputs on the right or youll see it in like a more mathematical setting where you have like f of x and then some transformation on x and then you know this this mathematical definition of a function is a little bit different than the way we use the word function in programming which generally means procedure we mean some place where were going to run a piece of computation and then bring the results back to the main loop or the main part of the program so when functional programmers say functional programming they mean viewing your computation through this lens through this idea of inputs and outputs and the closer you can get to that the more like um functional programming the more sorry the more functional programming youre doing yeah so like i said what is functional programming common answer the basic unit of computation is a function so that being said when you actually do functional programming a lot of times it doesnt really look like what youre doing is writing down functions and then computing inputs and outputs instead things look pretty crazy and this is a sample of reason i could have just as easily put a sample of haskell or scala or really any functional programming language ive ever used while its while i can understand how im using functions it oftentimes doesnt feel like thats what im doing so i wanted to talk a little bit you know about what is it that were getting if its not just about inputs and outputs what is it that were getting out of functional programming but first i was really curious uh just how many of you have actually written programs in a functional setting before i guess raise your hand if youve written functional programs before okay pretty good probably about half the group so thats thats awesome and i guess raise your hand if youd like to do it again i guess judging from you know being here thats really great um you know a lot a lot of people havent a lot of people dont really know what it is that uh functional programmers are talking about if theyve ever heard of it at all um so im gonna try and go through some of what it is so before i was talking about you know what a definition of functional programming is and id say its computation as a base unit of a function but to try and be a little bit more intuitive maybe itd be better to stop and think about like what do functional programming languages have in common so also what do people who do functional programming what do they seem to want out of the languages theyre using and then if youre not a functional programmer why might you want to learn about it whether you you know go and get a job as a functional programmer or not you know you might still want to know about it for for several reasons and then lastly you know what kind of problems are really does this stuff really work well for all right so first what do functional programming languages have in common so i would say even above mapping inputs to outputs the idea that functional programming languages really have in common is separating the transforms of data from the data itself compare that to an object-oriented approach where youre defining a class and then that class is going to have methods so in fact you define your data first thats the class and then you define the methods that operate on the data in functional programming instead youre going to define a set of functions that take data and then its up to those functions to define whether that data is acceptable or not either through a type system or through a set of you know conditional checking and contracts but they the reason that you would want to isolate the transformations of data from the objects is maybe subtle does anybody maybe have a thought of why you might want to split your data from the objects transforming the data so yeah so he said you dont know what data you have and um i think that thats uh thats a really good point and what that might mean is you do know what data you have right now but you dont know what data youre going to have so what what you can do with a function if youre if youre dealing with just a transformation you can extend that transformation in the face of a lot of different data without having to modify all the different definitions of that data so another reason that you might want to separate data and transforms is it makes it easier to write correct programs so a lot of the rest of this is going to be about program correctness and at least when i was in school learning about programming program correctness was almost an afterthought i felt like you know like there was maybe you maybe had like one proof class maybe had like just a little bit of talk about it and then the rest of time was hey go out and write there if your program does what its supposed to do its correct right like what else more do you need and i think that thats i think thats a pretty decent way of thinking about programming until you hit more complicated systems and more difficult problems and then suddenly it starts to fall apart and you really want to know that your program is going to be robust to varied inputs and is going to behave in an expected manner and i think that that more than anything is what functional programming allows you to have is are programs that behave how you would expect them to behave yeah so what do programmers seem to want so im going to answer that for me at least the thing i care most about are programs being correct obviously i need them to run fast but if i wanted just speed id be writing in c which ive done and didnt like so here i am writing programs in languages much slower than that um what you know what are some other things that you guys think that you know functional programmers like what do you care about or what do you find valuable yeah so he said transparency in your code and i think thats a really big big thing is being able not just to have a correct program but to make it so that everybody can tell that it is right like those two things are very important um so in fact like my next slide is this is all very going very well everybodys answers just lead me right into the next thing so thats awesome um yeah so like obviously functions make it easier to determine inputs and outputs thats actually in the definition of a function right so it should should at least be able to do that very well and in addition to that it makes it easy to see what your code is doing and i have an example coming up to show that so i say that functional programs make it easier to write correct code because it makes it easier to determine whats coming into your program whats going out of your program its easier to demonstrate that your program is correct either in the form of a proof or just casually just like walking someone through it because you have inputs and outputs it becomes much easier yeah jordan another reason is because the function does exactly what it does and its not touching much of other things [Music] oh yeah i i uh so so jordan jordan was saying that the the fact that functional programs tend to um they they tend to discourage side effects so when you write a functional program most functional programmers tend to write their code so that the inputs and outputs of their program are the only things that are going on so because of that you dont have to worry about some encapsulated state changing on you that you didnt know was going to change possibly by some other part of the program thats a huge thing and that that property of things not changing on you without you expecting it it allows the composability and allows so many of the nice properties of functional programming in fact i have a whole slide dedicated to composition so yeah so you know i think this really shows like people who do functional programming like were all wanting the same things like were all wanting our code to be easy to read easy to reason about and then the composition is really important because its no good to just have one small piece of a program easy to read and easy to reason about in fact id argue you can get that in just about any dynamic like you can always come up with a way of writing one piece of a code and make it so that people can follow it what becomes difficult is whenever you have multiple developers or complex systems and youre trying to compose those pieces together and still feel good that each piece independently and as a whole is correct i mean i i dont want to act like functional programming is a silver bullet to that problem i think that is the problem in uh computer software i would say functional program is a great tool to help with it um but if if you have a if you have a better idea for how to do it im im all ears but that i think is a very very powerful property of functions because youre mostly dealing with inputs and outputs where you dont have side effects you can compose sets of inputs two sets of outputs to develop more complicated behaviors so im going to do a very very simple example of proving a function so um raise your hand if you ever had to do any proofs in uh your c either cs courses or on your own yeah yeah so i see like four hands up which i mean i never i think i did in i think i had to do horror logic proofs in one class in a cs theory class let me tell you this isnt going to be that youre going to be very happy with this proof so its really silly so first we have we have several suits so we have clubs spades hearts and diamonds and then we have a color red and black and were going to write a program that tells you what color your suit is based on what suit it is so its input is going to be oh i have this backwards thats so bad uh this should say this should say suit so you cant prove your name is right it can only improve your structures right which i actually have a slide about but um yeah so suit and then the case of suit is going to either be a club a spade a heart or a diamond right there can be no other input because weve defined our input there can be no other output because weve defined our output so the proof is unbelievably easily easy right its just a proof by termination you just you just prove termination by exhaustion you have all your inputs you just simply work through every single input and then you have all your outputs that might seem like a little thing but i mean the fact that you have completely bound your input for that problem and then completely bound your output means you never have to worry about something like that being wrong you can imagine taking this and adding more complexity maybe its a club with a number and a spade with a string but in each case you can you can work through the same sort of idea and be very very sure that that part of your program is correct theres no way that side effects can happen theres nothing in here that can mutate something else and i made it a ridiculously simple example on purpose and there are you know plenty of examples where it does get just too hard to prove something but the fact that you can decompose the pieces where you can prove it you can decompose the uh program into pieces that you can prove and then just leave as a kernel the part thats really hard to prove and then write tests around that piece or monitoring that around that piece instead of having to consider all these other pieces and test through all those other pieces i think thats a really powerful and worthwhile technique but yeah so if youre looking for something more than this for the proof then there there isnt anything like i mean i could i could write like a qed i could write qed at the bottom i guess and then that would be in proof land for sure for real but thats what i want to say like when you know when functional programmers talk about proving things its i mean sometimes you know youre using things like structural induction and like complicated methods but i mean thats not that complicated but um but a lot of times its just this its the fact that you can actually read your inputs and outputs and because you can read your inputs and outputs you already know what the function does its a very its a very short argument if youre talking with another developer and you read through your inputs and your outputs and you guys all see what it does and usually you discover that somebody typed color instead of uh suit in your function yeah so um if youre not a functional programmer why might you care about these things um and this is kind of what i uh what i would go back to is like all programmers when theyre writing code have to decide when their program is correct the standard that you use to define that depends on the kind of code youre writing and you know the environment that youre writing a lot of times deadlines and schedules make it impossible for people to prove every single part of a program correct so you have to answer that question in some way or another and its good to have a good definition of that you should also know what parts of the program what parts of your system you dont know the answer to that question like what is correct behavior what is not correct behavior and thats surprisingly common too especially in microservice systems there are lots of microservices that are defined where parts of the system are just undefined like you dont you dont really have a good answer to what that behavior should be it happens the behavior happens but you know like why it happens is often left as an exercise for the user um and then i think another part of this is okay so you have your you have your business deadlines you have all that stuff but can you confidently say that over time the code that is in your system is getting better and not worse so as you add features and add pieces are the things that youre writing making your code base better do your refactors actually reduce bugs you know things like that i think that the answers in functional programming are all very solid for all these things especially the last one you know at our company we do a lot of a lot of fast development very fast development and i think its a huge benefit that we can then go back and iterate that the code that weve written and make it better each time and feel more and more confident in it yeah so i think a lot of the times the answers to the questions about how do you prove a program correct or cultural right so you write tests you use test test driven development you check for code coverage and i think those are great answers i think everybody should be doing that you know you definitely should what what i feel like is that we can have a little bit more but i do want to talk you know specifically i want to talk about ruby people because uh you know thats a community that ive never been involved with um but i listen to a lot of podcasts and one of the podcasts to listen to is a ruby podcast im always impressed with uh the way that they they talk about naming and they pay a lot of attention to the way you name things and the way you write your code i think a lot of that has to do with the fact that it is completely untyped and so much is changeable and so much is flexible in the ruby language so you have to be very careful about cultural things like you know naming conventions and testing conventions stuff like that um but i guess this is where the reason i want to bring this up was to talk about like why you might care about functional programming even if youre not going to be a functional programmer its like i find value in learning about other programming languages even though im you know i probably am never going to write any ruby code i never say never but ive never written any but um its still very interesting and i learn a lot learning about that language um yeah so i think that to write good systems you have to use everything that you can possibly use so great culture is important and you know managing complexity technically also is important and i think that the technical management of complexity is where functional programming really shines so thats that leads me into the next part of what i what i want to talk about which is what i want this to be i would like to see us take this meetup and turn it into a meetup where were talking about tools and techniques to write better code that are not sort of on the culture side that are more on the technical side um and especially ones that are outside of the mainstream so you know i think choosing an alternate programming language for this is definitely outside of the mainstream i think theater improvers would be outside of the mainstream some languages are kind of like right on the border like rust rust is becoming pretty mainstream so but its still really interesting and then fp adjacent subjects just like uh just like the core of functional programming our functions well once you introduce the idea of a function there are all these other concepts in mathematics that are related to functions logic type theory category theory and then linear logic thats a sub display of logic but i want to call out specifically because of rust and so um i would love for us to start doing some talks about each of these categories i know jordans done a few on category theory weve had a few of those id love to see um a type theory talk or if somebody is a rust rust expert id love to see a talk about that i think that would be a really interesting topic um and then other languages like ive mentioned rest a couple times but uh prologue and data log are two other ways of approaching this problem so they have a really a very different approach from functional programming in a lot of ways because you talk about outputs and then you let the computer determine the correct way of resolving those outputs resolving to capture those outputs but um its a different sort of transparency but again its about writing correct programs you know you you write a program where if you the only thing youre specifying is the output then you know you have the output so i think thats a really interesting property as well and then theorem provers ill probably have someone do a talk on tla plus weve weve started using it at our work and have been very happy with the results and its a way of specifying um specifying a program regardless of whether the programming language youre writing in has the tools to do that kind of specification so something i could see be very valuable if youre working say at like a data science shop and youre writing a lot of python you dont have some of the advanced type tools writing a specification can be really nice of course we we use haskell and i still find it incredibly valuable because you can then actually write a one-to-one mapping between tla plus and haskell but yeah and then also i i kind of like to try a few different kinds of talks you know this is great but you know if somebody doesnt feel like they want to come up here and stand and have everyone stare at them i can understand why it can be a little intimidating i know i feel a little intimidated when i do it id be glad to first of all come up with someone and just talk to them about their topic like if you want to do like an interview style thing or if you dont want me to talk to you because you dont like me which i also understand we can have a bring a buddy so you can have somebody else talk with you about it or if you want to do a group talk id love to see that show and tell is really nice too so if you have some super cool project that youve been working on you know that youre allowed to show or if youre not allowed to show and you dont care and you want to show it anyway i guess i dont care but yeah bring it up here and then show it off and well make sure we ask questions and you know we wont let you just swim and drown so yeah uh also solve a problem i i i think were going to do a couple talks where maybe we propose a problem and then look at different different ways of solving it in functional programming languages and other languages i think hopefully you know i dont intend to pick very complicated problems so its going to be like finding the you know i dont know the prime you know decomposition of a number or something like that or you know reading a string and finding all the fs in the string you know i dont because its hard to do anything more complicated than that in a talk but thats a great way of like say if we want to do a language comparison like maybe comparing a solution in oak camel to a solution in python i think that would be fun i actually wrote a couple of those that ill show after this but yeah and then im also open to any other suggestions about ways to do stuff but i i think that its really neat that we have something like this and id like to see it grow and become more more interesting so um theres a few more things after the thank you i got my slides out order there we go so ill come back to the thank you so uh yeah jordan right before this started he reminded me that maybe itd be useful to put some links to things and ill slack them in the in the channel but one really good resource for learning about goings-on in functional programming communities theres a haskell newsletter um i subscribe to thats the main way i learn about stuff that like summarizes whats going on in haskell and a lot of times well talk about other programming languages too and then if youre looking for something fun to do and youre looking for a functional programming product project theres this icfp con contest so thats uh i dont know ic whatever that stands for and then functional programming so so we do this contest at my work every year uh for i think four years now and oh yeah see i didnt want to say it because i was like maybe its french and so im not gonna just say that um international conference thats what jordan says it was i couldnt take i could have guessed that and then but the contests are really interesting so one year there was a uh you had to they gave you this they gave you these files for 3d printers like a magical 3d printer they made and you had to verify that you could build the build the object that they said that you could build i mean obviously its all just virtual but it was really neat another one was there was like you had to find the shortest path for a gondola going through venice and that was really interesting because you learn a lot about shortest path algorithms and how like you know thats a really hard algorithm i mean you probably already know that but you really feel it when you try and build something that has to run in under a minute so and its got 40 000 nodes to compute and it fails so uh one was we folded origami so like you had to you had to fold all these different shapes they gave you like a map and you had to try and fold that shape we managed to fold a piece of paper in half i called it half a gummy and thats as far as we got but i was pretty proud of that yeah so itd be really neat maybe we can maybe we can try and do one of that if everyones interested we could try and do some of that as a group and like not just be like like all isolated um all right ready thank you i got it in the right order now does anybody have any questions for me um okay uh so yeah so in your own workshop do you use utilize all the functional programming concepts in a production sure yeah uh so uh company i work for is plow and we um we use haskell for something like 90 of our backend code and then we use um reason now for something like 90 of our front end code so we have functional programming uh all the way up and down the stack we use a little bit of c for some stuff and we use nicks now for doing uh for doing uh builds and deployment so thats a functional uh programming environment for um sort of building configurations to deploy software were very were all in on the functional thing um you know for better for worse were all in okay so was that um was your first exposure to functional programming then through your current position or was this something that you sought out because plow was known for embracing those concepts yeah so so im one of the founders of plow and so we um we selected it because i liked it they were using they were using php and c-sharp and mysql and they were running the mysql on a windows server and it was um look i mean the programmer who did it before me i like him a lot hes a good guy i was just i didnt know those languages i knew lets see i knew haskell and lisp um scheme and c and the idea of developing a website in c sounded like the worst thing in the world um so i i decided i was going to rewrite it all in haskell and i did that um but i happy happy with that decision that was seven years ago so its been a while no further questions for me anybody else all right well thanks guys uh you know also i guess another thing is that if anybody has talks feel free to uh message me on slack or just message in the channel but i would really id really love a rest talk if anyones doing any reason id love a reason talk or haskell talk um really just anything we had an erlang talk a long time ago i feel like maybe its another time for another erlang talk so all right guys thats all i have thank you so much you 