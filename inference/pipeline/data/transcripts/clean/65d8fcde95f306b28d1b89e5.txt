but we are surrounded by CPUs, or processors, and the computing they do for us. They touch every aspect of our lives. CPUs are in your laptop, in the machines you use to check out at the grocery store, in the electronics that power the instruments in your car more efficiently. They enable our artists and scientists to create things that were unimaginable only yesterday. CPUs are everywhere and shape just about everything we do. Welcome to Architecture All Access CPU Architecture, Part One. Ive always been fascinated with computers since I was a kid, when I was first captivated by those revolutionary green screen computers at my elementary school, and a lot has changed since then. And over the last twenty three years, Ive had the privilege of working on some of the most well known chip designs in Intels history. From the architectural definition and design of the Pentium 4, to designing the Nehalem, Westmere, Haswell, Broadwell, and Tiger Lake processors and many more. Today I helped lead the development of Intels Client Engineering Teams, where I oversee the development of current and future products. Hi, my name is Boyd Phelps, and today I want to talk to you about CPUs, and more specifically about CPU architecture, its future, and the technologies involved in modern CPU design. As we do so, my hope is that you will gain not only a greater appreciation for what a CPU is, what it does, and how it does it, but that youll also be inspired about the possibilities of what lies ahead in the decades to come. And who knows, maybe some of you will even have a hand in shaping that future. There is so much innovation ahead of us in what is one of the most amazing industries on Earth. We divided the content into two modules: The first one focused on a brief history of CPU Computer Architecture, the concept of Computing Abstraction Layers, and the Instruction Set Architecture. Module Two will cover the building blocks of CPUs broken down into what we call Front End and Back End, as well as a Primer on Caching. Think of Module one as the Architecture Module, where we describe things at a high level. In Module Two is a micro architecture module for CPUs, where we begin to click down a bit into the details. Weve got a lot to cover, so lets get going. So what is a CPU? Well, C.P.U. Stands for Central Processing Unit, and its often called the brain of the computer. The CPU sits at the center of everything in the computer and handles all of the computation needed to turn inputs from memory, like a photo on your hard drive, into outputs on your peripherals, like an image on your monitor. CPUs are a general purpose, flexible architecture that take in a stream of instructions from all types of workloads and compute or process information based on those instructions. Simply put, CPUs do what we tell them or program them to do. CPUs are what run your operating system, the web browser that youre using right now to watch this video, your favorite photo or video editing application, your productivity software, conferencing applications, and much, much more. With the advances in silicon technology over time and our ability to continue miniaturizing transistors and make them more efficient, weve been able to pull more and more functionality onto the same piece of silicon that contains the CPU. This ability to continue shrinking transistors is based on a famous law or observation that we in the industry refer to as Moores Law. Moores Law is based on the observed trend showing that we can double the number of transistors per unit area about every two years. This simple law drives tremendous innovation, making what was once thought to be impossible not only possible, but also cheaper over time. Several decades ago, computers were a luxury of large institutions, whereas today computers in some form or fashion touch the lives of nearly everyone on Earth. When we look at a computer motherboard from 40 years ago like this one, what we see is we have numerous expansion card slots that have different functionalities. We have IO devices, we have memory, we have printer drivers, we have graphics cards, display drivers. And whats really impressive is when you take out one of these, look at the number of just discrete components that you have on this, we have here, and you can probably count them, there are well over 20, 30, or more discrete components on this. Whats impressive is all of this functionality today that existed in a PC you know of this size and this complexity now fits essentially in a microprocessor of this size. Yesterdays supercomputer that once filled a large room now easily fits on a chip inside your laptop. And weve only begun to scratch the surface of what is possible. The CPU, or brain, continues to be the center of it all. While there are other things like memory and IO controllers, display, media, and graphics engines, and other components in your system-on-chip processor, in this class well focus on the brain, the central processing unit, which continues to be what we call the spark of life in modern computer architecture. Since the focus of this class, again, is on how an individual CPU core works, when we say CPU or processor, well be referring to an individual core. But before we jump into modern CPU design, lets go back to where it all started. At the birth of digital computing, computers were fragile, slow, and large; and I mean gigantic. ENIAC, the first general purpose, digital computer from 1946, covered 1800 square feet, or the size of a modern home, and weighed about 30 tons. ENIAC, which stood for Electronic Numerical Integrator And Computer, and other earlier computers, were built using vacuum tube technology which made them huge and unreliable. These were program controlled computers, meaning that an operator programmed the computer with a set of switches and wires for each new calculation. These early computers were technically general purpose, but programming them was complicated and error prone, often taking weeks. Even so, they were on the cutting edge of technology in the late 1940s. As an aside, speaking of error prone programming, the term bug has been used as a part of engineering jargon long before the ENIAC, but it was used in an account by the famous computer pioneer Grace Hopper in 1946, in an interesting way. While working the MARK II and MARK III computers, operators traced an error on the MARK II to a moth trapped in a relay, recoining the term bug. The bug was carefully removed and taped to the logbook with the caption First actual case of a bug being found. Fun fact: The silicon die of a modern microprocessor is smaller than that bug. On a more serious note, the importance of the ease of programmability, along with an abstracted computer model to make computers simpler to program and use, is paramount and CPU design. In the late 1940s, prominent mathematician John von Neumann popularized a new kind of computer architecture that simplified computer design and programming. His idea for a stored program computer reimagined the general purpose computer as three separate systems: a bank of memory for storing data and instructions, a central processing unit for decoding and executing instructions, and a set of input and output interfaces. This von Neumann architecture separated units for processing information, the CPU, from units that stored information, the memory, and allowed data and instructions to be stored and addressed in memory in the same way. It also introduced the four step instruction cycle: fetching instructions from memory, decoding the instructions, executing the instructions, and storing the results back in memory. This architecture was so revolutionary that modern computers are still today based on these basic principles. In the 1950s, semiconductor based transistors started to hit the market, replacing the larger, more unreliable mechanical vacuum tube based technologies. This brought smaller and faster circuits to the electronics industry. Then, in 1959, Robert Noyce patented the first Monolithic Integrated Circuit, which combined multiple transistors on a single silicon chip. These early chips didnt have many transistors, but they enabled much smaller and more complex circuit designs. By 1968, several companies were making integrated circuits and Robert Noyce teamed up with colleague Gordon Moore to get into the game, founding Intel, which was short for Integrated Electronics. Intel quickly found a niche making memory chips, but in 1971 they unveiled the Intel 4004 single chip microprocessor for the calculator market. With a whopping 2300 transistors and a blazing fast clock speed of 740 kilohertz, it was the first general-purpose programmable processor and packed all of the computational power of the ENIAC into one tiny device. Engineers could now purchase a single component that could be customized with software for a variety of functions. In 1972, Intel released the first 8 bit microprocessor, the Intel 8008, but its successor, which released in 1974, known as the Intel 8080, was a real breakthrough. The Intel 8080 was a giant leap in CPU design, one of the worlds most widespread microprocessors. And when the 16 bit 8086 was released in 1978, the world would never be the same. The Intel 8086 with its x86 instruction set architecture became the foundation for modern CPU designs that we still use today. Here you can see a die picture of the 4004 microprocessor, and here is the 11th Gen Intel core processor named Tiger Lake. You might look at both these die pictures side by side and think that the physical size is not that dramatic, but consider this: The 4004 CPU had 2300 transistors, while the Tiger Lake processor actually packs in billions and billions of transistors. In fact, I would have to have about 4 to 5 million of these chips to have the same number of transistors as Tiger Lake. Whats even more remarkable is that the 4004 took a team of engineers to design, whereas today, due to the power of computing abstraction, a single engineer handles millions of transistors. There are a couple of concepts that are key to understand with regards to computer architecture. First is the notion and use of the binary system. And second is that concept of computing abstraction layers I was just mentioning. Digital computers use a number system based on zeros and ones rather than the decimal system that most people are familiar with. For computers to function, its critical that we represent all control and data and numbers in simple on or off states. It turns out that the characters and numbers humans use to communicate with can be easily translated into a binary based system of numbers or encodings like the popular ASCII representation for characters of the alphabet. There is great power in what the binary system allows us to do. By representing data as a series of ON or OFF states in a computer or memory, we can simplify and create a foundation for computer engineers to do much more complicated tasks. The second concept is that of computational abstraction layers, and how you can start with very simple things like atoms and transistors and add abstraction layer, to abstraction layer to build things up to complex applications that run in large data centers. In general, the abstraction layers that make up computing are well understood, and building from one layer to the next allows us to build complex computing structures from the bottom up that would be almost impossible to visualize from the top down. Allow me to explain. At the foundation of the computing abstraction layers, you have atoms which get put together in materials like silicon from which we build tiny transistors. These transistors act as switches that turn on or off with the application of an electrical current or voltage signal. By connecting switches together in specific arrangements, we can form what we call the fundamental boolean logic operators for performing calculations: AND, OR, and NOT. For example, one switch by itself can convert a 1 to a 0, and on its output it is called a NOT or an inverting operator, and two switches arranged in series form an AND operator. If we wire switches in parallel with each other, we get the OR operator at the output. These arrangements of switches are known as logic gates, so we can now organize, or abstract, ones and zeros to a language of logic that is more efficient to understand than the language of physics and the flow of electrons. Using transistors as switches and connecting the output of one to the input of another, we can build a variety of logic circuits, or functional blocks. These functional blocks can take the form of Adders, Multiplexers, Decoders, Latches, Flipflops, Registers, Counters, the list goes on and on. The power of abstraction is incredible. And as you might expect, chaining functional blocks together allows for even more complex logical functions. With them we can build custom execution units that perform specific calculations. For example, one of the most important execution units in a CPU is the Arithmetic Logic Unit, or ALU. Designing a whole CPU comes down to building multiple specialized processing elements and connecting them together in ways that allow complex computations to be done. The combination of those processing elements into a design that can fetch instructions from memory, decode the instructions, execute those instructions, and store the results back in memory is what we call a Microarchitecture, or the instantiation of an architecture implemented in hardware. John von Neumann would be proud. So how do we get from hardware to software? With yet another abstraction layer, of course. The Instruction Set Architecture, or ISA, is a set of instructions that defines what kinds of operations can be performed in hardware. It is nothing more than the language of the computer. Much like English or Spanish are languages, most languages have dictionaries that describe the words, the format, grammatical syntax and meanings to those who communicate in those languages. An ISA is an abstract model of the computer, sometimes also referred to as Architecture or Computer Architecture. The ISA describes the memory model, supported data types, registers, and behavior of machine code - the sequences of zeros and ones that the CPU must execute. You may have heard of several types of ISAs like x86, ARM or MIPS. The ISA acts like a sort of bridge between software and hardware. On the software side, a compiler uses the ISA to transform code written in a high level language like C, Perl, or Java into machine code instructions, or language, that the CPU can process. The ISA is the dictionary of instructions, data types, and the formats that the CPU adhering to that ISA must execute. This means the application programmer can usually ignore the ISA and focus on what the programming language provides. On the hardware side, when a CPU microarchitecture is being designed, the ISA is used as a design spec that tells the engineer what operations it needs to execute. Because of this layer of abstraction, the instructions in the ISA are implementation independent. This means that even if a different company creates different micro architecture designs, they can all run the same code based on the same ISA. Computer architects continue to evolve ISAs through extensions to the instruction set, much like new words are often added to dictionaries. These additional instructions are often created to perform certain operations more efficiently, leveraging new processing elements in their microarchitecture. These ISA extensions can increase a CPUs performance by streamlining operations for a particular arrangement of processing elements. Modern CPUs support thousands of different instructions, but many of them are related to arithmetic operations like Addition, Subtraction, Multiplication, logical operations like AND, OR, NOT, memory operations like Loading, Storing, Moving, and flow control like Branching. Well explain what branching is later. In general, instructions consist of an opcode, which is the operand to be performed, like ADD, and a number of operands, the data to be operated on, like add A in Register X to B in memory location Y. ISA instructions often also include additional bits of data that give the CPU more information relevant to the operation, which the CPU uses to decode and execute the instruction in an efficient way according to its microarchitecture. Of course, this is a highly simplified description of instruction set architectures, and its important to realize that modern ISAs are much more complex than we could hope to explain in this short video. ISAs are one of the most critical parts of modern CPU design, as they are the linchpin between software and hardware that allows efficient, high performance computation, and seamless software experiences across a variety of CPU microarchitectures. In part two of this series, well go into the details of the microarchitecture, the specifics of the instruction cycle, and the different parts and functions of the front and back end of a CPU, as well as a primer on caching. Stay tuned. 