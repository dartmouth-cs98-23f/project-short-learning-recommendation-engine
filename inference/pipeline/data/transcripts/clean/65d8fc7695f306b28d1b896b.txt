youtube channel and in this session we will be discussing the tree data structure before we begin let me tell you guys that we have daily updates on multiple technologies if you are a tech geek in a continuous hunt for latest technological trends then consider getting subscribed to our youtube channel and dont forget to hit that bell icon to never miss an update from simply learn now without further ado lets get started with the agenda for todays discussion so we will be discussing what exactly is a tree data structure followed by that we will understand why we need a tree data structure then we will learn the tree terminologies followed by that we will understand tree node then we will see the types of trees and followed by that we will understand the tree traversal and finally we will see some applications of trees in real time i hope i made myself clear with the agenda now lets get started with the first topic that is what is a tree data structure so what exactly is a tree data structure the tree is a non-linear data structure that consists of nodes and is connected by edges i know its a little difficult to understand just by the definition so let me show you the pictorial representation as you can see we have the elements that is 10 20 30 40 50 60 and 70 and all these are stored in the tree data structure they are stored in a non-linear structure if we had used arrays it would have been in a linear consecutive way where 10 starts first and 70 ends at the last position now in the next section we will discuss why we had made to a switch to the tree data structure when we already had a linear data structure that is airy now the next topic that is why we need tree data structure so there are many reasons why we had switched into tree data structure and one of the reason is a linear data structure always stores the elements in a sequential form that is one after the other and in operations to be performed in linear data structure that time complexity increases as the data size increases you can see here that as discussed before the elements are stored in a linear form that is 10 at the first place and 70 at the last place imagine you wanted to access the element 70 then using the traversal you had to start from the first position that is 10 20 30 40 and slowly at the end is 70. so accessing that particular element is really time consuming we are facing this just for 70 elements imagine if we had 700 elements right so that is exactly why we had made a switch to tree data structure and using trade data structure we have many advantages as the tree data structure is completely non-linear and it allows easier access and quicker access of the data elements how is that possible we will look into it into the next segment where we will discuss about the traversal of trees now before we understand the traversal of trees we should understand another important topic that has the terminologies of tree so the first one is the node node is the entity that contains the keys and pointer to its child nodes so here you can see that the elements a b c d e f and g are the elements so each and every element or the blue dot is called as a node and the blue dots here are one two three four five six and seven so we have seven blue dots so we have seven elements here so you can see the line between each elements right so this particular line is called edge now well discuss about the edge in the next part so the connecting links between any two nodes are called as edges so we discussed about the nodes right where the element is stored the blue dots are the nodes and the lines connecting between the elements or nodes is called as the edge so out of all the nodes this first node that is the element a is called as the root node in a tree data structure so indirectly root node is also called as the parent node of all the nodes now we will understand what are parent nodes and children nodes so in a tree data structure the node that is the nodes predecessor is called as parent node so here we have discussed that a or the root node is the parent of all nodes so for a b and c nodes are children nodes and for b and c nodes a happens to be the parent node similarly d and e are the children nodes of b and f and j are children nodes of c and the nodes d and e have b as the parent node and the nodes f and g have c as the parent node now followed by that we will understand the descendant node so as discussed before the descendant node is the node that comes after the parent node here the b and c are the descendants of a and d and e are descendants of b and similarly f and g are the descendants or children of the node c so in a tree data structure the node which does not have any child is called as the leaf node now at the end we have d e f and g so these particular nodes do not have any children nodes like b and c so these particular four nodes which do not have any children are called as the leaf nodes in a tree data structure the node with at least one child node is called as the internal node so here the internal nodes are p and c which have at least one child in a tree the total number of children of a node are called as the degree of that node so in this particular diagram the degree of root node is 2 because it has two child nodes and the degree of b is 2 as it has two child nodes similarly the degree of c is 2 because it has two child nodes but when it comes to d e f and g the degree is 0 because they do not have any child nodes in a tree data structure the root node is said to be at level 0 and the children of the root node are said to be at level 1 and the children nodes of the level 1 are at level 2. so to understand this lets go through the diagram as you can see this particular root node is called as level 0 and followed by that we have the children nodes of a that is b and c and that level is called as level 1 and followed by that we have level 2 and if this tree goes forward the levels also increase accordingly now in a tree data structure the total number of edges from a leaf node to the particular node is the longest path and this particular path is called as the height of that node now here we have our general tree data structure and here you can see the height of node a s2 and the height of node b and c together is at 1 and the height of the last leaf nodes happens to be 0. next in the tree data structure the total number of edges from the root node to a particular node is called as the depth of that node now in this particular tree data structure the depth of the root node is zero and the depth of b and c together is one because the number of edges connecting to the node a from b is just one and similarly the number of edges connecting the node c from a is just one so the depth of both b and c is one now if we consider the last leaf nodes then the depth is two because if you see g is connected to a using two different edges similarly f is connected to a using two different edges and e and d also have two nodes to connect to a so the depth is two now in the next segment we will understand the tree node so the tree data structure has data part and references to its left and right child node in the tree data structure so here you can see this is the node and the node has three segments that is data element and the references to its left child and the references to its right child now there are four different types of trees the first one is the binary tree followed by that we have the binary search tree then we have avl tree and finally we have the b3 let us discuss each one of them the first one is the binary tree a binary tree is a tree data structure in which each parent node at most has two children so in this particular tree well have at most two children that means it might have one or more than one but not more than two children per node moving ahead we have the binary search tree so a binary search tree or a bst is a tree data structure in which each node has a maximum of two children all nodes of the left sub tree are less than the right node all nodes on the right sub tree are more than the root node so here you can see the image or the gif which represents the image of a binary search tree so here all the nodes of the left sub tree are less than the root node and all the nodes of the right subtree are more than the root node the next type of the tree is the avl tree the avl tree got its name after inventory georgie adelson welsky and landis avl tree is the self-balancing tree in which each node maintains a balanced factor both value is either one zero or minus one balance factor is equals to height of the left subtree minus height of the right subtree or height of the right subtree minus height of the left subtree so in this particular image you can identify it is an avl tree and now the last type of tree that is the b tree b3 is a special kind of self balancing search tree in which each node can contain more than one key and can have more than two children b3 is also known as the height balanced m v tree now in this particular gif we can see how a b3 looks like now followed by this we will discuss the tree traversal so traversing a tree helps to visit required node in the tree to perform specific operations tree traversal can be performed in three different ways the first one is the pre-order traversal where we visit the node and visit all the node from the left side then visit all the nodes from the right side so this particular gif is an example for pre-order traversal where we visit all the left side nodes first then we visit the right side nodes now we will move ahead into the next type of traversal that is the in order traversal first we visit all the nodes from the left side then we visit the root node and then represent all the nodes from the right side so this particular gif will be an example for the in order traversal where we visit all the left side nodes then we visit the root node and followed by that we will visit the right side nodes and the last type of traversal is the post order traversal where we visit all the nodes from the left side first then we visit all the nodes from the right side and finally visit the root node so this particular image on the right side is an example for post order traversal now before we get into learning the applications of trees we will try to execute one example based on the post order pre-order and in order traversals entry data structure so you can see that we have an example on my screen right now so here we have the node structure then we have the in order traversal function followed by that we have the pre-order traversal function and finally we have the post order traversal function now lets quickly run this program and see the output and dont worry about the code this particular code document will be attached in the description box below and you can have access to it now we have the run option over here and the program got successfully executed uh you can ignore this warning and here we have the in order traversal of the tree and the first output then we have the pre-order traversal of the tree and finally we have the post-order traversal of the tree now lets discuss the last part where we will learn the application of trees so the application of trees are as follows binary search trees are used to quickly check whether an element is present in the set or not then we have the most popular database usage of b3 which is a variant of tree data structure then we have the modified version of trees called as trice which is used in the router to store routing information and finally the compiler uses a syntax tree to validate the syntax of every program you write so with that we have come to an end of this tutorial on tree data structure if you have any queries regarding the topics covered in this particular tutorial then please feel free to let us know in the comment section below and our team of experts will be happy to resolve all your queries until next time thank you stay safe and keep learning hi there if you like this video subscribe to the simply learn youtube channel and click here to watch similar videos to nerd up and get certified click here 