exciting chapter of digital design and computer architecture in this chapter the whole course is going to come together so in the first part of the course we began with zero and one and worked our way up to logic design to being able to design things like alus memories and multiplexers then we jumped up to the high level we looked at software and worked our way down to computer architecture the native instructions run by the computer and now were going to meet in the middle to connect these two threads in topic of micro architecture were going to look at how to put together hardware blocks to actually build a microprocessor so well use all the components we developed in logic and connect them together in a way that we can run the machine language instructions of our risk risk microprocessor so as we look at a processor one of the key issues will be how fast it is so well talk about performance analysis then well look at three different possible implementations three different micro architectures or a risk five processor the first one is a single cycle processor where all the work takes place in one clock cycle because of this the clock cycle has to be long enough to accommodate the most complicated instruction next well look at a multi-cycle processor where we break up the instruction into multiple simpler steps and that will allow each step to run faster and also allow us to reuse some hardware and well compare how that performance shapes up against a single cycle processor finally well look at the pipeline processor earlier wed talked about a pipelining example of doing laundry and in the same way we can overlap the execution of various instructions to make them run a lot faster so all modern processors where performance matters are pipelined finally well survey some of the advanced micro architecture techniques used in current processors so as we said microarchitecture is the way you implement the architecture and hardware the architecture is the programmers view of the machine and the micro architecture is the hardware designers view so well take our processor and divide it into a data path and a controller the data path has the functional blocks that work on words of themes words of data and the controller is going to make control signals to tell the data path to do the right things at the right time as i mentioned well look at three different implementations three different microarchitectures of the same architecture all of them will do the same thing theyll all be risk 5 processors but theyll have different trade-offs among how fast they work and how much hardware they take so to measure speed we look at the program execution time the ultimate measure of how fast the processor is is how long it takes to run a program of interest to us and that execution time is the number of instructions in the program times the average number of clock cycles needed for each instruction times the number of seconds in a clock cycle so lets define cpi to be the cycles per instruction the clock period also known as tc is the number of seconds in a clock cycle and sometimes well look at ipc instructions per cycle thats the reciprocal the cycles per instruction and our challenge is to satisfy some constraints of cost power and performance or get the best performance we can under cost or power constraints as were building this processor to keep things tractable lets consider a subset of the most interesting risk five instructions well look at the r-type instructions add subtract and or set lesson well look at the memory instructions load word and store word the branch instruction beq and well build up a processor that handles these later on well look at how to add other instructions such as had eye or jump and link but once you get the fundamental ones the rest are very similar so the next important notion on microarchitecture is the architectural state the architectural state determines everything that you need to know what a processor is doing so if you took a processor and well in science fiction movie imagine taking somebody and freezing their brain and then 100 years later reimplanting it in a body and warming it back up and the person is there again we could do the same thing of freezing the brain of our processor if we record the architectural state then we could even turn off the power to the computer eventually we turn it back on and if we restore the architectural state the processor will keep going just as it was before so in the risc 5 processor the architectural state we need are the contents of the 32 registers the value for program counter and the contents of the memory if we restore those registers and restore what was in memory and then put the program counter back where it was the program will continue running just as it had so any implementation a risk five processor needs to have that architectural state heres the program counter here is the register file with 32 registers and the memory we may break up into an instruction memory and a data memory to separately hold those two parts of the program in the data so in the upcoming sections we will connect this architectural state together with things like arithmetic logic units to do operations on the registers and multiplexers to select the desired result and put that together to build our data path and then well make a controller that asserts the control signals to the data path at the right time 