effectiveness of an algorithm while we know there is more than one way to solve the problem in programming knowing how the algorithm works efficiently can add value to the way we do programming to find the programs effectiveness or algorithm knowing how to evaluate them using time complexity can make the program behave in required optimal conditions doing so makes us an efficient programmer on that note hey everyone i am abou khandelwal and i welcome you all to yet another exciting video from simply learn in this session we will be discussing time complexity analysis however before we begin the session make sure you have subscribed to our youtube channel and click down the bell icon below so you never miss an update from simplyland so now lets look at the agenda for the todays topic we shall begin our session by introducing time complexity then we will discuss the types of time complexity and then we will discuss all the steps to evaluate the time complexity then we will briefly look at the time complexity of various algorithm finally we will sum up what we have learnt from this session so without any further ado lets get started with the first topic of this session introduction to time complexity the time complexity of an algorithm is the amount of time it takes to run as a function of the length of that input the length of the input determines how many operation the algorithm will do it will provide the information about the variance increase or decrease in execution time as the number of operations in an algorithm increases or decreases next up types of time complexity we will start with the constant time complexity then we will discuss linear logarithmic quadratic time complexity now lets have a look at them in the detail first constant time complexity when an algorithm is not reliant on the input size n it is set to have constant time of order big of 1 the runtime will always be the same regardless of the input as you can see in the code every line has the runtime of 1 and they are all independent of any input size so the runtime is always constant next up linear time complexity when an algorithms running time increases linearly with the length of in the input it is said to have linear time complexity when a function checks all the values in an input data set it is said to have the time complexity of order of big o of n as you can see in the code the loop depends on the size n so the time complexity rose up to n next up logarithmic time complexity when an algorithm lowers the input data in each step then it is said to have the logarithmic time complexity binary trees or binary search functions are some of the algorithms with logarithmic time complexity as you can see in this code by finding out the mid in every iteration the runtime will decrease every step making it approximately logarithmic runtime next up quadratic time complexity when the execution time of algorithm rises nonlinearly up to n square with the length of the input it is said to have quadratic time complexity in general net nested loops falls into the quadratic time complexity order where one loop takes big o of n and if the function contains the loop inside the loop then it multiplies as you can see in this code because of the nested loops the time complexity rose to n square now that you have the firm grasp of time complexity and its type we will discuss essential steps to evaluate the time complexity to understand this we will take an example of fibonacci number this code prints the fibonacci numbers till n we will divide this code into three parts isolating all the loops that play a significant role in altering the time complexity lets look at the first part it consists of some independent statement which gave constraint time for each statement next lets move it on to our next part that is for loop since this loop runs n times this will give linear time complexity on n next up the third part which also has the constant time complexity now lets take a total of runtime which comes out to be n plus 5 we will then discard the constant part to find the time complexity which does not affect the overall time complexity now we will have the final time complexity of bigger of n we have now discussed time complexity and how to evaluate it now lets have a look at the time complexity of various algorithm we will look at the time complexity of insertion sort merge sort quick sort bubble sort and some searching algorithms like linear search and binary search lets look at them in the detail first up insertion sort as you can see in this code we are using nested loops so in worst case its complexity comes out to be n square now in the best case scenario the complexity will be linear time complexity next up merge sort in this case whether it is the worst case or the best case it will always remain and login as every statement in this code will run the same amount so no matter what its time complexity will remain the same next up quick sort the time complexity of quick sort in the best case is n login and and in the worst case it is answer next up bubble sort as you can see in this code we are using nested loops so in the worst case its complexity comes out to be n square now in the best case scenario the time complexity will become the linear time complexity that is n and after that we will discuss some of the searching algorithms first up linear search in the best case scenario if the statement to be searched is at the first position then the time complexity will come out to be constant whereas in the worst case the time complexity will come out to be n finally binary search in the best case scenario if the element is to be searched is at the mid then the time complexity will come out to be the constant whereas in the first case scenario the time complexity will come out to be big of log n we have now discussed the time complexity and how to evaluate and the time complexity of various algorithm now lets sum up what we have learned from this session first up the execution time increases with the types of operations we make using the inputs next up the lesser the time complexity the faster is the execution finally if a code is of hundreds of lines then it takes a toll on the pcs processor so it is essential to check and reduce the time complexity as much as we can and this was all for todays session hope you guys found it informative and helpful if you liked this session then like share and subscribe if you have any question then you can drop them in the comment section below thanks for watching and stay tuned for more from simply learn hi there if you like this video subscribe to the simply learn youtube channel and click here to watch similar videos to nerd up and get certified click here 