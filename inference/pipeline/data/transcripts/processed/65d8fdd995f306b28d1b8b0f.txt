provided under a creative commons license your support will help mit opencourseware continue to offer high quality educational resources for free to make a donation or view additional materials from hundreds of mit courses visit mit opencourseware at ocwmitedu professor all right everyone lets get started so todays lecture and wednesdays lecture were going to talk about this thing called object oriented programming and if you havent programmed before i think this is a fairly tough concept to grasp but hopefully with many many examples and just by looking at the code available from lectures youll hopefully get the hang of it quickly so lets talk a little bit about objects and weve seen objects in python so far objects are basically data in python so every object that weve seen has a certain type ok that we know behind the scenes though every object has these two additional things one is some data representation so how python represents the object just behind the scenes and what are different ways that you can interact with the object so for example every one of these is a different object for example this is the number 1234 its a specific object that is of type integer the number 5 is a different object thats of type integer and so on weve seen floats weve seen strings weve seen lists lists and dictionaries are more complicated objects object types sorry but every object has a type some sort of way that its represented in python and some ways that we can interact with them ok so the idea behind object oriented programming is first of all everything in python is an object weve said that before and in this lecture i think well really get at what that means so weve seen strings integers dictionaries lists those are all objects when we did functions we saw that we could pass as a parameter another function so functions were also objects in python so literally everything in python is an object so what are the kinds of things we can do with objects well once you have a type you can create a new object that is of some type and you can create as many objects as youd like of that particular type right an integer 5 and integer 7 those all work in a program once youve created these new objects you can manipulate them so for a list for example you can append an item to the end of the list you can delete an item remove it concatenate two lists together so thats ways that you can interact with objects and the last thing you can do is you can destroy them so and with lists we saw explicitly that you can delete elements from a list or you can just forget about them by reassigning a variable to another value and then at some point python will collect all of these dead objects and reclaim the memory so lets continue exploring what objects are so lets say i have these two separate objects one is a blue car one is a pink car so objects are really data abstractions so these two cars can be created by the same blueprint ok this is a blueprint for a car and if an object is a data abstraction theres two things that this abstraction is going to capture the first is some sort of representation what is going to represent the car what data represents a car object and the second is what are ways that we can interact with the object so if we think about a car blueprint some general representation for a car could be the number of wheels it has the number of doors it has maybe its length maybe its height so this is all part of what data represents the car ok the interface for the car is what are ways that you can interact with it so for example you could paint a car right so you could change its color you could have the car make a noise and different cars might make different noises or you can drive the car right so these are all ways that you can interact with the car whereas the representation are what makes up the car what data abstractions make up the car lets bring it a little closer to home by looking at a list so we have this data type of list right weve worked with lists before the list with elements 1 2 3 and 4 is a very specific object that is of type list again we think about it in terms of two things one is what is the data representation of the list so behind the scenes how does python see lists and the second is how do you interact with lists so what are ways that you can manipulate a list object once its created so behind the scenes you have a list l which is going to be made up of essentially two things one is going to be the value at specific index ok so at index 0 it has the value 1 right because its the first element in the list and the second thing that represents a list is going to be this second part which is a pointer and internally this pointer is going to tell python where is the memory location in the computer where you can access the element index 1 so its just essentially going to be a chain going from one index to the other and at the next memory location you have the value at index 1 and then you have another pointer that takes you to the location in memory where the index 2 is located and in index 2 you have the value and then the next pointer and so on and so on so this is how python internally represents a list ok how you manipulate lists weve done this a lot right you can index into a list you can add two lists together you can get the length you can append to the end of a list you can sort a list reverse a list and so many other things right so these are all ways that you can interact with the list object as soon as youve created it so notice both of these the internal representation and how you manipulate lists you dont actually know internally how these are represented right how did whoever wrote the list class decide to implement a sort we dont know you also werent aware of how these lists were represented internally and you didnt need to know that thats the beauty of object oriented programming and having these data abstractions the representations are private of these objects and they are only known by what you can find out how its done but they only should be known by whoever implemented them you as someone who uses this class doesnt really need to know how a list is represented internally in order to be able to use it and to write cool programs with them ok so just find a motivation here before we start writing our own types of objects is the advantages of object oriented programming is really that youre able to bundle this data bundle some internal representation and some ways to interact with a program into these packages and with these packages you can create objects and all of these objects are going to behave the exact same way theyre going to have the same internal representation and the same way that you can interact with them and ultimately this is going to contribute to the decomposition and abstraction ideas that we talked about when we talked about functions and that means that youre going to be able to write code thats a lot more reusable and a lot easier to read in the future ok so just like when we talked about functions were going to sort of separate the code that we talk about today into code where you implement a data type and code where you use an object that you create ok so remember when we talked about functions you were thinking about it in terms of writing a function so you had to worry about the details of how you implement a function and then you had to worry about just how to use a function right so its sort of the same idea today so when youre thinking about implementing your own data type you do that with this thing called a class and when you create a class youre basically going to figure out what name you want to give your class and youre going to find some attributes and attributes are going to be the data representation and ways that you can interact with your object so you as the programmer of this class are going to decide how you want people to interact with the object and what data this object is going to have so for example someone wrote code that implements a list class right and we dont actually know how that was done but we can find out so creating the class is implementing the class and figuring out data representation and ways to interact with the class once thats done you can then use your class and you use the class by creating new instances of the class so when you create a new instance you essentially create a new object that has the type the name of your class and you can create as many objects as youd like you can do all the operations that youve defined on the class so for example someone wrote the code to implement list class and then you can just use the list class like this you can create a new list you can get the length pf the list you can append to the end of the list and so on and so on so lets start defining our own types ok so now youre going to define classes youre going to write classes which are going to define your own types of objects so for todays lecture were going to look at code thats going to be in the context of a coordinate object and a coordinate object is essentially going to be an object thats going to define a point in an xy plane so x y is going to be a coordinate in a 2d plane so were going to write code thats going to allow us to define that kind of object so the way we do that is we have to define a class so we have to tell python hey im defining my own object type so you do that with this class key word so you say class then you say the name of your type in this case were creating a type called coordinate just like we had type list type string and so on this is going to be a type called coordinate and then in parentheses here you put what the parents of the class are for todays lecture the parent of the classes are going to be this thing called object and object is the very basic type in python it is the most basic type in python and it implements things like being able to assign variables so really really basic operations that you can do with objects so your coordinate is therefore going to be an object in python all right so weve told python we wanted to define an object so inside the class definition were going to put attributes so what are attributes attributes are going to be data and procedures that belong to the class ok data are going to be the data representations and procedures are going to be ways that we can interact with the object the fact that they belong to the class means that the data and the procedures that we write are only going to work with an object of this type ok if you try to use any of the data or the procedures with an object of a different type youre going to get an error because these data and these attributes will belong to this particular class so the data attributes is what is the object right what is the data that makes up the object so for our coordinate example its going to be the x and y values for coordinate we can decide that can be ints we can decide that we can let them be floats but its going to have one value for the xcoordinate and one value for the ycoordinate so those are data attributes and procedure attributes are better known as methods and you can think of a method as a function except that its a function that only works with this particular type of object so with a coordinate object in this case so the methods are going to define how you can interact with the object so in a list for example weve said that you can append an item to the end of the list we can sort a list things like that so when youre defining methods youre defining ways that people can interact with your object so for example for a coordinate object we can say that we can take the distance between two coordinate points ok and thats going to be a way that you can interact with two coordinate points and just to be clear these are going to belong to this class which means that if you try to use this distance method on two lists for example youre going to get an error because this distance method was only defined to work with two coordinate type objects all right so lets carry on and continue implementing our class so weve written this first line so far class coordinate object so now lets define attributes first thing were going to define are data attributes generally you define data attributes inside this init and this is underscore underscore init underscore underscore and its a special method or function in a class and the special method tells python when you implement the special method it tells python when you first create an object of this type call this method or call this function so how do we do that so lets implement it so we say df because its just a function the name is the special name init and we give it some parameters right just like any other function these last two parameters are x and y which are going to represent how you create a coordinate object so you give it a value for the xcoordinate and you give it a value for the ycoordinate the self however is a little bit trickier so the self is going to be a parameter when you define this class that represents a particular instance of the class so were defining this coordinate object in sort of a general way right we dont have a specific instance yet because we havent created an object yet but this self is going to be sort of a placeholder for any sort of instance when you create the object so in the definition of the class whenever you want to refer to attributes that belong to an instance you have to use self dot so this dot notation and the dot is going to say look for a data attribute x that belongs to this class so for methods that belong to the class the first parameter is always going to be self it can be named anything you want but really by convention its always named self so try to stick to that and then any other parameters beyond it are going to be just parameters as you would put in a normal function ok in this particular case were going to choose to initialize a coordinate object by two values one for the x and one for the y and inside this init method were going to have two assignments the first one says the x data attribute of a coordinate object im going to assign it to whatever was passed in and the y data attribute for a particular object is going to be assigned whatever y was passed in questions so far about how to write this init yeah question audience inaudible professor how do you make sure that x and y are inits or floats so this is something that you could write in the specifications so the docstring with the triple quotes so whoever uses the class would then know that if they do something outside the specification the code might not work as expected or you could put in a cert statement inside the definition of the init just to sort of force that force that to be true great question yeah question audience inaudible professor does the x does this self x and this x have to be the same name the answer is no and were going to see in class exercise that you can have it be different ok great so this defines the way that we create an object so now we have sort of a nice class its very simple but we can start actually creating coordinate objects so when you create coordinate objects youre creating instances of the class so this line here c is equal to coordinate 34 is going to call the init method its going to call the init method with x is equal to 3 and y is equal to 4 im just going to go over here and i wrote this previously because notice when were creating an object here were only giving it two parameters but in the init method we have actually three parameters right we have these three parameters here but when were creating an object we only give it two parameters and thats ok because implicitly python is going to say self is going to be this object c so just by default ok so when youre creating a coordinate object youre passing it all the variables except for self so this line here is going to call the init and its going to do every line inside the init so its going to create an x data attribute for c a y data attribute for c and its going to assign 3 and 4 to those respectively this next line here is origin equals coordinate 0 0 creates another object ok its another coordinate object whose value for x is 0 and whose value for y is 0 so now we have two coordinate objects we can access the data attributes using this dot notation and weve seen that before right when weve worked with lists wed say something like l dot append right when we create a list so the same dot notation can be used with your own objects in order to access data attributes so here this is going to print 3 because the x value for object c is 3 and the next line print origin x is going to print 0 because the x value for the object origin is 0 ok so weve created a coordinate object we have to find the init method so we have a way to create objects when we use the class and then we can access the data attributes but thats kind of lame right because there isnt anything cool we can do with it there isnt ways to interact with this object so lets add some methods remember methods are going to be procedural attributes that allow us to interact with our object methods are like functions except that theres a couple of differences which youll see in a moment and when youre calling methods youre using the dot operator like l dot append for example for lists so lets go back to defining our coordinate class and lets define a method for it so so far weve defined that part there class coordinate and an init so we have that so in this slide were going to add this method here so this method here is going to say im going to define a method called distance and im going to pass in two parameters remember self the first parameter is always going to be the instance of an object that youre going to perform the operation on so pretty much by convention its always named self and then for this particular method im going to give it another parameter and i can name this whatever i want im naming it other and this is going to represent the other coordinate object for which i want to find the distance from my self so here im going to just implement the euclidean distance formula which is x1 minus x2 squared plus y1 minus y2 squared and square root of all that so thats what im doing inside here self and other are coordinate objects inside this method i have to refer to the x data attributes of each object if i want to find the difference between the 2x values from them so thats why im doing self dot x here right if i just did x i would be accessing just some variable named x in a program which actually isnt even defined so you always have to refer when as were thinking about classes you always have to refer to whose data attribute do you want to access in this case i want to access the x data attribute of my self and i want to subtract the x data attribute of this other coordinate square that same for y square that and then add those and take the square root of that so notice this method is pretty much like a function right you have df some name it takes in parameters it does some stuff and then it returns a value the only difference is the fact that you have a self here as the first thing and the fact that you always have to be conscious about whose data attributes youre accessing so you have to use the dot notation in order to decide whose data attributes you want access so weve defined the method here distance so this is in the class definition now how do we use it so lets assume that the definition of distance is up here i didnt include the code but really all you need to know is what it takes it takes a self and an other so when you want to use this method to figure out a distance between two coordinate objects this is how you do it so the first line i create one coordinate object second line i create another coordinate object first one is named c the second one is named 0 these are two separate objects and im going to find the distance and i want to first call it on one object so im going to say c dot so im using the dot notation to call the method distance on object c so python says this object c is of type coordinate its going to look up at the class coordinate that you defined its going to find this method called distance and then its going to say what parameters does it take so it takes another parameter right for the other and then in the parentheses i just have to give it this other perimeter an easier way to see what happens is by looking at what this line here is equivalent to so the third line here prints c dot distance 0 is equivalent to this one on the right and this one on the right essentially says whats the name of the class dot dot notation whats the method you want to call and then in parentheses you give it all of the variables including self ok so in this case youre explicitly telling python that self is c and other is 0 so this is a little bit easier to understand like that but its a little cumbersome because you always have to write coordinate dot coordinate dot coordinate dot for every data attribute you might want to access for every procedural attribute you might want to access so by convention its a lot easier to do the one on the left and as i mentioned python implicitly says if youre doing the one on the left you can call this method on a particular object and its going to look up the type of the object and its going to essentially convert this on the left to the one on the right and this is what youve been using so far so when you create a list you say l is equal to 1 2 and then you say lappend you know 3 or whatever so weve been using this notation on the left pretty much from the beginning of class so we have a coordinate class we can create a coordinate object we can get the distance between two objects as youre using the class if you wanted to use this coordinate class and you were maybe debugging at some point a lot of you probably use print as a debug statement right and maybe you want to print the value of a coordinate object so if you create a coordinate object c is equal to coordinate 3 4 right thats what weve done so far if you print c you get this funny message very uninformative right it basically says well c is an object of type coordinate at this memory location in the computer which is not what you wanted at all right maybe you wanted to know what the values for x and y were that would be a lot more informative so by default when you create your own type when you print the object of that type python tells you this sort of information which is not what you want so what you need to do is you need to define your own method that tells python what to do when you call print on an object of this type so this is going to be a special method just like init is because it starts and ends with double underscores and the name of the method is underscore underscore str underscore underscore and if you define this method in your class that tells python hey when you see a print statement thats on an object of type coordinate call this method look what it does and do everything thats inside it and you can choose to make it do whatever you want inside your definition of str in this case lets say when we print a coordinate object were going to print its x and y values surrounded by angle brackets that seems reasonable right so then from now on when you print coordinate objects youre going to see things like this which is a lot more informative so how do we define this so so far weve defined all that and the last part is going to be new so we define the init and the distance and lets define this str so underscore underscore str underscore underscore is a method its only going to take self because youre just calling print on the object itself theres no other parameters to it str has to return a string and in this particular case were going to return the string thats the angle brackets concatenated with the x value of the object selfx concatenated with a comma concatenated with the y value of this particular instance of an object selfy and then concatenated with the angle brackets so now any time you have print on an object of type coordinate youre going to call this special method str if its implemented in your code any questions ok so lets try to wrap our head around types and classes because weve seen a lot today lets create a coordinate object assign it 3 4 as we have been and assign it to variable c weve implemented the str method so when we print c its going to print out this nice three comma for our angle brackets if we print the type of c this is actually going to give us class main coordinate which tells us that c is going to be an object that is of type class coordinate if we look at coordinate as a class if we print what coordinate is coordinate is a class right so this is what python tells us if we print coordinate its a class named coordinate and if we print the type of a coordinate well thats just going to be a type so class is going to be a type so youre defining the type of an object if youd like to figure out whether a particular object is an instance of a particular class you use this special function called is instance so if you print is instance c comma coordinate this is going to print true because c is an object that is of type coordinate couple more words on these special operators so these special operators allow you to customize your classes which can add some cool functionality to them so these special operators are going to be things like addition subtraction using the equal equal sign greater than less than length and so on and so on so just like str if you implement any of these in your classes this is going to tell python so for example if weve implemented this underscore underscore add underscore underscore in our class this is going to tell python when you use this plus operator between two objects of type coordinate to call this method if you have not implemented this method and you try to add two objects of type coordinate youre going to get an error because python doesnt actually know right off the bat how to add two coordinate objects right you have to tell it how to do that and you tell it how to do that by implementing this special method same with subtract same with equals so if you want to figure out whether two objects are equal and when you implement these methods in your own class you can decide exactly what you want to do so what happens when you add two coordinate objects do you just add the x values do you just add the y values do you get them both together do you do whatever youd like to do and then you document what youve decided so lets create a fraction object so weve looked at coordinate we saw sort of a higher level car object lets look at a fraction object fraction object is going to be is going represent a number thats going to be a numerator slash denominator ok so thats going to be a fraction object so the way ive decided to internally represent a fraction object is with two numbers and ive decided that i will not let them be floats they have to be integers hence the assert over here so inside the init ive decided im going to represent my fracture with two numbers one for the numerator and one for the denominator so when i create a fraction object im going to pass in a numerator and a denominator and a particular instance is going to have self dot numerator and self dot denominator as its data attributes and im assigning those to be whatevers passed into my init since i plan on debugging this code maybe possibly sometime in the future im also including an str method and the str method is going to print a nice looking string thats going to represent the numerator and then a slash and then the denominator and then ive also implemented some other special methods how do i add two fractions how do i subtract two fractions and how do i convert a fraction to a float the add and subtract are almost the same so lets look at the add for the moment how do we add two fractions were going to take self which is the instance of an object that i want to do the add operation on and were going to take other which is the other instance of an object that i want to do the operation on so the addition and im going to figure out the new top so the new top of the resulting fraction so its my numerator multiplied by the other denominator plus my denominator multiplied by the other numerator and then divided by the multiplication of the two denominators so the top is going to be that the bottom is going to be that notice that were using self dot right once again were trying to access the data attributes of each different instance right of myself and the other object that im working with so thats why i have to use self dot here once i figure out the top and the bottom of the addition im going to return and here notice im returning a fraction object its not a number its not a float its not an integer its a new object that is of the exact same type as the class that im implementing so as its the same type of object then on the return value i can do all of the exact same operations that i can do on a regular fraction object sub is going to be the same im returning a fraction object float is just going to do the division for me so its going to take the numerator and then divide it by the denominator just divide the numbers and then im defining here my own method called inverse and this is just going to take the inverse of the instance im calling this method on and so its going to also return a new fraction object that just has the denominator as the top part and the numerator as the bottom part so then we have some code here so thats how i implement my fraction object so now lets use it and see what it gives us a is equal to a fraction 1 4 this is going to be 1 over 4 for a and b is going to be 3 over four when i do c notice im using the plus operator between two fraction objects right a and b are fraction objects so pythons going to say ok is there an underscore underscore add underscore underscore method implemented it is and its just going to do whatevers inside here so its going to say self dot numerator plus other dot denominator its going to calculate the top and the bottom its going to turn a new fraction object so this is going to be 4 plus 12 divided by 16 and 16 over 16 so c as a fraction object is going to be 16 for the numerator and 16 for the denominator because its a fraction object if i print c it should print 16 over 16 so we can even run it so print 16 over 16 if i print floats c so this special method float here is going to say is there a method that converts a fraction to a float and there is its this one implemented right here so its just going to divide the two numbers top and bottom which gives me 1 so its this one here and here notice im doing the exact same method call except im doing it the other way where you type in the name of the class name of the method and then what youre calling it on and this gives the exact same value here 10 and then here im calling the method inverse on object b which is going to invert 3 over 4 to be 4 over 3 and then im converting it to a float and then im printing the value so it gives me 133 so take a look at this code in more detail and see if you can trace through all of those different things and see if you can also write your own new fraction objects ok so last slide power of object oriented programming is that you can bundle together objects that are of the exact same type and all of these objects are going to have the same data representation and the same methods that you can do on them and ultimately youre going to be building these layers of abstraction so youre going to be building on a basic object type in python youre going to have integer objects float objects on top of those you can create lists dictionaries and on top of those you can even create your own object types as we saw in this lecture today 