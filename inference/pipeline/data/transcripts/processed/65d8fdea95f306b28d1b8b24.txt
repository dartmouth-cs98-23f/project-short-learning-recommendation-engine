foreign hi there welcome to computing with andy and we continue to look at human computer interface design and in this session we want to see how human computer interface design can be incorporated in the software development process so lets see what we have all right now it is important to know that uh hci gets incorporated into software development through the following activities or approaches number one uh through software engineering and two through usability engineering iterative design practices and finally using uh what well call the design rationale now in this uh lecture i am starting with the first item on the list and that is software engineering and were going to talk a great deal about this in so much that even this presentation will have two sub parts okay and lets see what we want to talk about now the first thing is we we need to have a good understanding of what software engineering is do you know that very few people know the difference between software engineering and software development um the term software engineering especially in zambia i dont know about other places ive noticed uh software developers calling themselves software engineers okay so its a term that is loosely used but the two things are very different a software engineer is different from a software developer and it is important to know that difference and i want us to start on that note okay because here we are looking at how are using software engineering human computer interface design uh gets uh facilitated so before we can know the difference between software engineering and software development it will help to look at the historical background uh to software engineering and a good starting point is what was happening in the 1960s through the 1980s during this period um there was a software crisis okay and what we mean by that is there were a lot of projects which were being done software development projects but which were characterized by failure okay and the following were things that happened that led to this period of time being labeled as a period of software crisis now this period was characterized by failed projects like i earlier mentioned many software projects failed and i need to say that some projects actually caused property damage and you know um where because of certain carelessness and satan um vulnerabilities which were in the programs which were designed it was very easy uh for someone for example to uh to get an authorized access a lot of bags and all such things but it didnt just end there a few projects actually caused problems like even the loss of life like in the 1980s um the thorac 25 was a computercontrolled radiation therapy machine which sometimes gave its patients radiation doses that were hundreds of times greater than normal and of course that resulted in injuring patients okay so uh it was 40 software running this system the thorac 25 okay and that is how terrible it was and um there were also many projects which experienced budget ovarence okay and a classic example of this was the os 360 this was a batch operating system which was developed by ibm for uh for their new computer system the men from 360 okay and this project was managed by fred brooks the gentleman who are seeing in the picture here uh he actually just died last year and um he was a great man uh did a lot of uh works and well what is interesting about this project he did it was a pre project i believe it lasted for over a decade and it was so large scale very big and huge it had about 1 000 programmers not lines of code programmers all right and in his book titled the mythical uh man month essay on software engineering uh brooke brooks remembered that you know he made a multimillion dollar mistake and what was the problem he pointed out that uh he should have first uh designed or developed a coherent architecture okay where you look at a whole system the overview of everything health is component fits uh with the other component he felt that should have been done first before starting the development project okay and well so many problems were going on and the good thing is uh there was an effort to point out what is causing these problems what is causing a lot of these software failures and were spending a lot of money and so many budget failures and all that you know and there were a couple of many other things which characterized the software crisis era one of them is unreliable software okay you invest so much into developing software but which ultimately fails and uh the the software which managed to get implemented had very expensive very high maintenance costs all right and it is said that the cost of owning and maintaining software in the 1980s was twice as expensive as developing the software can you imagine that and you know there was also a problem of um when for example youve implemented the software and maybe in the course of designing or coding it when customers give you new requirements at all we also need these features and that feature to be added and included uh there was a challenge to meet the growing requirements or new requirements which were coming from the users how do you incorporate them when youve already started doing certain works okay and youve gone through stages in the software development life cycle and there were also uh scalability problems okay um as software projects increased uh whenever maybe because uh hardware has a new capability or new speed and maybe uh theres a need to uh to add new components to the software or maybe to make this software cutter for a large number of users there were problems of you know trying to update these systems okay to accommodate new requirements to accommodate um you know the dynamics which were characterizing the business environment okay and uh there was also a problem of uh you know as demand was increasing for new software you know the demand exceeded the ability for the developers to generate new software so demand is increasing people want software but uh developers cant keep up with the with the purse all right and so that was the crisis all right but uh every now and then um companies individuals expats would come up with what they felt was okay this is a silver bullet its going to to be a good answer to this software crisis to all these problems so well in the course of time you had the solution this proposal and all that so through the 1970s various approaches were touted as silver bullets to solve the crisis and among them um you know there were twos automation tools you know which were getting developed you know as a way to um to develop software you know which will have quality and meet certain standards and reduce on errors and all such things and uh there was also an approach of structured programming objectoriented programming and so on and so forth okay all these were attempts you know uh you know to provide a solution to all these problems which were prevailing and well some some planets uh blamed the software crisis on their lack of discipline by programmers it seems some programmers were in a rush just to develop solutions without following are properly laid down procedure okay uh documentation doing thorough requirements analysis and all such things okay so theres also an issue of um uh discipline where some experts felt there was a lack of discipline okay in this industry and also uh with time former methods were being uh developed because some believe that if formal engineering methodologists now you know how traditional engineering when i say traditional engineering i mean engineering as people knew it where youre looking at machine equipment how engineers of these devices would take great care in how you design this component and how it needs to work with another component and you make sure all the measurements are correct accurate and all that now that is very typical of uh engineering all right and well some felt if we can introduce formal methods okay formal engineering methodologies if they could be applied to software development then production of software will become as predictable an industry as other branches of engineering okay so you know that in engineering you want to quantify things you want to measure things precisely and you use all the mathematical tools and formulas you know to ensure that accuracy is the is the m is the goal and so uh former methods were being introduced you know to uh uh to provide a way for software which is getting developed you know to be accurately measured assessed you know so that uh errors could reduce all right now um other issues which came up and where being advanced was the issue of process men advocated the use of defined processes and methodologies like the capability maturity model okay and there was also emphasis on professionalism it was during this time that uh uh works also were being laid to the development of code of ethics licensing and professionalism okay you have people like professor benam you know who really advocated for you know the importance of core of ethics issues of licensing issues of you know defining the software uh you know career as a profession not just something any person you can do in their own way you know but there has to be code of ethics which needs to be established code of conduct you know professional associations to define you know the right way to do things in an ethical in an in a responsible way and well over time former methods best practices and standards you know have been developed and this has uh culminated into what we call software engineering now let us define software engineering now you notice immediately that there are two words in this term that is software and that is engineering well what is software we know that software is a collection of codes documents and triggers that does a specific job and fills a specific requirement simply well series of instructions that enable a computer system to function now that is what we can say about software but then what is engineering and why are these two terms being brought together engineering is uh you know it refers to the development of products using best practices principles and methods the listings characterize engineering okay engineering really emphasizes on you dont just develop a product anyhow you know there has to be best practices which have to be defined they have to be principles you need to adhere to there are particular formal defined methods all right now bringing in uh bringing software and engineering together means uh uh software engineering is the application of a systematic disciplined quantifiable approach to the development operation and maintenance of software so what we are simply saying is the application of engineering to software okay um ultimately thats how we come to define software engineering so we want to apply systematic a systematic approach you know to the development of software we want to apply a disciplined approach to the development of software we want to apply a quantifiable approach you know to the development of software okay and now this leads us to what we wanted to explain the difference between a software engineer and a developer a developer simply designs and codes specific application software so if it is a software to perform a particular task or for a certain one organization where you develop that system and it is uh not only focused okay its really about developing software but when you talk about software engineering it goes beyond that a software engineer uh typically we work on a large a large scale system okay and well of course that means uh even the design is of a large scale and it involves developing and testing entire computer systems and application software for a company or organization now this implies that software development is just a subset of software engineering because in software engineering youre going to look at the overall architecture the over overall architecture youre going to investigate the different components which are there okay how will this module fit in with this and you look at all that and then you you you you do what is known as architectural design then later on you do detailed design to make sure is all these different sub systems get integrated there should be uh um uh you know a seamless flow of information there should be proper integration okay so here you are looking at largescale systems so software engineering like ive just mentioned involves architectural design and this requires decomposing a largescale system into interacting components again simulate what happens in the actual engineering okay a block diagram can be used to define an overview of the system structure features of the components and how these components communicate with each other to share data now why is there a trouble to do a detailed investigation like this it is for this simple fact that you are looking at a large system with uh different components in it but as these different components begin to work you dont want them to uh to fail to communicate or to pass data from one components to the other you want them to fail to do that so software engineering involves a meeting with different units and users of system to identify their requirements and the letter you know you want to analyze all these different things and how they can fit into a coherent hall okay and so what is important is software engineering is the discipline for understanding the software design process or life cycle okay and designing for usability occurs at all stages of the life cycle not as a single isolated activity so what we mean by this is uh when you look at software engineering it really focuses on uh you want to understand the software design process the the whole systems development life cycle you are interested in that and um you focus on issues of usability not just as a particular stage at a certain time but from the beginning you want to see if this system we are developing will satisfy user requirements you are not just given a particular task to say oh okay weve done the requirements now can you start coding this module no you look at an overview of everything and you make sure as the work is starting issues of usability have already been taken care into taken care of been taken care of okay and so here is the traditional waterfall model listing the main phases of a systems development life cycle you of course begin with requirement specification then architectural design then detailed design coding and unit testing integration and testing operation and maintenance so when you talk about software development you are really interested in these stages here coding and testing okay and integration testing and all that but when youre looking at software engineering youre really concerned about this whole thing here okay and youre looking at a large scale system and now if you notice there is what weve stated here requirement specification and let us talk about that okay and what happens during this stage now in requirement specification the designer and customer try to capture a description of what the eventual system will be expected to provide in other words whatever project you are working on whatever system you want to develop what is it required to do what is it required to achieve and so uh the important artifact that comes out of this is the requirement specification document now requirement specification involves eliciting information from the customer about the work environment or domain in which the final product will function so you really want to interact with the prospective users okay you need you you want to understand how is their work environment because this system youre developing remember were talking about human computer interface it is these people who will be interacting with this system so rather than just locking yourself up in some room and trying to develop or write some lines of code software engineering you want to understand what kind of environment will this system run in okay you want to capture the requirements you want to interview these users you want to ensure that um um what this system uh is designed to do ultimately it has to answer to what people uh need okay and aspects of the web domain include not only the particular functions that the software product must perform but also details about the environment in which it must operate such as the people uh whom it will potentially affect and the new products relationship to any other products which is which it is updating or replacing and remember this whole approach is an attempt to do away with the crisis which happened in the 19th century instance so you want you dont just limit the activity to developing lines of chords and all that but you know you extend it to uh wanting to establish a good understanding of what kind of environment or this system operating okay now requirements must be formulated in a language suitable for implementation okay now requirements are usually initially expressed in the native language of the customer okay and that is how a requirement specification looks like it is just written in a natural language uh which we use you know uh it can be english and you describe in detail what the system is required to do but however what will happen is whatever those things you are expressing will need to end up as software code okay so the executable languages for software are less natural and theyre more closely related to a mathematical language in which each term in the language has a precise interpretation so what that means is a data of description which can be in english can even be ambiguous but uh whatever requirements you generate they need to be stated in uh in form of precise statements where there is no ambiguity because remember it has to end up a software called so the transformation from the expressive but relatively ambiguous natural language of requirements to the more precise but less expressive executable language is one key to successful development okay and that is true um what ultimately should end up a successful chord should be um through a process of refining these expressions in the requirement specification refining them to such an extent that you come up with nonambiguous statements okay which can be expressed in form of an algorithm uh or a pseudocode and ultimately it will end up as software called now after you know producing your requirements specification the next uh critical activity is architectural design and this focuses on how the system provides the services it is expected to provide now when you are doing requirements elicitation or when you produce the requirement specification the requirement specification merely states what the system needs to achieve what it needs to do but architectural design specifies how the system will work okay and this is a high level description of how the system will function so the first activity is a high level decomposition of the system into components that can either be brought in from existing software products or be developed from scratch independently so remember you first had an overall um specification but then now this high level the specification has to um uh later on you know be decomposed but at this point when youre looking at architectural design this is a high level decomposition of the system into components that can either be brought in okay from existing software products or be developed from scratch independently okay so you are looking at what was described in broad terms but now you are looking at a high level structure where you show the different components which are there okay then overall thing which needs to be achieved is broken down into these components which are interconnected okay and certain components can uh be brought in as already existing software products or they may have to be developed independently okay but architectural design goes on further to describe the interdependencies you know between these separate components and the sharing of resources that varies between companies so all this thing has to be done during architectural design so that later on you dont have problems which used to happen during the software crisis where after doing a lot of work later on as you try to integrate these things you know like uh frederick let us say to say we should have started by looking at the architectural design of the whole thing looking at the components which are there and how this has to interact with this way before you start any coding activity you know you avoid a lot of problems by doing that okay and of course what follows after architectural design is detailed design and this refers to the refinement of architectural components and in the relations to identify modules to be implemented so you further break down whatever was identified during architectural design where you refine this architectural components okay to identify which modules have to be implemented which modules depend on each other and you forecast on those particular modules how they need to function what input they have to take which other components do they need to interface with okay and the behavioral uh the the behavior implied by the higher level description must be preserved in the more detailed description so you dont uh you uh you you dont forget what youre from doing at architectural design uh whatever was described under architectural design should be preserved there should be consistency okay you dont introduce new things on detailed design which are not reflected in the architectural design so the behavior implied by the higher level description remember that behavior was only implied it wasnt detailed you know it was just alluded to but that same thing which was implied in the high level description during architectural design must be preserved it must be returned in the more detailed description okay and typically there will be more than one possible refinement of the architectural components that will satisfy the behavioral constraints choosing choosing the best refinement is often a matter of trying to satisfy as many of the nonfunctional requirements of the system as possible okay so for this part we shall end here and then we shall continue moving on uh to coding testing and all that that will be covered in the next lecture okay see you in the next lecture music 