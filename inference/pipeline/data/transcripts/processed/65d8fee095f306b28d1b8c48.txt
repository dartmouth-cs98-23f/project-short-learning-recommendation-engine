be talking tonight a little bit about algorithms and complexity i was interested in algorithms and wanted to talk to them to some aspect of them in my techtalk this topic proved to be a bit intractable but im hoping to provide an introduction into some of the ways that computer scientists and theorists think about complexity and algorithms so my my screen is showing you a fractal pattern fractals are geometrical patterns that can be broken down into smaller units and each smaller unit is a like half size or reduced size copy of the pattern as a whole fractals are found throughout nature which we can see in this nice image of a cactus some flowers and cauliflower which is everyones favorite fractal image but fractals fractal patterns can also be generated by algorithms recursive algorithms and thats i think this is one example of that that you see on the screen now so briefly to give an introduction to an algorithm its defined simply as a precise rule or set of rules specifying how to solve a problem algorithms are complete they are finite they may be exact in terms of their solution to a problem or they may be in exact they may be approximate in programming they are evaluated among other ways but one important way is by their big o notation which we are all familiar with and this the big o represents the upper bound on the number of operations a function will have to produce well when it is called so the number of operations and how this number changes as the size of input grows gives us some information about how long the process is going to take to complete another graph which will be familiar this is a plotting of inputs n on this access little n versus the number of operations to complete the function big n on the yaxis constant operations that remain constant even as the size of input grows will give us a big n of a constant some constant call it 1 this is an ideal scenario but not always possible a big o of n is when the number of operations grows constantly at a constant rate as the input size grows and these are less these are the sort of bago youd see for less complex algorithms as we get more complex you start to move to this area of the graph and ill just draw your attention to these three clustered here where you have n squared o of m squared this is called polynomial time which is the largest factor in that time is going to be and to some power could be n squared can be in cubed then in the orange next thing to it you have 2 to the end this is exponential time and then finally factorial time and so one of the significant divisions in terms of how computer scientists think about complexity occurs in the change from polynomial time to exponential time so more on that in a minute but just to return to our fractals i wanted to start with fractals because theyre pretty theyre interesting to look at they use recursive functions which were familiar with but also they represent a case that might be kind of surprising i think for complexity which is that the patterns can look complex but the process to construct them might not necessarily be so so this is via khan academy a common fractal pattern called the sierpinski gasket here you see the finished product and then they also helpfully provide a stepbystep of how to construct this pattern you start with a square you divided into four squares you put an x in all of this the nude subdivided squares except for the one on the bottom left and then for the squares that have xs in them you repeat the process again removing any marks from that bottom left square it should remain empty you repeat this process again notice each time the size of the square is diminishing and we have more lines and a more complicated picture finally well reach a point where we decide our dimensions are small enough we dont want to subdivide anymore and at this point if you fill in all the squares with xs in them you get the sierpinski gadget so although this pattern looks complex you have a finite and constant number of steps for it each iteration of the function so if i were to posit what the o of n of that particular fractal function would look like i would guess that it would be constant n because as if we take the number of iterations as the input as that increases in size the number of operations is just going to increase at a constant rate so that puts it in the lake not so complicated region of our graph which brings me to the more complicated region of the graph there these terms p versus np are ways that theoreticians think about complexity p means polynomial time that means a time to execute which has an upper limit marked by and to some power np time is anything to the left of this anything that grows at a rate faster than that described by n to some power a more a more theoretical definition of them is problems in the set p can be solved on a deterministic turing machine ill explain what that is in a second by an algorithm that runs in polynomial time whereas those in the said np can be verified like if you have a positive solution you can verify it on such a machine in polynomial time but you couldnt find a solution in polynomial time a turing machine is named for the british mathematician whose first name is escaping me alan turing i think um who was a quote breaker during world war two actually developed the model the conceptual model that a lot of people still use for a computer before the first computer even existed he was working on breaking a german ciphers during world war two side note there is a 2014 movie called the imitation game with benedict cumberbatch and its pretty good and its about tourings code breaking work during the war it has a pretty sad ending which reflects his prosecution at the hands of a moralizing state so just be warned if you watch it but i would recommend it so np problems can be verified but not solved in polynomial time they cant however be solved in polynomial time on a nondeterministic turing machine which is just a concept of some kind of computer that would be able to be in different states so performing different operations at the same time which i dont think exists in real life it may be quantum computing but thats a question for someone besides me then we have within the class of np problems to further complexity labels and p hard and npcomplete as far as i can tell the definition of np hard means its just as hard as any hard problem in a set np  npcomplete shares that criterion but also and this is kind of interesting theyre an np complete problem is kind of a representative problem for the set of all np problems the idea is if you could solve an np complete problem your algorithm could solve with a little bit of tweaking every other np problem and the reason this is interesting is that a lot of internet encryption relies on np problems remaining unsolvable in any reasonable amount of time and so if somebody were to come up with a solution to an np complete problem internet security would be in big trouble because youd be able whoever had that solution would be able to with work shirley but not you know crazy exponential amounts of work break every or solve every other np problem and therefore break a lot of encryption but what if you still need a solution to an nphard problem so one approach is to develop an approximation algorithm this is gonna be the case of like goodenough gives us a working solution may not be the best may not be ideally optimized but will at least get us a working solution for our problem so for the remainder of the presentation which may not be much longer im just gonna take a quick look at one such case where its a very well studied problem called the vertex cover problem and this is a case in which an approximation algorithm so sort of relaxing the constraints on your ideal case will enable the problem to be solved the vertex cover problem comes from graph theory so its quite convenient that karen talked to us last week about what graphs are these slides that are formatted in this way are from a course offered at the nsba quill normale sup√©rieure in france and made available via coursera so i have references at the end of the slide if youre interested but i just want to make clear that this is not my work so the vertex cover problem is you start with a graph heres an example of a graph its defined by vertices which are blue dots the vertices are labeled they have little letters they they also have weights which are the red numbers so each vertice each vertex has a weight which is at least in this case fairly arbitrary the edges are the black lines and in a vertex cover problem you want to make sure that for each edge like this edge c be at least one of its endpoints ends up in your solution set of vertices the reason if if speeding along here the conclusion about this problem is that it is going to be nphard and why you might ask me and i might tell you well a lot of people have studied it and they said so and theyve proven so and a really smart professor at the ecole normale says so so we should all agree with that but i try to work out one reason myself which is that if this each if we have a problem with four vertices here right abcd for each vertex you have two possible states yes or no if we are brute force coding through all possible configurations we end up with two to vn possible configurations shown here so this is a problem with only four vertices and it ends up with 16 possible solution states so this if we go back to that graph earlier to zdn is outside of the bounds of polynomial time again briefly it turns out that if you take the word of scientists past and scientists present that this problem is nphard its only because the vertex can either be in or out of your solution set so its either a zero if its out or its a one if its in and this integer constraint is what makes the problem unsolvable um a cheesy math example of a situation where you might have no integer solution is the second set of equations here or the second equation here where theres theres no energy integer solution that will satisfy this equation but if we let x be a real number instead of an integer you can find a solution its just going to be messy so long story short thats what happens with the vertex cover problem if you relax your condition and allow your solution to be a non integer you allow the vertex to be kind of like partly and partly out for the sake of solving the problem you can in fact find a solution it may not be like ideally optimized but the magic moment and ill just tell you this about the end is that you round this is what you do when you have your decimal points between 0 and 1 for each vertex is you round up to one for that particular vertex if its if if it ended up with a value that was greater than or equal to 05 and zero otherwise and the limit on this is that it would be at most two times the cost of the sum youre trying to minimize the sum for all the vertices that are included but apparently in like daytoday working scenarios its usually within about 10 of an optimal solution which doesnt seem that bad so so much for a very quick look at complexity in dollars applause 