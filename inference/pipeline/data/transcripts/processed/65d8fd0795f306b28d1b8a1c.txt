recognize most of your faces from cs223 thank you for coming to the class on the first day uh well do an introduction today a little bit about the administration of the course um and then well start the lesson with the material from chapter one usually chapter one is an introduction to the whole topic thats what its going to be here today so i can say that its a good uh you know overview of the material its not necessarily going to be on the exam and there will be a simple homework probably from chapter one but its not hard its more to help you get a engineers perspective about computers um so while were waiting um i guess ill introduce myself im will sawyer ive taught at bill can for 10 years im an american i do speak turkish but im not allowed to in the classroom as you know please dont try to get me to tell turkish jokes and be funny most of the recent students laugh is not because my turkish is funny its because me speaking turkish i speak it in a funny way so its not do all of course but anyway i think if you uh tune into my english it is a little bit fast its natural speed but if you tune into my english youll get the tempo if youre having trouble understanding my language do raise your hand and say hojo can you please say it again or slow down hold you or repeat it a different way im happy to do that the goal here is for you to understand its not for me to get up here and run through you know 50 slides and give a good performance its for you to learn the goal of being here is for you to learn so im here to assist that learning they call me a teacher but i dont think that i teach so much as i think you learn so im the help with the learning process thats my job were going to use powerpoint slides quite a bit in this course but therell be times when we do some other things as well but the opening lecture today will be pretty much from the slides id like to get a class discussion going id like to ask questions but ive had a hard time finding students responding so when theres that awkward silence and hoja asks a question please dont be afraid to be the first one raise your hand and say yeah i think this maybe its wrong maybe its right but heres my opinion heres my idea ill really appreciate that thats what wed like as a dialogue and for you to be thinking ive said it many times before but ill say it again because it bears worth saying you can watch a lot of movies and not learn anything about how to make movies and so if youre here to watch a course go by youre probably not going to learn very much about computer organization but if youre participating as an active learner im sure that youll learn much more so thats the own says lets see if we can find our powerpoint slides and begin okay i think everybody knows but if you go to the course homepages on our departments site you see every single course and this is cs224 so heres the home page for cs224 for this semester like the homepage for 223 the recent announcements will be found here anything thats important lets go see if theres anything important to learn oh my goodness theres already announcements oh boy it has begun the syllabus shows the readings for each week and theres already an assignment to read chapter one and follow along it supplements the introduction that ill be giving in class and to be prepared for each week you should do the reading in advance of the class next week well move into chapter two about assembly language so it should read ahead and the textbook for the course is this one the computer organization and design book by patterson and hennessey its in the fourth edition whenever you get a book thats in the fourth fifth sixth seventh edition that tells you that its quite popular around the world as a textbook this is international student edition very reasonably priced top quality top shelf best in best in class as far as im concerned so weve picked a good one for you you need to get this one fourth edition there are some still some third editions floating around among the students but thats not the one we we have significantly changed from the third edition please dont use the third edition all right so thats our first little announcements schedules will be posted here for myself and the other teacher but currently theyre not right weve got five tas but theres been a little bit of change there as well your class section is three so were here on friday afternoon and the office hours will be posted im not exactly sure if ill be available these hours on tuesday so there may be some updates but the book has its own website if you click here you go to the website about the book there are resources for students including a solved example problems the code from the book some extra resources lots of stuff here that you can get from this books website the objectives of the course lets go over what are we trying to achieve in cs224 why are you here because its required hold you i have to take it thats the only important reason no no no no theres a lot of things that were going to be hoping to achieve will we achieve everyone in every student no i dont think so but the goal will be that most students achieve most of these objectives so ill let you study these on your own time to see what were trying to get but the main idea here is to learn about how computers work computer organization how are they organized what are the structures from a hardware point of view and also from a software point of view what are the structures so this is a the name of our textbook is called computer organization and design the hardware software interface so its right at the place where software and hardware meet thats the thats the focus of our course so itll be both looking up to the software layers and down to the hardware layers and right at that interface thats where the course is aimed at so you can see that after we work on instruction set architectures then we look at processor units especially pipeline then we move into memory and do cache and then some bus and i o issues and then youre going to gain experience in the use of hardware description languages and tools for designing computers to be able to explain in an informal interview on a project you know what youve worked on and why you did what you did and practice the skills of project documentation and technical reporting so again you might say one of my goals in this course is to turn you into an engineer engineers design they document they give oral presentations they work in teams they do peer review all those will be part of our our courses approach okay the syllabus of the course shows what topics well be covering every week well this is a really weird week because it starts on a friday so i just put friday on to uh next week but it means that with friday and next week you have three class sessions and most of the uh topics will only need uh integer multiple of weeks so therefore if this takes one week for the other two sections and we have a week and a half it means were going to finish early so and the second lecture in each week well probably be looking ahead to the next weeks material so today and the tuesday will be corso review introduction to computer architecture next friday well already be moving up to here the reason is this this section is out of sync with the other two sections because you we start today on a friday which makes the week weird anyway you can see that were going to cover the material from the textbook including some appendices in order of the chapters one two three four five six and inshallah if time allows chapter 7 by the end of the course weve not only covered processors and pipelining and memory hierarchies and i o systems then were moving into multiprocessors well actually look at multicore chips and clusters of processors in order to form parallel computers thatll be our end target by the end of the course so this gives the topics and the readings the schedule for the homeworks on the projects will be announced separately on other web pages i wont try to integrate them here but you can see for each week of the semester ive written something including look at this one spring break week first week of april middle class take a vacation maybe the weathers warm down in the south lets hope so anyway the grading policy everybodys always interested in in how will the course be graded heres what were going to do in order to pass this course you have to show a minimum competence in the exams any student that doesnt have a weighted average of 30 or greater from the midterm and final will not pass no matter how wonderful your homeworks and projects and quizzes are you must show that you understand the material oil in a proctored exam where you are independently thinking and working so were going to have an exam minimum to pass and then the activities in the course which will account for the percentage of the grade are homeworks quizzes projects the midterm and the final and you can see that the exams together 50 and the other things are 50 so its about half and half and then from the numerical average uh grades the students who meet the above requirements will then be given a grade in the range from a to f and it depends on as it says there the classes overall average the distribution your personal performance uh your effort your attendance your participation in the class so those can be factors that affect your personal grade um yeah theres a bunch of resources here like there was on the cs223 website i wont go through them now because theyre not of any value you dont really know why we need them and what theyre for but theyll be useful later theres a policy statement about homework there will be homework assignments posted here as they become active when you click the link something will happen right now nothing happens because the first homeworks not posted um and solutions to previous homeworks will be always placed in the library on reserve soon after the homework is due you can go and get the solutions and check your work to see how well you did project assignments will be based here we generally have two projects the first one is an assembly language programming project the second one is a processor design project so ill be grouping you up in groups of four or five and where youll be working together first on this in teams then well reshuffle the project teams and youll form a new team and youll work with that one sort of like in companies they form project teams do a project then they reform and they form a different team for a different project uh theres an exam policy statement here which says what you need to be aware of when you come to our exams in the previous years exams are generally posted but then we take them down and theyre not posted so but you can im sure find them anyway if you look so well put up just before the midterm well put up the last two years midterm exams as samples to see what kind of questions to expect and then just before the final well put up the last two years final exams to give you an idea of what to expect and then as we did in cs223 the grades for homeworks quizzes projects and exams will be posted on links here uh probably by section and then at the end the lecture slides so the lecture slides will be posted here all right are there any questions about the sort of administrative aspect of the course um anything that you want to ask about how were going to be running the course not the content but the administration of the course policies and i dont know procedures okay if you dont have them now maybe theyll come to your mind later and you can send me an email as you know i try not to do too much course administration in the class we want to focus on the material of the learning of computer organizations so i try to keep the admin outside class time this is the biggest section of time that well give to administration in the whole semester is this little introduction here because i think the class time should be spent on content you can read the announcements thats a lot of administration if you have questions you can email me and ill respond we have a good group of tas including phd students and some top level master students and people that took this course before and very much enjoyed it and theyll look forward to you visiting them in their office and you probably will want to do that when the projects come because youll need their help any any questions at all okay and oh wait maybe yeah yeah almost thing okay then then there arent any all right then lets start the material lets begin chapter one and an overview of computer organizations everybody okay all right lets do that okay um i coteached this course with um os john ostirk he teaches section number one and number two and im teaching section number three so its a wellcoordinated course if for any reason you need to transfer sections youll be getting excellent instruction from ocean in the other two sections if for some reason you have to miss and you want to get the material live uh you can go to the other section and get it but theres also the material will be on the videotapes which youll be able to see and also the slides are posted on the web so theres lots of opportunities um for you to get it if you miss it okay i dont encourage you to miss i encourage you to come to class all the time but in case you missed the class theres opportunities to see the lecture or get the material or even get it live in the other section we go first and then the other two sections meet next week so this if you missed today for example simple you could come later youll have that advantage throughout the whole semester your section is just a little ahead of the other two sections so if you miss then you can go to the other sections and and hear that same material being taught okay heres a imposing slide of the course contents i think this is actually just taken out of the catalog the catalog kind of what is a student expected to learn if they get into cs224 and you can see were going to have an overview and then were going to talk about something real important called instruction set architecture isa and well spend quite a lot of time maybe two three weeks on instruction set architecture here the word architecture sounds like hardware here the word instruction sounds like software and thats exactly it the hardware and the software coming together at this level well look up designing an instruction set architecture which essentially means designing a processor well look at two basic uh families of architectural approaches complex instruction set computers and reduced instruction set computers then well work down on the assembly language level and well do a lot of work at low level software and then how to translate those and how to startup programs even including compilation so well look a quick look at compilers then well move into arithmetic and how you do arithmetic in the computer so well look at computer arithmetic what units are needed in order to do the computer arithmetic including floating point numbers and their implementations so after weve gotten the arithmetic then well head into the full processor design so this is for the alu you know arithmetic logic unit once we got that then well put it together in a full processor design and having already surveyed what kind of design considerations and the options then well actually design a processor well design the data path well design the control well implement them then well pipeline it and speed it up well look at difficulties called hazards and issues with pipeline design and then we will even look at how to predict branches in order to get further performance improvement and how to handle exceptions which are all sometimes called interrupts then after weve done all that you can see thats about 70 of the course then were going to work on the other parts of a computers architecture which are memory and input output so then well spend time on the memory hierarchy principles and structures of memory uh performance dealing with caching dealing with virtual memory dealing with segmented memory dealing with paging some of those topics actually are very important in operating system design so thats why we require cs224 before taking the operating systems course so youll get a good understanding of computer memory but not obviously as deep as computer processors then we move lastly into input output devices performance interfacing buses and things like that so how to connect peripherals to the computer and then lastly in the final week well be looking at multiprocessors and multicomputers including clusters and multichip multicore processors all right so basically you know everythings on the website go there and look your questions are answered heres the layout of the distribution of the of the points to pass you have to make two exams exam grades have to be above the minimum and you have to have overall course performance thats passing all right thats um lets begin now uh with the question um you know what do we mean by a computer theres different types of computers different uses of computers different manufacturers so its a pretty broad category when we talk about computer dont just think oh i know what a computer is its this thing right here you know a desktop or a laptop because thats too narrow of a definition yes you know what one particular kind of computer is but we have desktops laptops servers embedded devices which are computers lots and lots of different kinds of each of these we have different uses of computers you realize theres computers in automobiles computers in portable electronic devices computers in uh lots of things different manufacturers know theyre not all made by intel or just amd and different underlying technologies and different costs its a really broad category and our goal in this course is to expand your understanding of computing and computers much bigger than perhaps you have thought its not just the thing that you can put in your chanta and take with you to school and you know read on an airplane or a bus the best way to learn about computers is to focus on a specific instance and learn how it works at the same time while teaching general principles so you have both a specific and deep example and you also have a broad set of understanding to apply through a computer so what were going to do is learn general principles and historical perspectives about how computers have evolved as computer architects and computer engineers have brought them to the place we are at right now but at the same time well be looking at a specific instance of one computer architecture now why would you want to learn this stuff i dont really want to its just because its a required course i hate hardware you know that may be your answer i hope i can persuade you to vasquez from that some positive answers to that question are the following if you want to call yourself a computer engineer you have to understand computers right if youre a bridge engineer you understand bridges if youre a traffic engineer you understand traffic youre a chemical engineer you understand chemistry so if youre a computer engineer you must understand the computer deeply widely completely and well second thing is you want to build software that people can really use and if it has terrible performance then it wont be used and so your software will not be a valued in order to satisfy customers needs there must be adequate performance people are impatient and they push the button they want to see some response so if you dont understand the relation between software and hardware your performance will be probably poor and then the third thing is and this happens a lot computer engineers are often called upon to give advice or even make a purchasing decision should we buy this hardware or should we buy this hardware how much money is it worth to spend to get that we have this budget whats the best performance we can get to meet our needs for that so you have to understand hardware because youre involved in purchasing it either advising or actually making the decision yourself um now both hardware and software are going to affect our performance when a program runs on a computer of course the softwares algorithm and its big o and the efficiency of the code and the compilation those will have an effect on it but so will the hardware ive listed here a number of factors that determine the performance first is the algorithm and it actually affects the number of source level statements and then the language and compiler and architecture together determine from the source how many machine instructions will be executed notice you dont write machine instructions so theres already been a transformation from source level down to machine level source being things like c plus plus and java high level languages and then the processor in memory will determine how fast each individual instruction is executed and the i o and the number of cores will determine the overall system performance so weve actually got one two three four different factors in system performance and i think you can see that its like a chain if any one of these is the weakest link that will limit the performance if you have a bad algorithm with a bad big o then youre not going to be able to say save it even if you have the worlds fastest hardware on the other hand if you have the worlds greatest algorithm but youve got problems here or here or here youll slow it down and youll waste the performance of the algorithm so optimizing compilers efficient algorithms high performance implementation and architectures and multicores are all ways to make things go faster and of course well be looking at this this and this in this course this is other courses you get that in algorithms and your software engineering and programming courses all right now the five components of a computer is classically understood are the processor which contains both control and data path so you see that those two here the memory and the input and the output so sometimes its reduced to three processor memory io io actually means both of these processor of course means both of these and weve got the control which is giving the orders thats the brain weve got the data path here shown as a kind of a production line you know taking care of data and actually doing things with the data so theres like the body notice that memories in the middle things from the processor that have to go to io go through memory memory feeds or receives from the processor and it also feeds and receives from i o input as things coming in output is obviously things going on these little boxes are data okay and you can see that they have all different shapes and sizes for io but theyre much more regular when theyre inside the processor theyre theyre the right size for processor to be able to handle and so heres a good equation data path plus control is the processor processor sometimes called cpu central processing unit thats an old term from my days but you still hear people saying cpu but these days a more modern word would be processor are there any questions about this this is probably one of the more important slides that well see this semester because it gives the picture of what is a computer its a collection of the processor which itself is a collection of two major units memory and input output it actually shows a kind of a functional model of what it might do five classical components um input devices are things like mouse and keyboard but many other as well output devices are things like displays and printers but many more as well memory are things like the jump drive that i plugged in here disk drives dram static ram cds all kinds of things can be used for storage networks are some of the components connected to computers and our primary focus in this course as i said earlier is going to be the processor unit itself thats going to be our primary focus well have a secondary focus on memory and io but those are only the final 30 percent of the course we really want to understand deeply the processor because its the you might say this the the actor inside the computer its implemented using billions of transistors as you know and so its impossible to understand it by looking at a low level so were going to do the classic engineering thing were going to use abstraction were going to take a higher level view if thats not high enough well go to a higher level view well choose the view level in order to get the right tradeoff between understanding and detail too much detail blurs our understanding not enough detail also limits our understanding so the great thing about abstraction is a modeling approach that allows you to look at and understand the level thats appropriate for your needs so abstraction omits unnecessary detail and helps us cope with complexity its a very key engineering approach or engineering tool to abstract and therefore model at the right level um so theres a lot of abstractions in understanding a computer and this course is going to deal with quite a few of them okay lets just toss out some application software system software assembly language software machine language programs architectural issues sequential logic and finance state machines combinational logic and arithmetic circuits boolean logic down to the bit level transistors use to build the logic gates semiconductor and silicon used to build the transistors properties of atoms and electrons and quantum dynamics to make the semiconductor work okay so did you see what there theres a nice stack of abstraction and every layer is a way that you could look and say i want to understand computers im going to look at quantum dynamics and atoms oh my goodness or i want to understand computers im going to look at a few billion transistors or i want to understand computers i want to just look at the application software level huh its a spreadsheet oh computers work with numbers computers let me enter my words and write my letters thats a very high level abstraction it hides all this weve been as you know working here at the level of sequential logic and combinational logic in cs223 and this of course the subset of that now were going to start to move up to some of these levels here and here and here okay so i say our course kind of deals in this range right here so im overlap with 223 and some new stuff for 224 youve got plenty of courses that work at this level and moving down below here transistors semiconductors were moving toward electrical engineering and physics okay so that that will be their domain to model at that level so were in the middle of this stack with software engineering here computer engineering especially the hardware and and computer architecture here and then moving into the but this is a set of abstract layers each is an abstraction built upon the one below all right now lets make it into a diagram form that was a stack of words this is a stack of blocks in a block diagram same thing though um application programs sit on top of an operating system they need that operating system to operate the operating system needs the compiler and the firmware which are again software okay now below the this blue block in the middle is the implementation in hardware and you can see that ive got an instruction set processor ive got an i o subsystem to supporting that with logic design supporting that with circuit design supporting that was layout so once you know what you want you can implement it going this way and this right here instruction set architecture that blue box is the top of what we call computer architecture so computer architecture is both the implementation of the hardware and the model of what it will do the architecture i mean this building has an architecture and it also has an implementation the architect designed it and then after that the building company came and built it but they didnt just build it randomly they built according to a design so that the building would have what the functionality which is needed to support instruction and labs and administration and offices and so on security etc in the same way this blue layer is the key its the middle of the this software depends upon a reliable interface here for the instruction set architecture the instructions that architecture once designed determines how you will implement so actually this is going to be a key focus for our courses this middle layer or the software touches the hardware thats the reason for the choosing this textbook the software hardware interface heres a picture of it in a different way these two guys are acting or dancing or sword fighting or whatever theyre doing and theyre on a stage the stage is the platform and its called the instruction set you cannot have software if you dont have an instruction set because the set means we will choose this instruction and then well follow it with this one then well follow it with this one and so you build a program by choosing instructions you put the instructions together in an order which implements the algorithm that you want to have in your program so an instruction set is the resources from which we will choose the instructions that in are needed for your program or your program or your program or my program so its the resource so the instruction set is the model of the computer oh it has a branch oh it has an ad oh it has a shift i can build programs so the software needs to have this much of a view what are is my instruction set but the instruction set of course is implemented by a hercules which is our hardware this is the implementation of it once you have an instruction set that determines the hardware you must have in order to supply those instructions if you build hardware and doesnt have a shift then its not part of your instruction set so understand once again this is the key layer the software understands it as a model depends on it and runs on it but its implemented by hardware so together this is our computer architecture this plus this are there any questions about this concept here okay trying to get the idea different ways you know pictures block diagram words key abstraction is the instruction set architecture okay now heres a verbal definition of it lets see if we can work with this now and some people are multimode learners others have different modes this is a verbal way now to try to approach the concept the isa instruction set architecture sometimes just called the architecture because were not talking about bridges or highway systems or you know buildings were talking about computer architecture the isa or the architecture is the abstract interface thats the key its an interface between what the hardware and the lowest level of software that encompasses all the information necessary to write a machine language program including the registers the instructions the memory the i o and everything it is the interface on which the lowest level software can run and it provides all that that software needs to know so it enables various implementations which have cost and performance differences to run the same software now that means that if you specify the instruction set architecture the same software can run on it even if you implement it that way or you implement it that way now whats the classic example of a common isa implemented in two very different ways that all of us are familiar with every time you touch a computer you have an example of this the programs run no matter whether you buy it from manufacturer x or manufacturer y what are we talking about if i open up this computer what will i find inside for a processor what will i find inside will i find intel inside maybe but maybe not what else might i find inside amd now do i need to ask the computer oh this is an intel processor okay i got to use these programs oh no its amd those wont work i got to use these programs is that a problem no why not because theres a common instruction set architecture which the programs run on but the two companies have implemented their processors in different ways exactly what it says here it enables implementations of varying costs have you been to buy a processor lately in those prices am these prices are different varying performance been to a website lately and seen performance claims and performance measurements theyre not the same theyre not identical they have different number of transistors and different layouts and different everything internal organizations but when it comes to dancing on the stage the stage is the same your software runs no matter whether its one or the other okay now that takes us right back to this one here take out this and put in a different one as long as it does this we dont care thats a really key concept you can implement in a different way lets go back another slide back to this one okay again the architecture boundary with the software is here so if i change all this but this still knew this still implements the same architecture no problem everythings fine thats actually quite significant isnt it what does it mean for a company like intel whats the consequence of that significant statement that we just made whats the consequence for a company okay let me ask it again your intel and you know that out there theres six billion human beings that are running you know their code on your architecture does that mean that you can never change your chips for the rest of your companys life nothing can change doesnt mean that what does it mean it sounds like it means we cant have innovation is that true of course not intel is a very innovative company so how does intel manage to innovate yes right right exactly they can make this faster cheaper lower power than after a while started adding multiple cores etc et cetera the other thing that theyve done all companies do this they say look were keeping this the same but were going to add a little more and they they extend it but they dont change the core if they did software would stop running oh no it doesnt work what the new chips dont run the code ive been using this code for eight years i love my games i love my graphics i love my office set it means it doesnt work uh no sorry it doesnt work you have to get another version of the software no thank you i wont buy chips if they force me to change all my software i dont want to have to have a processor change force an entire software change too at least if i can avoid it that would be very disruptive to my organization to my company i think if youre a bank they say weve got a great new server itll be awesome youll get much better performance and your customers will love it its secure and it cant be hacked into great how much does it cost whats this performance wonderful oh just theres one problem none of your current software will run on it youll have to rewrite all your programs uh no thanks ill find somebody their vendor see this this idea about instruction set architecture is very very important we dont want to make existing software obsolete that would be a horrible thing yes architectures um is it like confliction between their instructions that architecture is different yeah theres been a theres been a inevitable pressure on yeah okay thats exactly the issue that were talking about its not pleasant it is its not nice to have to say oh my old programs dont work on this new architecture very difficult choice to say sorry guys were taking not this away were taking this away and you cant dance anymore because the new one isnt going to work you have to learn a different dance thats not very nice yeah companies that do that take big business risk and they can sometimes lose customers as a consequence of it um yeah the only thing you can do in that case is make the upgrade painless or as little painful as possible um otherwise people say thats it im not dealing with them and go over here or not or not upgrade or whatever theres theres a number of factors well talk about in this course um about that all right lets move on now the combination of that isa the basic instruction set and the operating system interface together is called the application binary interface so right where the operating system has a binary interface to the isa we call that the abi and thats the user portion of the instruction set plus the operating system interfaces that are used by application programmers and it defines a standard binary portable across all computers in other words the isa plus the operating systems support that is used by application programs if you piece them together now that can be portable and programs can be portable across all systems notice its not just the hardware because programs are calling on theyre running on the hardware but theyre also calling operating system lowlevel functions for support and together that pair is the abi application binary interface all right now back in 64 which is now what 45 years ago um three greats amdahl blau and brooks also famous each in their own right said the attributes of a computing system as seen by the programmer notice the programmers looking hey look at this floor im im walking on um are the instruction set architecture what are those attributes well its the structure and the functional behavior of the computer as distinct from the organization of how the data flows and how its controlled the logical design and the physical implementation distinct from different not that in other words the high level conceptual structure and functional behavior not the implementation this says organization its not that as distinct from any different from so back in 45 years ago they realized that the instruction set architecture is as the programmer sees the computer not as the designer sees the details okay so the isa is going to include these things as a programmer at the low level you need to know how much storage have i got how is it organized what data types are provided for by this machine um how do i encode and represent instructions uh what is the instruction set what are the op codes that i can choose from you mean you do have shift i mean you do have floating point operations great you mean you dont have you know whatever and there will be some and theres some that you didnt choose to include how do i address the items um or the instructions and and and uh what exception handling is visible to the program exception handling is when theres an error or an interrupt or a problem some of thats invisible but the part thats visible to the programmer also can everything is of this list thats visible to the programmer is called our isa all right um now again maura yesterday its pretty important you can tell because im staying on it the instruction set architecture is a is a crucial maybe the most important abstraction between the hardware and the lowest level of software and the reason its so important is it standardizes the interfaces the machine language bit patterns it suddenly defines the computer without telling all the details below it it tells the software heres what you have heres what you need to do and b to run on this computer the advantage is you can have different implementations of the same architecture intel then and intel now you know you can upgrade and also intel versus amd you know once you have an architecture and thats not the only example but thats the obvious one that we all know about once you have an architecture you can have different implementations of it the disadvantage is and it was raised here or is that your name yeah we raised it that sometimes it can prevent new innovations because youre staying conservative to your code base and you dont want to leave anybody behind and so it can prevent innovation in some ways unless you change the isa and some common instruction set architectures isas are as you will know ia32 and now ia 64 intel architecture 32 thats the one amd and other manufacturers have to follow if they want to be running that code powerpc architecture mips architecture spark arm and many others is there only one company making this is there only one company making this is there no multiple sources with different implementations they come compete with each other so thats the great thing about an architecture it just says heres the plan see how you can realize it heres the heres the platform you implement and some companies will have better designers and implement better than others all right lets take a really simplified instruction set architecture okay this is the mips isa very simplified for the computer programmer to understand it what does the computer programmer understand from this well ive got 32 registers that i can put data in and keep in as temporary storage ive got a another one called program counter and a high and a low register so the grand total seems to be 35 registers ive got some instructions loads and stores those go to and from memory ive got some computational instructions add subtract multiply divide i got jumping and branching instructions i have some floating point instructions for handling real numbers i have some memory management and some special instructions they have specifics but i dont want to show them to you right now so ive got these are my instructions these are my data storage resources other than main memory of course and then the instructions come in three formats so when i have a 32bit instruction its either the format where the op code is followed by one two three registers a source another source and a destination and then theres a shift amount and a function field or the op code is followed by two registers and a 16bit immediate field or the op code is followed by a very long jump target field okay so only three basic instruction formats six instruction categories with some members in each category and a view of the storage so you might say heres where the data can be and heres what i can do with the data in the instructions and heres what the instructions have to look like wow you just hold you you scared us with all those slides about isa we thought it was going to be core kunch hey its not too bad thats a simple isa its what the programmer needs to know at the low level to run machine instructions to run machine instructions i think you all know dont you that c plus plus instructions dont run on the computer java instructions dont run on the computer theres some levels of translation to get down to the instructions which do run on the computer you know you know that im sure that in the cs101 you talked about that so i think thats a good place to take a break so why dont we have a little you know 10 minute break here in between the two lessons and enjoy you know some fresh air and a glass of water or a stroll or a candy bar and well come back in 10 minutes okay so well see you then 