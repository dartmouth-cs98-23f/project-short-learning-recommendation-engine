the previous lecture we had looked at the basic building blocks which are required to construct the processor design we will now try to put these together to come up with a very simple design and later on we will look at the performance issues and try to improve the design so what we will do today is have a simplest possible solution to the problem of taking a set of instructions and having a circuit to execute those instructions so we will build this design in small steps that you can see each and every step clearly and get a clear picture of how the circuit is getting designed we will start with small set of instructions first we will take only r  class instructions which includes arithmetic logical and comparison add subtract and or and slt so that will be only part of the solution then we will add instruction by instruction and see how the whole thing can be built so with the basic skeleton of the design we will include other instructions step by step so first we will include load store instructions to the basic set of four five instructions and then we will include the jump and branch instructions so after having put the data path together we will try to see how you control it what actually is required in terms of control signals to make it do the right operation at the right time and we will interconnect a controller to this data path which we will build we will not go into detailed design of the controller that we will take up in the next class so once again let us look at the subset of the instructions which we have set out to consider for building this data path among the arithmetic and logical instructions we have this five add subtract two arithmetic instructions and or two logical instructions and slt which does the comparison so they are all of same class in the sense that they take two operands from registers perform some operation put the result in register then we come to load and store which access memory so basically the data is transferred between register file and memory one way or the other and then instructions which influence the flow of control beq which does a comparison and then decide which it go and jump which is a conditional jump instruction as i mentioned in the last class the whole design will have two parts the data path and the controller the signal which go from controller to the data path are called control signals and the signal which comes from data path to the controller is considered as a status signal so controller times the activities in the data path and also directs what has to be done in which clock cycle or which instant so the status signal is information the controller seeks from the data path to decide the actions now we are going to begin with these five instructions add subtract and or and slt the process involve or the actions which will be required would be to get the instruction from the memory taking program counter contents as address then depending upon the fields which contain register values we access the register file so the register the register addresses will come from the instruction fields and the operand which we get from register file are passed on to alu then the result produced by alu is passed on to the register file and we also increment the pc and make it ready for the next instruction so before we begin let us look at the format of these instructions the format has several fields a 6bit field is the opcode field and for all these instructions this is common there is a same there is a single code which actually defines this a larger group than this this is only a subset of all the instructions which have a common opcode here then there is a source register 5bit third register 5bit these two are the operands these two specify addresses of the operands and another 5bit field specifies the address of the destination so all these are numbers from 0 to 31 and specify one of the registers then this is unused in some instructions this is used to specify shift amount and it is this field which is called function field which will distinguish these five instructions from one another and also from other instructions which are part of the group so we would need to look at all the fields except for this field which is just to be ignored so the action begins by fetching an instruction from the program memory we have a program counter a register which will carry the address of the current instruction and there is an instruction memory instruction memory in this design will be assumed to be having fixed contents we are not going to change the contents so the only input to this is an address input and the only output is an instruction which come out of this so you given address instantly the instruction comes out we assume that the program is somehow stored in this memory already by some means in fact such memories are called read only memories if you are familiar with where by a special process you load the contents in the memory and then you can only access it you can read it so in that sense this will behave like a combinational circuit does not require a clock so you given an input you have an output but the function which transforms input and output is fixed and by a special process it can be changed therefore the pc feeds the address input of this memory and we get an instruction the next thing is to look at the instruction various fields in instruction and address the register file so particularly for these five instructions we are talking of we need to access rs and rt which was in second and third field in the instruction if you remember and bits of this 32bit instruction which we are getting would be used to address register file so register file as i discussed yesterday is specifically for this particular design we need register file as an array of register with a provision of reading two values at a time you can read two registers and you can write one register at any given time so now the addresses for these three things two readings and one writing is provided independently they could be in general different two or more also can coincide but a register file will respond correctly in all these cases the three address inputs are read address 1 read address 2 and write address these are the three inputs each of these are 5 bits there are two data outputs read data 1 and read data 2 and there is one data input write data hence we have instructions which is 32 bits so specific fields are being tapped out of this from bit number 21 to 25 this is rs the source register and that goes to one address bit number 16 to 20 forms a field which defines rt or the third register this goes and addresses rad2 or the second read address so out of these 32 bits we are taking two groups of 5 bits and connecting it to the register file now once addresses are given this register file will respond with data here and the operand which will come out of this will need to be passed on to the alu so we have an alu imagine the same design which we did couple of lectures back where by specifying some control signal you could perform addition subtraction and operation or operation you could do comparison for equality you could do comparison for less than for the purpose of slt so same alu we are putting now as a block box we are not looking into details of what is inside we understand that design and we are simply using it to build a larger circuit now so these two outputs are forming two inputs or two operands for the alu and next the result which is produced by alu would be have would be sent to register file for storage and that is where the cycle of flow of data or cycle of instruction would be complete so now at the moment i am not worrying about how to control alu to do the right function now we are looking at those five instructions together and alu would need to be told which of these instructions is so we will eventually when we talk of control we will look at bit number 26 to 31 the opcode field and bit number 0 to 5 bit number 0 to 5 the function field we will look at those fields and then pass on some signals to alu so that it does the right operation right now we are not distinguishing between those files but just looking at the overall flow of the data the output of the alu goes back to this register file to the right port let me just emphasis the terminology these are called ports for the register file port meaning there is something like a gateway so there are two read ports in this and then one write port and this is going back to the write port therefore now when we are writing we also need to arrange for the address where it has to be written so we need to look at another field from here and make sure that the address is also delivered correctly to the register file so bit number 11 to 15 are the destination address and that connects to the third address input so now with this the cycle is complete so basically starting with pc we have a sequential element here so at the edge of the clock a new value is available at the output of pc which defines address of a new instruction and as a function of that we get the instruction as a function of that we get these operand as a function of that we get the result and finally the result is available at the input of the register file therefore now at this point when a clock edge comes to the register file this information will get stored at that instant so we are assuming that transition in the state of register file would be edge triggered so you have one clock at which pc gets the value and at the next edge of the clock the result of this instruction will get stored in the register file and at the same time we will arrange we will see in the next slide that pc will have to get a new value and be ready for the next instruction so let us a complete that part and see how pc is to be incremented so all we need to do is have a 4 added to the pc contents and connect the result back to the input of pc this is an adder with one input as 4 one input as pc and output of this is going back to pc so you give let us say at time t the output of pc was available for a new instruction and then at time t plus 1 i am counting time in terms of clock cycles not in nanoseconds alone so at time t plus 1 which is the next clock you get a trigger here and trigger there so the current instruction completes by storing its value storing the result in register file and at the same time pc gets the new value and is ready for the next instruction so that completes one cycle and if the next instruction was also of the same type then in the next cycle that instruction will be executed so this cycle can go on and the important thing to note here is that the instruction is executed in one clock cycle remember that in the past we have talked of cpi and we have talked of figures of cpi which are 2 3 4 and so on so later on we will discuss design where instruction execution does take multiple cycles and there are good reasons why we would do that but currently this design is aimed at doing the instruction in a single cycle and that was the simple component which i was talking of we are talking of simple possible design now we have seen the design for these five instructions we need to now go further we need to augment this to include more instructions and we will see that by making small incremental changing we can accommodate more and more instructions so let us address load and store instruction next the common thing there is that memory has to be accessed and the mechanism mechanism for calculation of memory address is same you have to take this number which is the signed offset 16bit number and contents of this register add the two and apply that as address for the memory and this field defines the register which will exchange the data with the memory depending upon whether it is load or store so we need to look at these two registers specified by these two fields and a constant here is a same design we have done so far and now we will add more things to it to make it possible to do store instruction we will then add load instruction so first of all we need to bring in data memory unlike instruction memory this will have data input as well and that is actually the only difference you have address read port write port well actually strictly speaking this will be considered it will not be considered as two port memory it will be considered a one port memory because you either do read or write there is a single address and we will define control signals which will ensure that either you either you perform a read or write so it is a single port memory but it can do read or write whereas this is a three port memory two read ports and one write port this one has a single read write port in fact some memory modules have these in common there is a same set of wires which are connected to memory through which you can send the data in or take the data out so that data terminal is a bidirectional one there is one address line and a bidirectional data line in this case of course again for simplicity we have separate read and write lines but there is a common address line this is also a single port memory with a single read port and that is all now we have positioned the memory here we now need to connect the inputs and outputs for this so first of all the address as i mentioned will be produced by performing an addition so we will use alu for doing the same thing because load store instruction does not require other arithmetic operations to be performed we will use this alu itself to calculate the address for doing pc plus 4 we could not used this because we had instructions which were using for some other purpose and this pc plus 4 was being done over and above all that so we required a different piece of hardware here but for load store instruction we will use alu to do the address calculation and therefore i have connected it in this manner i need to make sure that the right inputs come to the alu for calculating address and that is the next thing so we do not directly connect register file output to alu because for address calculation the constant coming from instruction will be loaded we need to put a multiplexer here which will have this rd2 output for r  class of instruction but it will have something coming from this for performing address calculation i have not connected it yet here because those 16bits which we get from instructions need to be sign extended before we can pass it on to alu this is the block which is doing signed extension it takes 16bits as input bit number 0 to 15 of the instruction and it does sign extension so here it is a 32bit output wherever i have not labeled things assume that you have 32bit output 32bit signals each wire is actually carrying 32 bits exceptions are here where i have labeled explicitly or here i have also indicated that there are 16bits explicitly so now you see what is happening that rs specified by this field would bring out some 32bit number here 16bit taken from here sign extended and we will control the multiplexer to select this path when it is load or store it is this path which will be selected so we must give input one to the multiplexer control input one and for add subtract instructions we must give zero so that this goes in so wherever we have actually two paths converging to the same destination you will notice that we have put a multiplexer and then it is the responsibility of controller to control this multiplexer correctly so that depending upon what we are trying do the right thing gets done or the right data gets passed through that multiplexer this part takes care of inputs for data memory address input in particular so it comes from here and inputs of the adder inputs of the alu are also arranged now properly to complete the picture we also have to make sure that the data from register file goes to the data input of this memory so where does it come from in this diagram where will the data come from which will have to be connected to this wd because it is a rt the third field which actually specifies which register has to be written so that is already happening here and that output is available here we simply need to connect this to this now this is the complete arrangement for performing store word instruction and now we can move to the load word instruction now in the load word the address generation part is same that we do not need to touch this is same same mechanism same paths and that need not be modified what additional thing we need to do for load word is to take the data from data memory and put it back in register file at appropriate address so first of all we have this line going to wd write data of the register file so we have broken this here so that we can take this and this and put a multiplexer so there two options are and they need to be joined with a multiplexer so this multiplexer when you give control as 1 then it will send this to the register file and when the control is 0 it sends this to the register file so we will have to remember that for add subtract and or instructions the control has to be 0 and for load instruction control has to be 1 here so this is one part of the picture the second part of the picture is to give the correct write address the write address comes from now let us figure out from where the write address has to come see for addsubtract instruction write address is coming from this part bit number 15 to 11 to 15 and for this it will come from bit number 16 to 20 for load instruction it is rt which is to be used here for add subtract it is the rd which decides the right destination now it is rt which will do it so again we need to make changes here introduce a multiplexer because it is either bit 11 to 15 which goes there or bit number 16 to 20 which goes there so we have to make a provision for that we remove this line and put it through a multiplexer and the two choices are either this or that this is the choice which will be taken for load instruction and this is the choice which is taken for add subtract and or slt instructions so now we complete thethis is the complete picture for now seven instructions we have done add subtract and or slt and load store so everything which is required for these as far as data path is concerned is there now let us look at branch and jump instruction again we will take one by one they would need to do something with the program counter because these instructions influence how the next instruction is chosen we did not modify this part for load store because this part continues to be same you have one instruction and the next instruction follows but for branch instruction we need to modify this and also we will use alu for equality test the comparison will be done and alu will produce a bit which will indicate whether the two inputs are equal or unequal the branch instruction has this format opcode this is the i  format as we have for load store rs and rt are the two registers which will be compared and this number would be added as word offset to pc and it will be pc plus 4 to which will be add because that part we want to retain as common for all the instructions so again start from this point where we have come up to we need to do some modification here instead of sending pc plus 4 back directly to pc we will introduce more options and the options would be that this with something added to it now let us look carefully first of all this is a multiplexer which is making a choice either we take pc plus 4 or we take output of this adder which is adding something to pc plus 4 what is that we are adding we are adding this 16bit constant which has been sign extended but it is also been shifted this s2 i am using to shift this number by 2 bits to the left which is effectively multiplying by 4 and getting a byte number from word number therefore as i had discussed earlier it is a matter of simply wiring things correctly we have the correct offset coming here with gets added to pc plus 4 and is available to this multiplexer now this multiplexer has to look at which instruction it is if it is not branch instruction it will simply allow this to go through if it is branch instructions then it looks at the result of comparison in the alu and accordingly a 0 or 1 will be chosen here hence again we will get into those details when we discuss the control but for the moment we assume that somehow there will be some logic put together which will take care that the correct value 0 1 is given here so as far as the data path is concerned what we have introduced here essentially is one multiplexer and one adder and these wiring of signals so that a shift of 2 bits takes place now just to remind you we had seen that signed extension and shifting are essentially wiring there is no active gate or any active component involved sign extension means repeating one particular bit and shifting means just rearranging these and supplying a constant zero to some of the bits so in the previous diagram the sign extension and the shift are essentially these kinds of wiring arrangements now finally we come into this jump instruction jump instruction has only two fields the opcode field and a 26bit field which decides the next address once again since it is not a full 32bit address we need to retain some bits of pc as it is so what we will do is we will take these 26 bits and 4 bits from pc plus 4 again not pc and form a new address for the next instruction so we would require another multiplexer which will provide one additional choice we introduce that multiplexer here remove this line and pass through a multiplexer and the input for this multiplexer is coming from instruction bits we are taking these 26 bits from the instruction field shift it left by two positions to get 28 again for the same reason we want to get byte from the word number 4 bits we are picking from pc plus 4 bit number 28 to 31 and these 4 bits and these 28 bits are concatenated together to form a jump address which is a 32bit value and this is available as yet another input for going back to the program counters the program counter pc has three possibilities either it is plain pc plus 4 or this pc plus 4 plus offset or this combination of pc bits and instruction bits you can actually combine these two multiplexers into a single three input multiplexer that is another way of designing but we will just retain it in this manner now the next thing is to start worrying about how we are going to control this data path what are the points where we need to apply control signals so that is what we will see next all multiplexers would require control and in this exercise of identifying controls we will assign names for the purpose of reference for all the control signals so we will call this control signals for this multiplexer as rdsd or register file destination it will select the destination address in the register file it comes from here or from here then register file needs a control signal to tell it whether it has to write or not all instructions you would notice are not writing into register file so it is only first five instructions write and load instruction these six instructions out of the nine write into the register file so this will have to be made 0 or 1 accordingly alu source which i am labeling as a source is the control signal for this multiplexer and this will distinguish whether alu is being used for address calculation or for normal arithmetic logical operations alu would require 3 bits to control it recall the design of alu which we have done we had some circuit and then at the end there was a 4 input multiplexer which will select and output or output or plus minus output or output for slt so 2 bits are required to control that and another bit to choose between add subtract so there were a total of 3 bits so i am labeling that as op standing for operation then a status output which will come from alu i am labeling it as z standing for 0 so it is a comparison of the two operands from the point of view beq instruction comparison you recall was done by doing subtraction and checking of the result is 0 so that is why i have labeled it as z this is not an input this is an output this is the status and others are the control data memory requires control for read or write so mr stands for memory read mw stands for memory write we will make sure that memory does only one operation at a time actually in this kind of arrangement where read and write lines are separate it is also possible that you do read and write simultaneously in this but it has to be from the same address same location in the memory is used for reading and writing simultaneously but in our design we do not do that we will either do read or write then there is another multiplexer here which is distinguishing between what goes to register file whether it is from memory or from alu so memory to register file m2r this is called p source pc source basically either here or there then whether it is jump instruction or not it is another control signal hence these are the control signals so we require some circuit which will produce so many outputs 1 2 3 plus 3 6 7 8 9 10 11 so these 11 outputs and that control will have to look at this and also look at two fields of the instruction the opcode field and the function field so that is the controller which needs to be designed it has to have this 12 inputs in fact strictly speaking it is plus 1 so 13 inputs and 11 outputs so if you can design that and plug it in here that will complete the task but we will not design it as a monolithic circuit we will design it again in terms of some simpler parts as you will see now now you want to bring in the controller we will not go into details but we will just go through an outline of what it is going to be first of all we look at the opcode bits and these bits are sufficient to distinguish between jump branch load store and this group of add subtract etc altogether so except for controlling alu from these 6 bits we can derive all the information out of the eleven signals eight can be straightaway figured out using these of course generating this will require us to look at z also so let us connect the output of this control i will show the outputs and connect to various signals which can be driven by this if it is load instruction which we can figure out from here we will allow this to pass through here otherwise we will allow this to pass through so this hardness can be determined from this whether we have to write register file or not can be determined from this alu source can be selected it can be determined from this memory write and memory read so if it is load instruction we will do memory read if it is store instruction we will do memory write then control of this multiplexer it has to distinguish between load from other instructions so that also can be done here we are doing slightly differently we are first of all figuring out that it is a branch instruction so this controller will activate a signal which tells us that it is a branch instruction with the z output to control this p source so you can see what is happening if the instruction is not a branch instruction you will have a zero here which means that p source is 0 irrespective of what is z and the multiplexer passes the upper input so when it is not a branch instruction we do not branch we do not even look at z when it is branch instruction we will have this as 1 the controller will make this output as 1 now it will depend upon z we will get 1 here or 0 here so if the result of comparison was true if the two registers are equal this will be activated this will be 1 and you will get a 1 here so this address will go as the next address of pc next value of pc and if the test failed then this will be 0 you will have a 0 and pc plus 4 will continue another way if you recall the gross diagram i had drawn where there was a data path and the controller i had shown the status signal going to the controller so strictly speaking the controller is not just this it is this plus this but it actually simplifies the matter to look at it as a 6 input circuit rather than a 7 input circuit because the influence of this has been handled separately which makes it somewhat convenient then we can also control this multiplexer by figuring out whether it is a jump instruction or not now what is left is the opcode an operation which the alu has to perform and it will depend upon 6 bits which come from the function field so the instruction 0 to 5 would be seen by another kind of control circuit i am calling it a controller alu control so looking at these 6 bits we are trying to determine what these 3 bits are but remember that alu is being used for load store instruction also for different purposes so we need to look at this also but we do not need to feed all those 6 bits here but what we need to tell this circuit is which class of instruction it is whether it is r  class one of those instructions or it is load store or something else so we will have some information coming out from here connecting to this and this needs to be just a 2 bit information because we like to distinguish between three different cases the r class instruction add subtract and or and slt that is one possibility load store together grouped as another possibility and all the rest as third possibility so we will take 2 bits out of this and connect to this and i am calling it opc which stands for operation class so basically this circuit now has 6 inputs plus 2 inputs so 8 inputs producing 3 outputs so we have taken special care to keep the number of inputs low so the complexity of a combinational circuit like this or like that depends upon the number of input lines and number of output lines but i will not i will not explain that but you can take it that with the number of input lines the size of the circuit or the complexity grows generally exponentially but with outputs it will generally grow linearly so we are more worried about keeping the numbers of inputs as low as possible so if there are large numbers of inputs then we can look at the parts of it separately and then combine the results that are always a better strategy that is what we have followed this circuit is predominantly looking at the opcode field whereas this is predominantly looking at the function field and some additional information it requires about opcode is being actually processed by this and made available here so after having done this what remains is basically to look at the design of this and design of this so if you can enumerate what outputs you require for what inputs you can do it in a straightforward manner and same thing here we will take it up in the next class so just to summarize we have designed a processor except for some controller details for these nine instructions add subtract and or slt load word store word beq and j and our approach was a very simple step by step approach we gradually put the components on the table connect wires and build up the circuits so first we took this group of first five instructions which are similar in nature the only difference comes in the way you control the alu so we did that we started with these five added store and load and then added beq and jump then we identified the control signals for the various components which were put there and we placed some black boxes which are called controllers which expected to produce these signals and the next task will be to look at the details of these two black boxes and design this that is all for today thank you 