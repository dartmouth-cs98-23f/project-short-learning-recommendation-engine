now sort them in alphabetical order computers have to do stuff like this all the time its a seemingly simple requirement that can be accomplished with dozens of different sorting algorithms all of which have tradeoffs with no one optimal approach modern languages have builtin functions to do the heavy lifting for you but you wont always have that luxury on a technical interview or when doing lowlevel systems programming in todays video well not only implement seven different sorting algorithms and code but also see and hear them in action thanks to an amazing project called the sound of sorting if youre preparing for a technical interview these visualizations and audibilizations will absolutely change your life major props to teemo bing men were releasing these videos under creative commons so we can use them in videos like this im going to implement my algorithms in javascript and then benchmark them at the end and you can find the source code on github but first i want to check out an amazing product from our sponsor jetbrains mps to the average developer building a custom programming language sounds like an impossible challenge however with this open source ide from jetbrains anyone can build their own domainspecific language like meta r which is a highly specialized language for biomedical students who would otherwise have to learn how to program in r jetbrains mps is a logical editor as opposed to a text editor allowing end users to interact with the code visually this allows nonprogrammers to easily integrate their own domain logic then mps will generate the code for the underlying platform like c javascript or any other language that means anyone in the organization can harness the power of code in a safe easy to learn environment along with all the awesome tooling you would expect like code completion debuggers and more to get started simply download it for free and give it a try now back to the program the first album rhythm will implement is bubble sort which in my opinion is the easiest one to wrap your head around it works by comparing adjacent elements then swaps them if theyre in the wrong order which allows smaller elements to bubble to the top of the list first well set up a for loop for the length of the array inside of which well nest another loop that loops over the array minus the current index in this loop we can do swapping by comparing the current index to the one next to it if the left side is greater than the right side then theyll need to trade places if the process continues until we go through the entire outer loop and heres what it looks like oh bubble sort is intuitive but not very performant its average time complexity is o of n squared or quadratic time which gets slower and slower as the list grows longer this wont cut it in the real world another fairly easy option to implement is insertion sort which builds up a sorted array one element at a time but once again we start with a loop but this time we start at index 1 or the second value in the array we then set up variables for the current value and previous index and while the previous index is greater than the current value we move the previous value to the right then we move to the left until we find a previous value that is smaller at which point we can insert the current element heres what it looks like in action foreign once again we have a nested loop here which results in quadratic time complexity but in practice it can still be pretty fast if the input data is already mostly sorted another similar approach is selection sort it works by finding the smallest element in the array and exchanges it with the element at the beginning then repeats this process until its fully sorted once again we loop over the entire array and then add a nested loop inside of it but this time were looking for the minimum value in the subarray in this nested loop if the minimum value doesnt equal the current value then we swap them out which will effectively put the smallest element in the proper position then repeat that process across the entire array but lets check it out foreign applause also results in quadratic time next up we have merge sort which is a divide and conquer algorithm thats been around since the 1940s the idea is to break the main array into subarrays sort them and then merge them back together unlike the other examples weve looked at this one is implemented recursively first the recursive function finds the midpoint of the array then we have a base case here that will stop the loop when the array length is less than two we then break the array in half at the midpoint using splice and then we call the same function on both halves but in order for that to work well also need to implement a merge function that does the actual sorting it loops over both arrays simultaneously compares their values and adds them in order to a new array then finally it merges everything back together heres how it looks oh its a bit more complex to implement but performs much better at quasilinear time thats why a variation of merge sort is the algorithm implemented under the hood for array sort in javascript as well as many other languages and applications one drawback though is that it doesnt sort in place and requires extra memory if thats a problem a similar alternative option is quick sort its also a divide and conquer algorithm that uses a pivot element to create subarrays that are sorted recursively with quicksort the array isnt necessarily split in half and works with any ratio to sort the array in place well first create a function called partition its job is to divide the array into two parts to separate the elements smaller than the pivot from the values greater than the pivot in this case the pivot value is set to the element at the right index of the array from there we loop over the portion of the array between the left and right values if a value is less than the pivot value then we swap it with the element at the partition index from there we can create a recursive function called quick sort to divide and conquer both the left and right side of the array this is the more proper way to implement quicksort but we can illustrate the concept a little better by cheating in this more simplified function notice how im first determining a pivot point on the array then we divide and conquer by filtering out items that are less than the pivot on the left side and items that are more than the pivot on the right side now call that recursively to sort the entire array that works but it wont perform as well as the previous implementation in any case lets go ahead and watch it on tv thank you music next up we have radix sort which was created all the way back in the 1800s for tabulating machines its still used today on values like integers or binary strings because it takes a unique approach where it groups items that share the same significant position or place value the implementation is a bit more complex but basically it works like this it splits the elements of the array into 10 buckets one for each digit 0 through 9 it then loops over those buckets and has a nested loop for the array itself get digit will then find the number at that place going from 0 to 9 which provides a bunch of sorted buckets that are combined back into the original array whats interesting here is that theres no direct comparison going on were only looking at the underlying digits this implementation is called lsd or least significant digit but its also possible to work in the other direction with most significant digit thats pretty cool lets check it out oh music and finally i saved the worst for last bogo sword also known as stupid sword this would be like if you had a deck of cards and kept shuffling them over and over again and just hope that one time theyre in perfect order its totally random to implement it i have a helper function called shuffle that takes the array and randomizes all the elements with the math random function then i have another helper function that loops over the array to determine if its sorted or not then we simply put those two together in a while loop until we get a sorted array not surprisingly it looks pretty wonky to finish things up i made a quick benchmark just to test these implementations and heres how everything played out bubble sword and cocktail shaker sort were near the bottom well heap shell and quicksort were near the top but it really depends on what youre sorting this graphic from top towel illustrates how different types of input data change the performance characteristics of these algorithms a10x engineer needs to understand the tradeoffs and implement the optimal algorithm luckily for most of us we can get by with a race sword so basically everything you learn in this video is completely useless on a practical level thanks for watching and i will see you in the next one 