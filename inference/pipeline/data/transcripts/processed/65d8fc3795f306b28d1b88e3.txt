course taught by tobias günther   hell help you move beyond git  basics and improve your git workflow   hello free code camp friends my name is tobias  and im going to improve your git knowledge today   there are a lot of beginner tutorials  out there about version control with git   but i will help you understand the  concepts behind many things in git   how to craft the perfect commit how to  choose a branching strategy or how merge   conflicts really work so my goal is to give  you more confidence when you work with git   and to get you a little bit closer  to becoming an advanced git user   before we start a huge shout out to the free  code camp team thank you so much for being on   this mission of teaching people how to code and  thanks for letting me contribute a little bit   a couple of words about my own background im  part of the team behind tower and tower is a   git desktop gui for mac and windows weve been  around for more than 10 years now and helped over   100000 developers and designers well work more  easily with git become more productive with git   and make fewer mistakes for todays session  you dont need to have tower installed   you can follow along on the command line  no problem alright lets get started   so lets talk a bit about how to create the  perfect commit so the first part is to add the   right changes right and the second part is to  compose a good commit message so lets start by   lets start by adding changes to the  commit so our goal here is to create   a commit that makes sense one that only  includes changes from a single topic   and in contrast to the easy way when we  sometimes just cram all of our current   local changes into the next commit so this  is the bad thing we should not do but being   selective and carefully deciding what should  go into the next commit is really important   this is a better way of how a better commit could  look like because it separates different topics   on the other hand the bigger a commit gets and  the more topics that are mixed into the commit   the harder it gets to understand both for your  colleagues and for yourself in the future so   git staging area concept is really helpful in this  context it allows you to select specific files   or even parts of those files for the next commit  so this is what the staging area can do for you   you can really select individual files for one  commit and even parts of files for one commit   and leave others for future commit so lets take  a look at a practical example and over the last   few hours or maybe even days weve created  a bunch of changes lets say git status here   but lets say that not all of those are  about the same topic so lets stick to   that golden rule of version control to  only combine changes from the same topic   in a single commit and you probably already know  that to include a specific file we can simply   type git add and the name of the file so lets  add that css file here and voila and lets take   a closer look at another file index html and see  what changes it currently contains so we can   use git diff for that and we can see that there  are two parts or chunks of changes at the moment   and lets say that the first one belongs to the  next commits topic but not the second one so   lets just add the first part to the staging  area we can do that let me just exit the   output here we can do that with the git add git  add dash p flag p brings us down to the patch   level we want to decide on the patch level what  to include and what not and we want to do that   with index html so now git steps through every  every single chunk of changes with us and it   asks us a simple question do we want to add  this chunk or hunk to the staging area or not   dont worry about all the other possible answers  you can give in that situation i dont know them   and i want to sleep at night for us a simple  why for yes or n for no is sufficient so lets   say this one is actually the topic that we want to  commit so lets say yes we want to include that   and and for the second one this is not the  same topic so lets leave that out of the   staging area for the moment so if we now take  another look at git status we can see that   parts of index html will be included in the next  commit changes to be committed and other parts   will be left for a future commit again so index  html is listed twice awesome crafting a commit   like this in a very granular way will help you  create a very valuable commit history one that   is easy to read and to understand and this is  crucial if you want to stay on top of things   now lets talk about the second part of creating  that perfect commit and that is providing great   commit message well start with the subject line  so of course conventions are different between   teams but generally the advice is to write  something very concise less than 80 characters if   possible and the subject should be a very brief  summary of what happened and heres a little   hint if you have trouble writing something short  and concise then this might be an indication that   youve put too many different topics into that  commit right so lets go to the command line   and if i now type so i have a couple of  changes against stage for the next commit   if i type git commit i will get an editor  window where i can enter a commit message   and well write something simple  ad capture for email signup   if we add an empty line after the subject get  knows we are writing the body of the message and   has room for a much more detailed explanation so  here are a couple of questions you might want to   answer with your commit message body this  year whats now different than before   whats the reason for the change and is there  anything to watch out for or anything particularly   remarkable about that commit so ill write my  version of that in the text editor here and   voila so lets save and close  this and the commit is done   lets take a quick look at git log and we can  see okay so this is the last commit we just did   this is the subject and this is the  body of the message so by answering   these questions youre doing your colleagues  and your future self a huge favor because   it helps to understand what exactly happened  in this revision and what to watch out for   lets talk a bit about branching strategies  this is an important topic because git leaves it   completely up to you how you want to work with  branches it only provides the tool but you   and your team are responsible for using it in the  optimal way and this brings us to our first topic   conventions if you work in a team you need to  come up with a clear convention on how to how   you want to work with branches and you need to  write this down somewhere where its accessible to   everyone why your team needs a written convention  you ask because git allows you to create branches   but it doesnt tell you how to use you need  a written best practice of how to work or how   work is ideally structured in your team to avoid  mistakes and collisions and this highly depends   on your team and team size on your project and  how you handle releases of your software last not   least it helps to onboard new team members when  new people join your team you can point them to   your documented will convention and will quickly  understand how branches are handled in your team   when you think about how you want to work  with branches you automatically think   about how you integrate changes and structure  releases these topics are tightly connected   to help you better understand your  options lets simplify a little bit   ill show you how to extreme versions  of how you could design your branching   workflows and the motto of the first one is  always be integrating mainline development   always integrate your own work with the  work of the team thats the motto here   and this is how it could look in this  example we only have a single branch   where everyone contributes their commits so  this is a really simple for example i doubt   that any team in the real world would have such  simple branching structure but for illustration   this extreme simplified example helps us  understand the advantages and disadvantages   of this model so in an always be integrating  model you have very few branches and this makes   it easier to keep track of things in your project  of course also commits in this model must be   relatively small this is a natural requirement  because you cannot risk big bloated commits   in such an environment where things are  constantly integrated into production code   and this also means that you must have a high  quality testing environment setup again   the premise in this model is that code is  integrated very quickly into your main line   your production code and this means that testing  and qa standards in your team must be top notch   if you dont have this this model will not  work for you the other end of the spectrum   is when multiple different types of branches  enter the stage so here branches are used   to fill to fulfill different jobs new features  and experiments are kept in their own branches   releases can be planned and managed it managed  in their own branches and even different states   in your development flow like production  develop can be represented by branches   remember that this all depends on the needs  and requirements of your team and project   its hard to say that one approach is better  than the other and although a model like   this one seems complicated its mostly a  matter of practice and getting used to it   and as i already said in reality most teams  are working somewhere in between these extremes   now lets look closer at two main types  of branches and how they are used   these two types of branches are long  running and short lived branches   so the distinction between a long  running and a short lived branch   is one of the broadest you can make and a  very helpful one so lets start about talking   about the long running branches first every  git repository contains at least one long   running branch typically something called main or  master but there might be also other long running   branches in your project something like develop  or production or staging for example these   branches all have something in common they exist  throughout the complete lifecycle of the project   ive already mentioned one typical example of  such a long running branch every project has a   mainline branch like master or main and another  type of long running branches are so called   integration branches often named develop or  staging typically these branches represent   states in a project release or deployment process  if your code moves through different states   for example from development to staging to  production it makes a lot of sense to mirror the   structure in your branches to and finally many  teams have a convention connected to long running   branches typically commits are never directly  added to these branches commits should only make   it to the long running branch through integration  in other words through a merge or rebase   there are a couple of reasons for such a rule  one has to do with quality you dont want to   add untested and reviewed code to your production  environment as an example and thats why code   should go through different states tests and  reviews before finally arrives on production   another reason might be release bundling and  scheduling you might want to release new code   in batches maybe even thoroughly scheduled  and without such a rule when code is directly   committed to long running branches like main  keeping an eye on whats released becomes pretty   difficult now the other type of branches are  short lived branches and in contrast to long   running branches they are created for certain  purposes and then deleted after they have been   integrated there are many different reasons  to create short live branches for example   when you start working on a new feature a bug  fix or refactor refactoring or an experiment and   typically a short lived branch will be based on a  long running branch for example when you start   a new feature you might base that new feature  on your long running main branch for example   and after making some commits and finishing  your work you probably want to re integrate it   back into main and after youve safely merged or  rebased it your feature branch can be deleted and   ive already said that branching strategies  will be different for each team and project   it highly depends on your preferences  or team size or type of project   but id like to give you a glimpse into two  pretty popular branching strategies and take both   of them as inspiration for your own individual  branching strategy lets start with github flow   github advocates a workflow thats extremely  lean and simple it only has a single long   running branch the default main branch and  anything youre actively working on is done in   a separate branch a short left branch no matter  if thats a feature a bug fix or a factoring   so this is a very simple very lean setup another  very popular model is called git flow and this   offers a bit more structure but also more rules to  follow so the main branch is a reflection of the   current production state the other long running  branch is typically typically called develop   in any feature branches start from  this one and will be merged back   into it develop is also the starting point  for any new releases you would open a new   release branch do your testing commit  any bug fixes to that release branch   and once youre confident that its ready  for production you merge it back into   main you would then add a tag for that release  commit on main and close the release branch   as you can see good flow defines quite a  couple of tasks and steps in the process   in tower the good desktop gui that we make  we support users by offering these tasks as   shortcuts in the app and that way i can show  you here so you have all of the most important   actions that git flow brings to you so you  dont have to remember all of the bits and   pieces and what you have to do and what comes  next that makeup these different steps   so if you ask different teams how they are using  branches you will get many different answers   there is no perfect branching model that everyone  should adopt its more about understanding your   project your release workflow and your team  and then modeling a branching workflow that   supports you in the best way possible lets talk  about pull requests first of all you need to   understand that pull requests are not a core good  feature there are provided by your git hosting   platform which means they work and look a little  bit differently on github git lab bitbucket   azure devops or whatever youre using but the  basic principles and ideas are always the same   lets start by talking about why you would  want to use pull requests at all in essence   they are a way to communicate about code and  review it the perfect example is when youve   finished working on a feature without a pull  request youd simply merge your code into main   master or some other branch and in some cases  this might be totally fine but especially when   your changes are a bit more complex or a bit  more important you might want to have a second   pair of eyes look over your code and this  is exactly what pull requests were made for   with pull requests you can invite other people  to review your work and give you feedback   and after some conversation about the code  your reviewer might approve the pull request and   merge it into another branch apart from this  theres another important use case for pull   requests its a way to contribute to code to  repositories which you dont have right access   to think of a popular open source repository you  might have an idea for improving something but   youre not one of the main contributors and youre  not allowed to push commits to their repository   this is another use case for pull requests and we  also have to talk about forks in this connection   of fork is your personal copy of a git repository  and going back to our open source example   you can fork the original repository  make changes in your forked version and   open a pull request to include those  changes into the original repository   and one of the main contributors can then review  your changes and decide to include them or not   i already mentioned it every good platform has  its own design and understanding of how pull   requests should work and they look a little  bit different on github git lab bitbucket or   azure devops or whatever youre using so here  is an example well use the github interface   for this test case lets use the ruby on  rails open source repository and lets see   alright so here we are on github on the ruby  on rails main repository and in the top right   i can fork this repository so i can create  my own personal version of the repository   and its code base and again a reminder  about why were doing this i dont have   access to push code into ruby on rails into the  ruby on rails repository and for good reasons   of course because im not a ruby on rails pro  but in my own fork repository i can make changes   i can make whatever changes i want so i just  did that i forked the repository and i can now   simply clone that ill get the clone url and then  on the command line git clone and remote url   and we will in a second when  this has finished cloning   we will create a branch and make some changes so  this is also important to understand pull requests   are always based on branches  not on individual commits   so were creating a new branch which we later  request to be included and lets ogburn   lets go into rails and open this in my editor  and ill just create a brief branch git branch   test and git checkout test alright  so i now am on a new branch and can   make a silly little change lets change  something in the readme file this is a   an awesome web application framework close  this alright lets take a look at our changes   git add readme and git commit dash m silly   little change so we now have made some small  changes on a separate branch and we can push that   branch to our own remote repository our fork  so git push set upstream origin tests test and   once this is available okay so this has worked  so we have now created the changes that we can   request to be included once ive pushed  them to my remote repository on github   i can take another look at the repository  in the browser and see what happened   and voila github has noticed that i just pushed  something here and since its a fork of forked   repository github detected my changes and  automatically asks me if i want to create a pull   request with those changes because in a forked  environment this is mostly what you want to do   and if i do i can propose which branch they  should be integrated in so ill start the   pull request process here so at the moment im  proposing to integrate my changes from my little   branch here in the fork back into the main branch  in rails and lets say that is okay and i can   add some comment and i could then create the  pull request and the maintainer of the original   repository would then be notified and they can  review my changes and possibly integrate them   merge conflicts nobody likes them  but they are a fact of life when youre   working with git and in most cases they  are not as tragic as we often think oh   well talk about when they happen what  they actually are and how to solve them   alright so the name already says it merge  conflicts can occur when you integrate when your   merge changes from a different source but keep  in mind that integration is not limited to only   merging branches conflicts can also happen when  rebasing interactive rebasing when performing a   cherry pick or a pull or even when reapplying  a stash and all of these actions performed   some kind of integration and thats when merge  conflicts can happen of course these actions   dont result in a merge conflict every time  thank god but when exactly do conflicts occur   actually gets merging capabilities are one of its  greatest features and advantages merging branches   works effortlessly most of the time because git  is usually able to figure things out on its own   but there are situations where contradictory  changes were made and thats when technology   simply cannot decide whats right or wrong  these situations require a decision from a human   the true classic is when the exact  same line of code was changed into   commits on two different branches git has  no way of knowing which change you prefer   there are some other similar situations  that are a little bit less common   for example when a file was modified  in one branch and deleted in another   but the same but the problem is always the  same changes contradict when youre working   with a desktop gui like tower forget that  can make things easier especially because its   just more visual i can select things here and  this helps me understand what actually happens   i can see these two changes conflict and i  can select one or both or just this year and   solve the conflict pretty easily how do  you know when a conflict has occurred   dont worry about that get will tell you very  clearly when a conflict has happened first   it will let you know immediately in the  situation for example when a merge or rebase   fails with a conflict so lets try this  out actually we have something here lets   provoke a merge conflict and ill just try  to merge in developer to my main branch   and voila automatically i can see something is  wrong here conflict conflict conflict automatic   merge failed so you can see that when i tried  to perform the merge i ran into conflict and get   tells me instantaneously about the problem but  even while even if i had overlooked these warning   messages i would find out about the conflict  the next time i run git status so lets do that   and pretty quickly you have this unmerged path  category in the status here so in other words   dont worry about not noticing merge conflicts  get makes sure you cant overlook them   all right um though you  cant ignore a merge conflict   you really have to deal with it  before you can continue your work   dealing with a merge conflict doesnt necessarily  mean you have to resolve it you can also undo   it and this is sometimes very helpful so keep  this in mind always you can always undo a merge   conflict and return to the state before and  this is true even when youve already started   resolving some of the conflicted files and you  notice oh god im im on the wrong track here   even then when you find yourself in a  dead end you can still undo the merge   and some commands come with an abort option that  lets you do exactly that so the most prominent   examples are git merge uber abort and git rebase  abort so in our example here when i find why   i dont have the time to deal with this right  now or ive resolved something the wrong way   i can always type git merge dash dash abort here  and get status shows me im back to normal again   so this should give you the confidence that you  really cannot mess up you can always aboard   return to clean state and try again start  over so lets see what a conflict really   looks like under the hood we will  demystify those little buggers and   at the same time help you lose respect for  them and gain a little bit of confidence   so as an example lets look at the contents  of one of the conflict files ill provoke that   merge conflict once again and i can see that  in my index html file i have a conflict so   lets take a look at that and  nope not this one but this one   so get was kind enough to mark the problematic  areas in the file so theyre surrounded by these   symbols here this is the start and this is the  end of the problem area so the content that   came that comes after the first marker originally  originates from our current working branch then   aligned with some equal lines equal signs  separates the two conflicting changes and   finally this year came from the other branch  thats displayed as well so in this case   its pretty simple in the develop branch  where i made some changes i deleted this   list item these list items and in my head  branch i changed them so git is unsure   did you want to change them like like  this or did you want to delete them   like here and i have to tell git  whats correct and whats not   okay so how can you solve a conflict solving  the conflict is actually pretty simple we need   to clean up these lines and after we finish the  file should look exactly as we want it to look   so it might be necessary to talk to the teammate  who wrote the other changes and decide which code   is actually correct maybe its ours maybe its  theirs maybe its a mixture between the two   and this process of cleaning up the file making  sure it contains the what we actually want this   doesnt have to involve any magic you can do this  simply by opening your text editor or id and make   some changes sometimes though youll find that  this is not the most efficient way thats when   dedicated tools can save you a little bit time and  effort so on the one hand there are good desktop   gooeys some of the graphical user interfaces for  good can be helpful when solving conflicts youve   already seen one so this is tower where you could  where you can see what happened in the conflict   and this visualizes the problem and on the  other hand there are dedicated merge tools   for more complicated conflicts can be great to  have a dedicated different merge tool at hand   you can configure a tool of choice using the git  config command and then in case of a conflict   you can simply type git merge tool and have it  open the conflict i have a kaleidoscope app   installed on my mac so lets just try this git  merge tool i configured that so the first one   as you can see is a pretty easy one or the  second one here error html was deleted so   i dont need to see that i just need to decide  do i want to keep it or do i want to delete it   so ill stick with the deletion and for the  second one theres really content in the file   where it makes sense to open that merge tool  that i configured i can see well this is   the the change that i made and this is the change  that came from another person or from a different   branch and what do i want to look like and what  i wanted to look like i can choose these changes   or these year or i can make my own changes here  so after cleaning up the file either manually   or in a desktop do your gui or merge tool we  have to commit this like any other change so i   can save it here and say this is resolved and  if i type git status i can see these changes   would be committed ive made some changes here  in index html this here is just a safety copy   you can configure that also to happen so you  can always return to the to the original file   but i would actually just commit this  here and simply by committing the resolved   files i signal to get that conflict is  completed and i can go on with my work   most developers understand that its  important to use branches in git   because having separate containers  for your work is incredibly helpful   lets talk a bit about integrating branches  about getting your new code back into an existing   branch there are different ways to do this and  the two most common ones are merge and rebase   lets start by talking about  merge and how it actually works   when git performs a merge it looks for three  commits first the common ancestor commit   if you follow the history of two branches in a  project they always have at least one commit in   common at this point both branches had the same  content and after that they evolve differently   the other interesting commits are  the end points of each branch   remember that the goal of an integration is  to combine the current states of two branches   so the latest revisions are of course  important combining these three commits   will perform the integration that were aiming  for ive chosen a very simple example case   here because one of the two branches are  a branch a here it didnt receive any new   commits after the branching happened so its  latest commit is also the common ancestor   in this case the integration is dead simple  good can just add all the new commits from   branch b on top of the common ancestor  commit and and get the simplest form   of integration is called a fast forward merge  both branches then share the exact same history   in most most cases however both branches  move forward differently of course   and to make an integration good  well have to create a new commit   that contains the differences between them  and this is what we call a merge commit   normally a commit is carefully created by a  human being at some meaningful unit that wraps   only related changes in the commit message  provides context and notes now a merge   commit is a bit different its not created by a  developer it gets created automatically by git   and it also does not wrap a set of related  changes its purpose is to connect two   branches just like a knot if you want to  understand a merge operation after the fact   you need to take a look at the history of  both branches and their commit history   now lets talk about rebase but before we  start let me emphasize something rebase is   not better or worse than merge most importantly  its different you can live a happy good life   just using merge but rebase has its pros and  cons so knowing what it does and when it could   be helpful is nice alright remember that we  just talked about the automatic merge commit   some people would prefer to go without these  they want the project history to look like a   straight line without any science that it had  been split into multiple branches at some point   even after branches have been integrated and  this is what happens with rebase lets walk   through a rebase operations step by step the  scenario is the same as in the previous example   we want to integrate changes from branch  b into branch a but now by using rebase   the actual git command to start this is  really simple its just git rebase and   the branch similar to git merge we just  tell git which branch we want to integrate   but lets take a look behind the scenes  first git will remove all commits on branch   a that happened after the common ancestor commit  but dont worry will not throw them away   you can think of those commits as being  parked as saved somewhere temporarily   then get applies to new commits from branch b  and at this point temporarily both branches   look exactly the same but in the final step  those parked commits need to be included   the new commits from branch a theyre positioned  on top of the integrated commits from branch b   they are rebased as you can see and the result  looks like development had happened in a straight   line there is no merge commit that contains all  the combined changes we preserve the original   commit structure theres one more thing an  important thing to understand about rebase   it rewrites commit history so take a close look  at this last diagram here commit c three has an   asterisk symbol it has the same contents as c  three but its effectively a different commit   because it now has a new parent before the rebase  see one was its parent and after the rebase   its c for which it was rebased onto a  commit has only a handful of important   properties like the author date change set and  who its parent commit is and changing anything   any of this information if effectively creates a  completely new commit and with a new commit hash   so we writing history like that is not  a problem for commits that havent been   published or pushed yet but if youre rewriting  commits that have already been pushed to a remote   repository you might be in trouble because  another developer might have based their work   on the original c three commit which is not here  anymore so lets close this topic with a simple   rule do not rewrite commits that youve already  pushed to a shared repository tools like rebase   you should only use them for cleaning up your  local commit history for example for a feature   branch that youve been working on for some time  and before you integrate that back into a team   branch then youre using re based on that thats  what these tools like in rebase were made for   alright so much for today be sure to check out  my little advanced git kit its completely free   of charge its a little collection of short  videos about a lot of advanced git topics from   things like interactive rebase all  the way to branching strategies   merge conflicts sub modules what  have you its really helpful if you   want to become more productive with  git and version control and again   its free more right have fun and see you  soon here on the free code camp youtube channel 