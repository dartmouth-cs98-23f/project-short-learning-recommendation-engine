professor in electrical and software engineering in the schulich school of engineering and in this lecture im going to talk about memory how memory is organized and basically how we organize the values that are stored in memory before we get into that i just want to review a few things about number notation and in this module and in this course in general were going to use several different number systems were going to use base 10 numbers were going to use hexadecimal numbers and were going to use binary numbers and just to be i guess just to start with the most familiar base 10 numbers are what weve been using all the way through elementary school this is our standard numbering system and for example if i were to write the number uh 3821 for the purposes of this slide in this discussion im going to give a subscript 10 here and that is going to indicate that this is a base 10 number and the value of this number can be calculated by multiplying each of these digits by a power of 10 so 3821 is equal to 3 times 10 to the 3 plus 8 times 10 to the 2 plus 2 times 10 to the 1 plus 1 times 10 to the 0 and the powers of 10 are a function of the position of each one of these digits binary numbers are base 2 numbers and so if i were to write out 1 1 0 1 i could just to indicate the base write a little subscript 2 to indicate that were using a base 2 number and just like our example for the 10 base number the value of this binary number is 1 times 2 to the 3 plus 1 times 2 to the 2 plus 0 times 2 to the 1 plus 1 times 2 to the 0 or in other words if we add up all of these numbers this is 8 plus 4 plus 0 plus 1 or 13 if we want to write it in terms of of base 10 now when were working with binary numbers were going to be grouping them together a byte is equal to an 8 bit base 2 number and a nibble is a four bit base two number two nibbles make a bite obviously another really common number system that were going to be using in this class are hexadecimal numbers which are actually base 16 now base 16 seems like a strange number base to use but the numbers 0 through 15 are the maximum range of numbers you can represent with four bits and so computer engineers like to use hexadecimal numbers because its relatively easy once you get the hang of it to very quickly translate between hex numbers and and binary numbers a lot easier than it is to translate between base 10 numbers and and binary numbers and for hex numbers since weve got 16 values that we represent using digits we start with 0 1 all the way up to 9 and then we use letters after that we go a b all the way up to f and so if we go if we add a through f at the end of 0 to 9 we get 16 values and so if i was to write out a hexadecimal number it would be a mixture of or it can be a mixture of letters and and numbers and so for example a2 f 9 is equal to a which is actually 10 right because it goes 0 through 9 and then a is represents 10 b represents 11 f represents 15 so this hex number is equal to 10 times 16 to the 3 im just going to move my example here so we dont get so cluttered plus 2 times 16 squared plus f which represents 15 15 times 16 to the 1 plus 9 times 16 to the 0 and if you do all of this math and express it as a base 10 number it ends up being equal to um four thousand or four sorry forty one thousand seven hundred and twenty one and thats thats fine but again really the the reason why we like hex numbers is because it makes it very easy to translate between hex and and binary and so ill just give myself a little more space here ill delete the base 10 example tweet delete so as i was saying each hex number can be represented using four bits and if you get good at it you start to basically sort of remember how the 16 values map directly to binary and so the number 10 can be represented as 1 0 1 0 because thats 8 and thats 2 right 8 plus 10 or 8 plus 2 is 10 the number 2 is represented as 0 0 1 0 the number f is the maximum number its 15 so thats one one one one and then the number nine is one zero zero one eight plus one right and so very quickly we can go from the hex number to its equivalent in binary and so were going to be heavily using binary numbers hex numbers base 10 numbers i typically um when im using binary numbers i typically wont put you know base to i wont put base 16 for for hex numbers most commonly when im using hex numbers i will proceed it with the prefix 0x so if i write 0x12 thats not equal to 1 times 10 plus 2 times 1 instead thats equal to 1 times 16 plus 2 times 16 to the 0 right so 0x represents a hex number sometimes i will use 0b to represent a binary number but typically i wont because in most of the examples when were using binary itll be selfevident that were using binary now just a quick word about prefixes so um in general most people are familiar with the standard metric prefixes so for example kilo means um you know change my color here so so kilo means a thousand um mega means a million giga means a billion and we use these prefixes a lot when talking about computers right we talk about a 250 gigabyte hard drive sometimes we talk about a one you know a one gigabit per second ethernet link you know talking about the the throughput of the ethernet link but kind of confusingly typically when we talk about storage memory size were not using the standard base 10 definitions of kilo mega giga terra instead were using the base two definitions now these base two definitions that im showing them over here have their own words so instead of talking about kilo when we talk about a thousand um you know some of the prefix thats roughly equivalent to a thousand in base two we should be saying kibi and kibi represents 2 to the 10 or in other words 1024 so when we talk about one but but confusingly most often like when you look at computer vendor sites or when you talk to people theyll still use the the metric term kilo so when we talk about oh this is a one kilobyte um you know this memory can store one kilobyte of data were talking about a memory that can store 1024 bytes not 1000 bytes when were talking about a 250 gigabyte hard drive were talking about a hard drive that can store 250 times 2 to the 30 bytes rather than 250 times um 10 to the 9 bytes now im trying to change i guess right so um you know when i can i will use the prefix ki i g i but really this is not whats still typically done today like if you go on to a computer vendor site youre buying you know a solid state drive for your computer they still will use the standard metric um standard metric prefixes even though its understood that when youre talking about memory and youre talking about storage the the prefixes correspond to the base two definitions and thats the convention that were going to be using in this class so whenever i talk about memory size even if i you know slip up and say kilobytes or megabytes its always the base 2 prefix definition and when i talk about anything else like if we were to talk about you know the throughput or the data rate of you know a digital link or something like that then well use the regular metric definitions so can be a little confusing if you just remember like its always base two if were talking about memory then youll be fine and if youre you need clarification obviously just ask when working with memory we talk about not only the the contents of the memory but also we talk a lot about addresses and memory addresses and basically you know when we think of memory as an array of bytes the address of each byte is basically the index of that byte and so um if this is the first byte in our array it has index zero and we would say that this byte is at address zero the second byte has index one and we would say that this byte has address one so this index column is basically the address column and by convention in this class i will be drawing memory kind of from the bottom up so address zero will always be at the bottom of the memory diagram and then as we go up the address of the bytes will will increase and thats the the convention that youll see in most textbooks most data sheets the only time that you see it reversed is when you are working with things like debuggers or programming environments that give you a snapshot of memory on a real device generally then they will show you know lets say maybe a little bit of a screenshot of your of your memory content and they might show you you know bytes or hex numbers and usually this is address zero and then this will be um sorry this byte is address zero this would be the address one this would be address two you know and so on and then it it sort of wraps around so when we get into using our simulator programs that give us a snapshot of data memory and some of our development environments youll see memory represented in this way but for the purposes of our lecture discussions were always going to use this kind of bottom up convention the other way we can picture memory is as an array of words now a word is basically a group of bytes so memory space can be grouped into multibyte chunks called words and when representing um a memory as an array of words typically i will have several bytes all in a row and one of these rows represents a single word so for example the arm processor uses 32bit memory or fourbyte words and so the one of these um rows represents one word of our 32bit arm memory now this is basically just the way im drawing the memory you can still obviously think of 32bit memory as just being an array of bytes still where the first four bytes correspond to one word and the next byte four bytes correspond to the next word but its just a little bit more ease its just a little bit easier to visualize when you draw it this way now as soon as you have multibyte words you are presented with two different options for how to do your addressing you can use word level addressing or you can use byte level addressing now word level addressing is basically using the indices that are basically using the word indices right so that means the first four byte row of memory will music correspond to addresses zero and if we move this up the next row of memory corresponds to address one the third row of memory corresponds to address two and and so on however other memories arm is an example of this uses still uses byte level addressing even though we are working with four byte words and so what that means is the address of each word corresponds to the byte index of the smallest byte in the word and so this byte is byte zero this is byte one this is by two this is byte three this is byte four this is byte 5 6 7 this one is 8 and so on and so the address of this first word ill just change my color here the address of the first word corresponds to the byte index of the lowest or corresponds to the lowest byte index in that word the address of the next word is the lowest byte index in the second word the address of the third word is the lowest byte index in the third word and so as micro architecture designers how do we decide on the width of our words well basically the width of the words typically determine how many bits are operated on in parallel by the processor so if we have 32bit words generally that means were feeding 32bit numbers into our processor and the wider the word you know the more bits that are operated on by our processor at one time basically the bigger the numbers we can represent right so um wider words have more uh can allow numbers with more range and resolution the disadvantage of wider words is basically cost the wider your your words the wider the buses on your computer chip have to be in order to transfer all of those bits in parallel so a 32bit word typically requires buses that consist of 32 parallel wires 64bit words would be 64 parallel wires and so on and of course you know as at this particular time when im recording this video most modern processors are 64 bits and so if you buy a laptop even your smartphone typically those processors are 64 bits and its relatively rare to see 128 bits and so the reason why we havent gone to 128 bits is that there today arent very many applications that require numbers that big or resolution so a a bigger number will will give you will allow you to store larger numbers but will also give you more precision if youre using sort of a floating point number and right now 64 bits is enough to give us numbers as big as we need and as precise as we need and that wont change until we get onto applications that require bigger numbers or more more precision because right now we want to you know keep we also want to keep an eye on cost and so 64 bits is kind of that sweet spot between number size and expense so as soon as we have multiple bytes in a memory word we have to talk about how were going to index the bytes within each one of those words and as it turns out historically there were two ways to do this and they were the big indian bite ordering convention and the little indian bite ordering convention and the terminology is actually from the book gullivers travels so in gullivers travels the king requires all of his subjects to um open their hardboiled eggs on the little end and so um thats not a very good egg but if you were a little indian you had to open your egg on the little end the big indians were the rebellious subjects that decided to open their eggs on the big end and so thats thats where the the indian terminology comes from the the the big indian and little indian conventions were basically used excuse me by different processor companies now processor design companies but now before i go into explaining the difference between big nd and little indian i should say that the convention that we use for ordering bits within a byte are is always the same regarded regardless of which indian convention you use so if we look within a byte we have of course eight bits and the right or sorry the leftmost bit is called the most significant bit because this bit value when we convert it to a 10 base number is multiplied by 2 to the 7 or 128 the rightmost bit is called the least significant bit because when we convert the byte into a 10 base number the value of the least significant bit contributes only zero or whoops zero or one whereas the most significant bit contributes either 0 or 128 to the value of the number so for the big indian convention we would use byte indexing for each of our words and so that means the word address for the first byte is zero the word address for the second byte is four the word address for the third byte is eight and the indexing for the bytes within each word goes left to right and so this is byte 0 byte 1 byte 2 and byte 3 and so for the bytes that ive circled this first byte is word address 4 right there and byte offset 2 the byte that ive circled up here is word offset 8 and byte offset 0 as you can imagine little endian is just the opposite way so um with this little indian example we still use byte level word addresses so the first word has word address zero the second word has address four the third word has address eight but the byte ordering goes right to left so this is byte offset 0 1 2 and 3 so this byte circled right here is word address 8 byte offset 0 the second address is would be word address 4 byte offset 2 now as ive noted in my slides the big indian convention was used primarily for primarily by motorola for their power pc processor which was an important processor in the late 80s certainly in the mid 90s and then little endian convention was mainly used by the intel processors but over time as motorola dropped its power pc product the sort of the champion for the big indian convention kind of disappeared and so now all major architectures today use the little indian convention so the the x86 processors the arm core processors mips processors all use the little indian convention and so going forward little indian is what were going to be using in this course so weve talked about memory organization memory addressing in a very general way weve talked about byte level addressing word level addressing words that can be a variable number of bytes weve talked about big endian little endian now i would like to conclude with a just a two real world processor examples and these are the two processors that were really going to be talking about most in this course the first one or the first thing i want to talk about is how an arm processor organizes its memory were not going to be doing any handson exercises with arm processors in this class but im going to be using arm as an example of a more sophisticated processor than the avr and as it turns out arm processors modern arm processors anyways default to little indian but they do actually support big indian byte indexing as well and depending on the version of processor they use either 32 or 64bit words in most of our examples im going to be assuming 32bit words and they use as i said bytelevel addressing so if i was to draw a picture of arm memory it would look like this so weve got 32 bit or four byte words so each row of memory consists of four bytes by default we use little indian byte addressing so the least significant byte is byte 0 and then we proceed all the way up to byte offset 3 and because we use byte level addressing the address of the first word is 0 address of the second word is 4 8 and and so on the avr processor is interesting because it actually uses different addressing and word lengths depending on whether were working with instruction memory or data memory remember the avr uses a harvard architecture it has completely separate paths for instruction and data memory and so it has this flexibility instruction memory is divided into 16bit words and it uses 17bit word addressing so word level addressing and the maximum um and and the addresses are stored using 17 bits and so that means the maximum memory size is 128 kilobytes where were using the base 2 definition of kilo or i could say kibi bytes here but even in the the avr data sheet youll see that we use the they use the prefix kilo data memory uses 8bit words and 16bit byte level addressing and so the nice thing about the avr processor and also including the arm as an alternate example is you get a real sort of you get a lot of experience with different types of addressing and comfort with using different types of addressing schemes as appropriate 