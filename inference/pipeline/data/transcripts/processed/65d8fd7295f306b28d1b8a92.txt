discuss how indexes actually work and help   improve the performance of our sql queries well  discuss how both the index types work  clustered   and nonclustered if youre new to indexes weve  already covered all the basics you need in this   sql server tutorial for beginners course please  check out the videos from parts 35 to 38 ill   include the link in the description of this video  now consider this employees table employeeid is   the primary key so by default a clustered index  on the employeeid column is created this means   employee data is sorted by employeeid column  and physically stored in a series of data pages   in a treelike structure that looks like  the following the nodes at the bottom of   the tree are called data pages or leaf nodes  and contains the actual data rows in our case   employee rows these employee rows are sorted  by employeeid column because employeeid   is the primary key and by default a clustered  index on this column is created for our example   lets say in this employees table we have  1200 rows and lets assume in each data page   we have 200 rows so in the first data page we  have 1 to 100 rows in the second 201 to 400   in the third 401 to 600 so on and so forth the  node at the top of the tree is called root node   the nodes between the root node and the leaf  nodes are called intermediate levels the root   and the intermediate level nodes contain index  rows each index row contains a key value   in our case employeeid and a pointer to either  an intermediate level page in the btree   or a data row in the leaf node so this treelike  structure has a series of pointers that helps the   query engine find data quickly for example lets  say we want to find employee row with employee id   1120 so the database engine starts at the root  node and it picks the index node on the right   because the database engine knows it is this node  that contains employee ids from 801 to 1200 from   there it picks the leaf node that is present  on the extreme right because employee data rows   from 1001 to 1200 are present in this leaf node  the data rows in the leaf node are sorted by   employee id so its easy for the database engine  to find the employee row with id equals 1120   notice in just 3 operations sql server is able to  find the data we are looking for its making use   of the clustered index we have on the table lets  look at this in action this piece of sql script   at the top creates employees table with these four  columns  id name email and department first   lets create the table this second block of code  here inserts test data into employees table lets   actually execute the script its going to take  a few seconds to complete and thats because   if you take a look at this code notice were  using while loop to insert one million rows   into this table and if we click on the messages  tab in a few seconds we should see a message   saying 100000 rows inserted thats because  for every hundred thousand rows that we insert   we are logging the message lets  give it a few seconds to complete there we go all the 1 million rows are  inserted now lets execute this select   query we are trying to find employee whose id is  932 000 and before we execute this query click   on this icon right here which includes the actual  execution plan you can also use the keyboard   shortcut ctrl  m there we go we got the one  row that we expected and when i click on the   execution plan and when i hover over this notice  the operation is clustered index seek meaning the   database engine is using the clustered index  on the employeeid column to find the employee   row we want number of rows read is 1 actual  number of rows for all executions is also 1 now   number of rows read is the number of rows  sql server has to read to produce the query   result in our case employeeid is unique so  we expect one row and that is represented by   actual number of rows for all executions with the  help of the index sql server is able to directly   read that one specific employee row we want hence  both number of rows read and actual number of rows   for all executions is 1 so the point is if  there are thousands or even millions of records   sql server can easily and quickly  find the data we are looking for   provided there is an index that  can help the query find data   now we have a clustered index on the employeeid  column so when we search by employeeid   sql server can easily and quickly find the data  we are looking for but what if we search by   employee name at the moment there is no index  on the name column so there is no easy way for   sql server to find the data we are looking for  sql server has to read every record in the table   which is extremely inefficient from performance  standpoint lets actually look at this in action   here is the query we are trying to find the  employee by name lets execute it there we go   we have the one row that we expected and i click  on the execution plan and hover over this notice   the operation is clustered index scan since  there is no proper index to help this query   the database engine has no other choice than to  read every record in the table this is exactly   the reason why number of rows read is 1 million  that is every row in the table and if you take a   look at actual number of rows for all executions  the value is 1 how many rows are we expecting in   the result well only one row because there is  only one employee whose name is abc 932000 so   to produce this one row as the result sql server  has to read all the 1 million rows from the table   because there is no index to help this query  this is called index scan and in general index   scans are bad for performance this is when we  create a nonclustered index on the name column   actually sql server is helping us here notice  its actually telling us there is a missing index   to improve the performance of this select query  its asking us to create a nonclustered index   on the name column why on the name column  well thats because we are looking up employees   by name so lets actually right click on this  and select this option  missing index details   we actually have the required code here to  create nonclustered index lets uncomment this   create nonclustered index we are creating on the  name column and lets give this index a name ix   for index we are creating it on the employees  table and on the name column lets execute this now lets execute that same select query  again click on the execution plan tab   and we have several steps here well discuss  execution plans in detail in our upcoming videos   for now just understand we read the execution  plans from right to left and top to bottom so   we start here and when i hover over this  notice now the operation is index seek   on the nonclustered index before we understand  this execution plan lets first understand how   nonclustered index is stored in the database in  a nonclustered index we do not have table data   we have key values and row locators we created  a nonclustered index on the name column so   the key values in this case employee names  are sorted and stored in alphabetical order   the row locators that are present at the bottom of  the tree contain employee names and cluster key of   the row in our example employee id is the cluster  key why because employee id is the primary key   by default it is the cluster key now if we look  at one of the row locators notice the names of   the employees are sorted in alphabetical order and  we also have their respective employee id now   if you remember on the employee id we have the  clustered index now when we search employee   by name both these indexes nonclustered index  on the name column and clustered index on the   employeeid column are going to work together to  find the employee that we are looking for lets   look at the steps involved first sql server  uses the nonclustered index on the name column to   quickly find this employee entry in the index in  a nonclustered index along with the employee name   we also have the cluster key in our case its  employee id the database engine knows there is   clustered index on employee id so this clustered  index is then used to find the respective employee   record now lets relate these steps to the  execution plan that we have in sql server   management studio remember we read the execution  plan from right to left and top to bottom so   we start on the top right here notice the first  step is index seek on the nonclustered index   on the name column we have nonclustered index  and sql server is using it to find an entry for   this employee in the index and remember in the  index along with the employee name we also have   employee id which is the primary key next  this primary key is used to find an entry   in the clustered index thats why we have  the operation here as key lookup clustered the value from the cluster index in our case  employee id is then used in an inner join with   the employees table to retrieve the respective  employee record if youre new to these execution   plans and wondering why this nested loop or inner  join is required well discuss these execution   plans in detail in our upcoming videos now  on this slide i have estimated subtree cost   with and without index so for this query   select  from employees where name equals whatever   name we supply estimated subtree cost without  index is 11 something with index it is 0006   just imagine the impact it can have on performance  if we dont have index on the name column   if youre wondering how did i get these  statistics well in sql server management studio   on the execution plan tab if you hover over the  select operation you get the total estimated   subtree cost for all these operations in our  upcoming videos in this series well discuss sql   server execution plans in detail with examples  thats it in this video thank you for listening 