im going to talk about what dynamic programming is and how to use it and as i explain how it works im going to assume that youre already familiar with recursion so what is dynamic programming exactly its actually fairly simple even though it might sound difficult its basically a way of making your algorithm more efficient by storing some of the intermediate results and it works really well when your algorithm has a lot of repetitive computations so that you dont have to repeat those competitions over and over again and im gonna give you a concrete example of how it works with fibonacci sequence so just in case youre not familiar with it phonology sequence is a sequence of numbers that starts with two ones at the beginning and each number after that is computed by adding up the two previous numbers so the third three months number is two because one plus one equals two and then the fourth 300 number is three because one plus two equals three and so on and this sequence keeps on going forever so lets say were trying to solve the problem of finding the entrance number or writing a function called fib of n which takes a positive integer n and finds and returns the end speedruns number so if the given n is three we want to be able to find and return the third finch number which is two and if the given n is five we want to be able to return the fifth reynolds number which is five lets see how we can solve this problem using dynamic programming so if you want to solve a problem using dynamic programming there are typically three steps you can take the first step is to come up with a recursive solution to your problem and then in your recursive solution if you notice that there are a lot of repeated competitions you can then store some of the intermediate results so that you dont have to repeat those competitions this process is also called memoization or memorize and this is not to be confused with memorize and ive made a mistake before too and then the third step if you dont like using recursion anymore is to come up with something called a bottomup approach so lets first see what a recursive solution might look like for this particular problem so as i said earlier were going to write a function called fable of n which takes and a positive integer and returns the n 3 branch number and if n is equal to 1 or 2 we know that the first and the second finish numbers are 1 were going to return 1 but instead of returning it right away were going to store it in a temporary variable called the result and then return that instead and its going to be clear why we need to do that later and if n is neither one nor two then were going to return the sum of the two previous fibonacci numbers instead fib of n minus 1 plus fib of n minus 2 store that in result and then return it at the end so the solution works but its very very inefficient to see why lets see an example where were trying to find the 5th fibonacci number by calling table 5 so to find the return value of people 5 we need to first compute the return values for table 4 and people 3 so we can add them up and to find people for we need to first compute fib of 3 and peep of 2 and so on and thats what this diagram shows and looking at this diagram you might notice that there are some competitions that we repeat over and over again for example we need to compute the return value for people to three times and we need to compute the return value for fib of 3 twice here and its not a big deal when we are trying to find the fifth or sixth minus number but if were trying to find the hundredth free bonus number it becomes an issue and actually the time it takes to find the nth fibonacci number grows exponentially or roughly in the order of two to the power of n and dynamic programming here says why not just store those return values for example for fib of 3 store the return value once we compute it and then use that same value when we see people 3 again in instead of computing it again and again this process is called memoization so lets see what a memorized solution looks like in code lets again consider the example where were trying to find the fifth boomers number by calling people five the idea of this solution is going to be that were going to use an array whose length is n plus one or six in this particular case because n here is five and then were going to store the return value for the function of fib of n at the index n so were going to store feeble of one which is the first few months number right here at index 1 and then fib of 2 at index 2 and so on and initially were going to set all these values to now and were going to write our function of fib and this is going to take two arguments instead of just one the first one is the same as before and a positive integer and the second one is going to be this array and so you need to initialize the survey memo before you call this function now at the beginning of this function check if memo at index n is null or not if its not equal to now thatll mean that weve already seen this argument n and weve already stored the return value for that at the index n a memo so just return that instead so we turn memo square brackets and otherwise the following part is the same as before if n is equal to 1 or 2 we turn one store 1 in result and then return that at the end and if thats not the case then find the sum of the two previous fabulous numbers and then return that instead and then whats new in this function is that before you return this result the return value you need to store it in memo at index n so that you can use it later now lets now think about the time complexity for the solution were going to call it t of n this is going to be the time it takes to find the nth fibonacci number with this particular method and were going to find that by multiplying the number of times we call this function baby with the time it takes to execute each of those calls were going to call that t now there are only two ways were going to call this function of fib the first way is when we call this function for the first time with the arguments and and memo to find the nsp ones number and the second way is from this line right here and notice that if you look at this whole block after this first if clause this whole block is only executed most n times and this is true because there are n possible arguments to this function thats 1 through n and each time this function is called with each of those arguments the return value will be stored a memo at index n so after the first time this function is called with each argument well never get to this block and each time this block is executed fib is called a most twice if we get to this line so the number of times fib is called is at most two times n plus 1 so 2 n it comes from this block right here and one comes from the first time we call this function fib and the time it takes to execute each of those calls this t right here is going to be a constant time or a big o of 1 and this is because if you look at each operation in this function excluding these recursive calls that follow each operation is a constant time operation and when you have a constant time operation when you add them up you still get a constant time operation which is bigoh of one and thats why we have big o of one here and so t of n or the time it takes to find the nth feminist number with this particular method is going to be 2 n plus 1 times big o of 1 which is big o of 2 n plus 1 which is equal to big o of n and this is a huge improvement from what we had earlier which was big o of 2 to the power of n now lets now examine how this memo array is actually filled so lets say were trying to find the 5th fibonacci number again and when we call fib with the argument 5 and memo of course well see that we dont have a stored value at the index 5 yet so we go down and were going to ask ourselves whats the value of fib of 4 and then 3 and so on and when we get to fever of 2 well know that this value is 1 so were gonna store it at index 2 right here and same with people 1 thats 1 right here and once we have these two values well be able to find the third a fibonacci number which is fib of 3 right here and then once we find the value by adding them up store that value right here so we can use it later and then when we go up to feeble 4 well add 1 and 2 right here and we get 3 and so on until we get here and so as you can see this array is mostly filled from left to right so when you see this you might say why not just explicitly build this array from left to right from scratch instead of building a recursively and thats the idea behind a bottomup approach so lets see what a bottomup approach might look like in code were going to define a function called fab bottomup which takes an a positive integer just like before and returns the nth fibonacci number and then if n is equal to 1 or 2 of course were going to return 1 and after that were going to define an array whose lie is going to be n plus 1 where n plus 1 is 6 of course if were trying to find the fifth fibonacci number right here if n is equal to five and after that were going to set the first and the second elements of this array bottom up to be 1 these two items right here and then were going to run a for loop for i from 3 which corresponds to this item right here up to n and n corresponds to the last item right here of this array and whatever index were examining currently were going to set that element at the index i or bottom up square brackets i to be the sum of the two previous items so in this particular example well have two here three here and after that were going to return the last item in bottom up or bottom up square brackets n and were done the time complexity for this algorithm will be again big o of n because were going to define this array and go through this array only once ok so thats how dynamic programming works but now im going to show you a quick demo with python and something called jupiter notebook to show you how this idea of my play out in practice so in this jupiter notebook i have defined a few functions in python fib of n which is a recursive naive recursive solution and river of memo and people to which represent a memorized solution and fifth bottom up which is of course a bottom up solution so lets see how they compare to each other in performance were gonna try running fib of n first the naive recursive solution with fever five and that gives us 5 which is expected what about fever of 20 that gives us the answer pretty quickly  and what about fever of 35 this actually takes five to six seconds on my computer so its obviously not the most efficient approach lets see how fib of 2 and 3 both memo the memorized solution compares to that lets try running fifth memo of 5 first and that gives us five which is expected and what about 50 mm or 35 thats pretty quick  and what about 50 ml 100 and 1000 this actually gives us an error and this error is called a recursion error python gives us this er actually because there are too many recursive calls on a call stack and to fix that we can just use the bottomup approach one advantage of using a bottomup approach is that we dont have to put any recursive calls on a call stack so we dont have to worry about that so were going to load this function and then run it with the argument 35 which is pretty quick 1000 and then lets try 10000 as well and thats pretty instantaneous  okay so thats my introduction to dynamic programming let me know in the comment section below what you thought of this video and if you have any requests about what kind of videos i should make in the future let me know in the comment section below as well im yk from ces dojo and ill see you in the next video 