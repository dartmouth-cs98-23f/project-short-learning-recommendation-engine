and individual actors are intercepting and storing lots of encrypted data like passwords bank details and social security numbers but they cant open these files so why are they doing it well because they believe that within the next 10 to 20 years they will have access to a quantum computer that can break the encryption in minutes this procedure is known as store now decrypt later or sndl and it works because there is information around today that will still be valuable in a decade things like industrial and pharmaceutical research and top secret government intelligence and everyone is aware of this threat the national security administration says that a sufficiently large quantum computer if built would be capable of undermining all widely deployed public key algorithms  you know in a five to 10 year timeframe quantum computing will break encryption as we know it today  even though sufficiently powerful quantum computers are still years away theyre already a threat because of store now decrypt later which is why the us congress just passed legislation mandating all agencies start transitioning right now to new methods of cryptography that cant be broken by quantum computers you know our current encryption schemes have been remarkably successful working effectively for over 40 years up until the 1970s if you wanted to exchange private information with someone you would first have to meet up in person and share a secret key this same key would be used to encrypt and decrypt messages so its known as a symmetric key algorithm as long as no one else gets their hands on the key your messages are safe but now what if you wanna send information to someone youve never met and its too hard to arrange an inperson meeting you cant share a key over an unsecured channel like a phone line or the mail because it could be intercepted and this is what in 1977 led three scientists riverst shamir and adelman to come up with an encryption breakthrough today its known by their initials rsa and it works something like this every person has two really big prime numbers all their own which they keep secret they multiply these numbers together to get an even bigger number which they make public for everyone to see now if i wanna send someone a private message i use their big public number to garble my message and i garble it in such a way that it is impossible to ungarble without knowing the two prime factors that made that number this is an asymmetric key system since different keys are used to encrypt and decrypt the message so its easy for my intended recipient to decode but impossible for everyone else unless they can factor that large public number now someone could try to factor it using a supercomputer in the best known factoring algorithm the general number field sieve but modern cryptography uses prime numbers that are around 313 digits long factoring a product of two primes this big even with a supercomputer would take around 16 million years but not on a quantum computer see in normal computers a bit can only be in one state at a time either a zero or a one so if you had two bits they could be in one of four possible states 00 01 10 or 11 lets say each of these states represents a number 0 1 2 or 3 if we want to do a calculation for example raising seven to the power of one of these numbers we can only do it for one state at a time in this case seven squared and so we get the answer 49 quantum computers consist of qubits which also have two states zero or one but unlike a classical bit a qubit doesnt have to be in just one state at a time it can be in an arbitrary combination of those states a superposition if you will of zero and one so if you have two qubits they can exist simultaneously in a superposition of 0 1 2 and 3 now when we repeat the same calculation it will actually perform the calculation for all of those numbers at the same time and what were left with is a super position of the different answers 1 7 49 and 343 if we add another qubit we double the number of possible states so with three qubits we can represent eight states and thus perform eight calculations all at once increase that number to just 20 qubits and you can already represent over a million different states meaning you can simultaneously compute over a million different answers with 300 qubits you can represent more states than there are particles in the observable universe this sounds incredibly powerful and it is but there is one very big catch all of the answers to the computation are embedded in a superposition of states but you cant simply read out this superposition when you make a measurement you only get a single value from the superposition basically at random and all the other information is lost so in order to harness the power of a quantum computer you need a smart way to convert a superposition of states into one that contains only the information you want this is an incredibly difficult task which is why for most applications quantum computers are useless so far weve only identified a few problems where we can actually do this but as luck would have it these are precisely the problems that form the foundation of nearly all the public key cryptography we use today in 1994 peter shor and don coppersmith figured out how to take a quantum fourier transform it works just like a normal fourier transform apply it to some periodic signal and it returns the frequencies that are in that signal now this may not seem particularly interesting but consider this if we have a superposition of states that is periodic that is the terms in the superposition are separated by some regular amount well we can apply the quantum fourier transform and will be left with states that contain the frequency of the signal so this we can measure the quantum fourier transform allows us to extract frequency information from a periodic superposition and that is gonna come in handy so how does a quantum computer factor the product of two primes much faster than a conventional computer i want to explain this by first walking through a simple example with no quantum computer required and then ill show how a quantum computer could execute this method even for a very large number in a short period of time so lets say we have a number n which is the product of two primes p and q for the sake of this example lets set n equal to 77 now i bet you can guess the prime factors but lets pretend for the moment that we dont know them because with a product of really big primes we wouldnt now i want to use a fact about numbers that feels like magic pick a number g that doesnt share any factors with n if you multiply g by itself over and over and over you will always eventually reach a multiple of n plus one in other words you can always find some exponent r such that g to the power of r is a multiple of n plus one lets see how this works pick any number that is smaller than 77 ill pick the number eight this number doesnt share factors with 77 and if you were doing this with big primes it would also be extremely unlikely that you just happen to pick a number that shares factors with n now multiply eight by itself once twice three times four times and so on raising eight to ever higher powers and then divide each of these numbers by 77 were not really interested in how many times 77 goes into the number just the remainder whats left over because at some point 77 should divide one of these numbers with a remainder of exactly one so eight divided by 77 is zero with a remainder of 8 64 divided by 77 is zero remainder 64 512 divided by 77 is six remainder 50 and as we keep going we get remainders of 15 43 36 57 71 29 and finally one so there we have it eight to the power of 10 is one more than a multiple of 77 so weve found the exponent r that satisfies this equation but how does this help find the factors of n well we rearrange the equation to bring one over to the left hand side and then we can split it into two terms like so and now as long as r is even we have one integer times another integer is equal to a multiple of n this looks remarkably similar to p times q equals n i mean since we know that p and q are on the right hand side of this equation they must also be on the left hand side just multiplied by some additional factors so one way to think about what weve done is weve taken a bad guess for one of the factors g and by finding the exponent r weve turned it into two much better guesses that probably do share factors with n since r was 10 the two terms on the left hand side are eight to the power of five plus one 32769 and eight to the power of five minus one 32767 these two numbers probably share factors with n so how do we find them we use euclids algorithm if you wanna find the greatest common divisor of two numbers say 32769 and 77 divide the bigger number by the smaller one and record the remainder in this case 32769 divided by 77 gives a remainder of 44 then shift the numbers one position left and repeat so now we divide 77 by 44 and we get a remainder of 33 repeat the process again 44 divided by 33 gives a remainder of 11 and again 33 divided by 11 equals three remainder zero when the remainder is zero the divisor is the greatest common factor between the two numbers you started with in this case its 11 which is indeed a factor of 77 and 32769 you could do the same procedure with the other number or just divide 77 by 11 to get seven its other prime factor so to recap if you wanna find the prime factors p and q of a number n first make a bad guess g second find out how many times r you have to multiply g by itself to reach one more than a multiple of n third use that exponent to calculate two new numbers that probably do share factors with n and finally use euclids algorithm to find the shared factors between those numbers and n which should give you p and q now you dont need a quantum computer to run any of these steps but on a classical computer this method wouldnt be any faster than other methods the key process that a quantum computer speeds up is step two finding the exponent you raise g2 to equal one more than a multiple of n to see why lets go back to our example where eight to the power of 10 is one more than a multiple of 77 watch what happens to the remainders if we keep going past eight to the power of 10 to 8 to the 11 eight to the 12 and so on well we get remainders of 8 64 50 15 43 36 57 71 29 and again one the remainders cycle and they will just keep cycling notice how the exponent that yields a remainder of one is 20 which is 10 more than the first exponent that yielded a remainder of one so we know that eight to the 30 and eight to the 40 8 raised to any power divisible by 10 will also be one more than a multiple of 77 its also worth noting that if you pick any remainder say 15 the next time you find that same remainder the exponent will have increased by 10 so you can find the exponent r that gets us to one more than a multiple of n by looking at the spacing of any remainder not just one remember that here im plotting out the remainders on a log scale so you can see they are periodic with a period of 10 if i had made a different guess say i had picked g equals 15 instead of eight well then the period would be different and the remainders would be different but there would always be a remainder of one why is this well now that you can see this is a repeating pattern we can go back to the beginning and any number raised to the power of zero is one so that is actually the first remainder so it must also appear when the cycle starts again now we are ready to use a quantum computer to factor any large product of two primes first we split up the qubits into two sets the first set we prepare in a superposition of zero and one and two and three and four and five and six and seven and eight and nine all the way up to 10 to the power of 1234 yeah this is a huge superposition but if we had perfect qubits it would require only around 4100 the other set contains a similar number of qubits all left in the zero state for now now we make our guess g which most likely doesnt share factors with n we raise g to the power of the first set of qubits and then we divide by n and store the remainder in the second set of qubits leaving the first set of qubits as it was now we have a superposition of all the numbers we started with and the remainder of raising g to the power of those numbers divided by n and through this operation we have entangled our two sets of qubits but we cant just measure this superposition if we did we would get a random value and learn nothing but there is a trick we can use if we dont measure the entire superposition but only the remainder part we will obtain some random remainder but this remainder wont occur just once it will occur multiple times every time it comes up in the cycle imagine we were doing this with the example from before with n equals 77 and g equals eight if the remainder we measured was say 15 then there would be multiple terms in our superposition because there are multiple exponents you can raise g2 that give this same remainder exponents 4 14 24 34 and so on they are each separated by 10 and that value is the exponent that satisfies our equation so more generally after measuring the remainder we will be left with a superposition of states that all share the same remainder and the exponents will all be separated by the same amount r this is the number we are looking for since the remainder is now the same for all states we can put it to the side and we now have a superposition that is periodic each term is separated from its neighbors by an amount r if we now apply the quantum fourier transform to this superposition of states and im simplifying a little here we will be left with states containing one over r so all thats left to do now is perform a measurement and find r by inverting it and thats it for the quantum part now as long as r turns out to be even we can use r to turn our bad guess g into two numbers that likely share factors with n and as long as these terms themselves are not a multiple of n we can use euclids algorithm to find the factors of n and break the encryption this would only take several thousand perfect qubits but the qubits we have today are imperfect so we need additional qubits to act as redundant information in 2012 it was estimated that it would take a billion physical qubits to break rsa encryption but by five years later that number had dropped to 230 million and in 2019 after more technological breakthroughs that estimate plummeted to just 20 million physical qubits so how many qubits do we have today well if we look at the state of ibms quantum computers we are nowhere near that number of qubits but progress looks to be exponential so now its just a question of when these two curves will collide before all our existing public key encryption can be broken because weve long known this threat is coming scientists have been looking for new ways to encrypt data which can withstand attacks from both normal and quantum computers in 2016 the national institute of standards and technology or nist launched a competition to find new encryption algorithms that arent vulnerable to quantum computers cryptographers from all over the world submitted 82 different proposals which were rigorously tested some were broken and then on july 5th 2022 nist selected four of the algorithms to be part of their postquantum cryptographic standard so how do they work well three of the algorithms are based on the mathematics of latices so lets do a simple example in the 2d plane take two vectors r1 and r2 by adding together different integer combinations of these vectors say three times r1 and one times r2 you can get two different points and all the points you can get to by combining these two vectors in different ways is what is called a lattice now i will also give you the point c and your task is to tell me which combination of r1 and r2 will bring me to the lattice point closest to c its pretty easy to see that we can get there by going in the direction of r2 twice and in the negative direction of r1 twice simple enough but those vectors r1 and r2 are not the only vectors that can give you this lattice take b1 and b2 for example these vectors also build up the same lattice and now if i ask you the same question again can you tell me the combination of b1 and b2 that gets you to the lattice point closest to c this has become a lot harder but why is that each time were taking a step were trying to get closer in either the x or y direction but with the b vectors each time we take a step in the right direction with one vector it puts us off in the other direction and thats why these vectors are a lot harder to work with in the end it takes us a combination of eight times b1 and negative six times b2 to get to the closest lattice point that is a lot harder than before but its still a relatively easy problem to solve but if we extend it to three dimensions this already becomes a lot harder especially because youre not given the collection of all lattice points youre only given the vectors that make it up so when you find a lattice point close to the target you must still find all the other lattice points near it to make sure yours is indeed the closest lets take a circle of radius r in two dimensions the number of lattice points inside the circle is proportional to r squared add a third dimension and the number of points in the sphere is proportional to r cubed so just watch how the number of lattice points grows as we increase the number of dimensions solving the closest vector problem is a piece of cake for your computer in three dimensions even a hundred dimensions should be manageable but in proposed future encryption schemes well use around a thousand dimensions take one step in the right direction on one of those dimensions and you could potentially be taking a wrong step in the other 999 dimensions you win some you lose everything else with that many dimensions it becomes extremely hard to find the closest point even for the most powerful computers that is unless you know a good set of vectors so how do we use that to encrypt data well lets go back to our twodimensional example each person has a good set of vectors that describes a lattice but they keep these vectors secret and they only share their lattice publicly using a set of vectors that is hard to work with now if i want to send someone a message i pick a point on their lattice for example say this point corresponds to the number seven so if i wanna send the number seven i can take that point but then add some random noise to it so the message i send is not precisely at that point but close to it now to decode the message my recipient must figure out which lattice point is closest to the message point in a thousand dimensions this will be extremely hard to do unless you have the nice set of vectors which my recipient does so its easy for the recipient who has the good vectors but hard for everyone else and as far as we know this problem is extremely difficult to solve for both normal and quantum computers behind the scenes theres an army of researchers mathematicians and cryptographers were gonna make sure your secret data stays secret these are some of the unsung heroes that will keep us safe moving forward avoiding mass surveillance by governments keeping critical infrastructure protected and allowing you to live as if quantum computers were never invented in the first place digital buzzing something that fascinates me is being able to see where the world is headed and right now its clear that quantum computers and ai chatbots are going to play bigger and bigger roles in our lives in the coming decades even if we dont know exactly how theyll be implemented i think its important to learn how they work right now and you can do that with this videos sponsor brilliant brilliant has an incredible course on quantum algorithms this one was codeveloped with microsoft and alphabet x i love that you can simulate quantum gates and write and execute real quantum algorithms right in the lesson no need to set up your own development environment and if you want to dive deeper into cryptography making and breaking codes is really a matter of statistics strong statistical reasoning skills help us find patterns in data and make sense of them which is crucial to mastering just about any topic in math and computer science brilliants course on data analysis will help you ramp up fast it uses everyday situations like business models to illustrate key concepts in statistics and its interactive so you can get hands on with data visualizations and develop a real intuition for interpreting them you know the thing that sets brilliant apart is they know how to break fundamentals down into their core building blocks whether youre learning math computer science or data analysis brilliants thousands of bitesized interactive lessons help you master key concepts and build to more advanced topics you can try everything brilliant has to offer for free for a full 30 days just go to brilliantorgveritasium i will put that link down in the description and for viewers of this video brilliant is offering 20 off their annual premium subscription to the first 200 people to sign up so i wanna thank brilliant for sponsoring this video and i want to thank you for watching 