course computer science last episode we discussed a few example classic algorithms like sorting a list of numbers and finding the shortest path in a graph what we didn’t talk much about is how the data the algorithms ran on was stored in computer memory you don’t want your data to be like john green’s college dorm room with food clothing and papers strewn everywhere instead we want our data to be structured so that it’s organized allowing things to be easily retrieved and read for this computer scientists use data structures intro we already introduced one basic data structure last episode arrays also called lists or vectors in some languages these are a series of values stored in memory so instead of just a single value being saved into a variable like ‘j equals 5’ we can define a whole series of numbers and save that into an array variable to be able to find a particular value in this array we have to specify an index almost all programing languages start arrays at index 0 and use a square bracket syntax to denote array access so for example if we want to add the values in the first and third spots of our array ‘j’ and save that into a variable ‘a’ we would write a line of code like this how an array is stored in memory is pretty straightforward for simplicity let’s say that the compiler chose to store ours at memory location 1000 the array contains 7 numbers and these are stored one after another in memory as seen here so when we write “j index of 0” the computer goes to memory location 1000 with an offset of 0 and we get the value 5 if we wanted to retrieve “j index of 5” our program goes to memory location 1000 plus an offset of 5 which in this case holds a value of 4 it’s easy to confuse the fifth number in the array with the number at index 5 they are not the same remember the number at index 5 is the 6th number in the array because the first number is at index 0 arrays are extremely versatile data structures used all the time and so there are many functions that can handle them to do useful things for example pretty much every programming language comes with a builtin sort function where you just pass in your array and it comes back sorted so there’s no need to write that algorithm from scratch very closely related are strings which are just arrays of characters like letters numbers punctuation and other written symbols we talked about how computers store characters way back in episode 4 most often to save a string into memory you just put it in quotes like so although it doesn’t look like an array it is behind the scenes the memory looks like this note that the string ends with a zero in memory it’s not the character zero but the binary value 0 this is called the null character and denotes the end of the string in memory this is important because if i call a function like “print quote” which writes the string to the screen it prints out each character in turn starting at the first memory location but it needs to know when to stop otherwise it would print out every single thing in memory as text the zero tells string functions when to stop because computers work with text so often there are many functions that specifically handle strings for example many programming languages have a string concatenation function or “strcat” which takes in two strings and copies the second one to the end of the first we can use arrays for making one dimensional lists but sometimes you want to manipulate data that is two dimensional like a grid of numbers in a spreadsheet or the pixels on your computer screen for this we need a matrix you can think of a matrix as an array of arrays so a 3 by 3 matrix is really 2 an array of size 3 with each index storing an array of size 3 we can initialize a matrix like so in memory this is packed together in order like this to access a value you need to specify two indexes like “j index of 2 then index of 1”  this tells the computer you’re looking for the item in subarray 2 at position 1 and this would give us the value 12 the cool thing about matrices is we’re not limited to 3 by 3  we can make them any size we want  and we can also make them any number of dimensions we want for example we can create a five dimensional matrix and access it like this that’s right you now know how to access a five dimensional matrix  tell your friends so far we’ve been storing individual numbers or letters into our arrays or matrices but often it’s useful to store a block of related variables together like you might want to store a bank account number along with its balance groups of variables like these can be bundled together into a struct now we can create variables that aren’t just single numbers but are compound data structures able to store several pieces of data at once we can even make arrays of structs that we define which are automatically bundled together in memory if we access for example j index of 0 we get back the whole struct stored there and we can pull the specific account number and balance data we want this array of structs like any other array gets created at a fixed size that can’t be enlarged to add more items also arrays must be stored in order in memory making it hard to add a new item to the middle but the struct data structure can be used for building more complicated data structures that avoid these restrictions let’s take a look at this struct that’s called a “node” it stores a variable like a number and also a pointer a pointer is a special variable that points hence the name to a location in memory using this struct we can create a linked list which is a flexible data structure that can store many nodes it does this by having each node point to the next node in the list let’s imagine we have three node structs saved in memory at locations 1000 1002 and 1008 they might be spaced apart because they were created at different times and other data can sit between them so you see that the first node contains the value 7 and the location 1008 in its “next” pointer this means that the next node in the linked list is located at memory location 1008 looking down the linked list to the next node we see it stores the value 112 and points to another node at location 1002 if we follow that we find a node that contains the value 14 and points back to the first node at location 1000 so this linked list happened to be circular but it could also have been terminated by using a next pointer value of 0  the null value  which would indicate we’ve reached the end of the list when programmers use linked lists they rarely look at the memory values stored in the next pointers instead they can use an abstraction of a linked list that looks like this which is much easier to conceptualize unlike an array whose size has to be predefined linked lists can be dynamically extended or shortened for example we can allocate a new node in memory and insert it into this list just by changing the next pointers linked lists can also easily be reordered trimmed split reversed and so on which is pretty nifty and pretty useful for algorithms like sorting which we talked about last week owing to this flexibility many morecomplex data structures are built on top of linked lists the most famous and universal are queues and stacks a queue – like the line at your post office – goes in order of arrival the person who has been waiting the longest gets served first no matter how frustrating it is that all you want to do is buy stamps and the person in front of you seems to be mailing 23 packages but regardless this behavior is called firstin firstout or fifo that’s the first part not the 23 packages thing imagine we have a pointer named “post office queue” that points to the first node in our linked list once we’re done serving hank we can read hank’s next pointer and update our “post office queue” pointer to the next person in the line we’ve successfully dequeued hank  he’s gone done finished if we want to enqueue someone that is add them to the line we have to traverse down the linked list until we hit the end and then change that next pointer to point to the new person with just a small change we can use linked lists as stacks which are lifo… lastin firstout you can think of this like a stack of pancakes as you make them you add them to the top of stack and when you want to eat one you take them from the top of the stack delicious instead of enqueueing and dequeuing data is pushed onto the stack and popped from the stacks yep those are the official terms if we update our node struct to contain not just one but two pointers we can build trees another data structure that’s used in many algorithms again programmers rarely look at the values of these pointers and instead conceptualize trees like this the top most node is called the root and any nodes that hang from other nodes are called children nodes as you might expect nodes above children are called parent nodes does this example imply that thomas jefferson is the parent of aaron burr i’ll leave that to your fanfiction to decide and finally any nodes that have no children  where the tree ends  are called leaf nodes in our example nodes can have up to two children and for that reason this particular data structure is called a binary tree but you could just as easily have trees with three four or any number of children by modifying the data structure accordingly you can even have tree nodes that use linked lists to store all the nodes they point to an important property of trees – both in real life and in data structures – is that there’s a oneway path from roots to leaves it’d be weird if roots connected to leaves that connected to roots for data that links arbitrarily that include things like loops we can use a graph data structure instead remember our graph from last episode of cities connected by roads this can be stored as nodes with many pointers very much like a tree but there is no notion of roots and leaves and children and parents… anything can point to anything so that’s a whirlwind overview of pretty much all of the fundamental data structures used in computer science on top of these basic building blocks programmers have built all sorts of clever variants with slightly different properties  data structures like redblack trees and heaps which we don’t have time to cover these different data structures have properties that are useful for particular computations the right choice of data structure can make your job a lot easier so it pays off to think about how you want to structure your data before you jump in fortunately most programming languages come with libraries packed full of readymade data structures for example c has its standard template library and java has the java class library these mean programmers don’t have to waste time implementing things from scratch and can instead wield the power of data structures to do more interesting things once again allowing us to operate at a new level of abstraction i’ll see you next week 