warshall algorithm if you have never heard about any of these don’t worry about it you see i have interviewed at all these companies and got offers from google facebook amazon and some others if there’s one thing i have learnt from my experience it’s this you do not need to know every algorithm in this world to crack coding interviews in most interviews they are asking you very similar kinds of questions and if you have heard of the 8020 rule or pareto’s principle you know that 20 of algorithms will be asked in 80 of the interviews in this video i will tell you the top 5 algorithms i was asked in my interviews so that you can pick the top 20 algorithms by yourself i will also share exact problems where these algorithms can be applied this video is going to be very information dense at number 5 we have the “top k elements” algorithm “top k elements” algorithm shows up in many different problems finding k largest or smallest numbers in an array or finding the k most frequent numbers in an array are some examples where you would need to know this algorithm it also shows up in some “sliding window” problems we will cover “sliding window” shortly for the purpose of this video let’s look into finding k largest numbers in an array sorting the array and taking k largest elements is one way of doing it but it’s not optimal because the big o of doing this would be nlogn that’s why in the “top k elements” algorithm we use a heap data structure to track top k largest numbers now if you don’t know what a heap is and want me to make a video on the top 5 most asked data structures let me know in the comments for simplicity just know that a heap makes getting the maximum or minimum number very efficient in the “top k elements” algorithm we add the first k numbers of the array on a heap for every number after that we put it on the array and right after doing that we remove the minimum number from the heap this way we maintain the heap size of k and the heap always contains the largest k numbers we have seen so far this step of adding and removing the number from the heap has a big o of logk and we do this for every number of the array which is n times so the big o of the “top k elements” algorithm is nlogk instead of nlogn at number 4 we have the “sliding window” algorithm this algorithm shows up in many problems like largest substring without repeating characters maximum sum subarray of size k and largest substring with k distinct characters etc here we will learn the “sliding window” algorithm using the largest substring without repeating  characters problem you can pause the video if you need some time to understand the problem better in the first step we initialize two pointers left and right at the beginning of the array now we increment the right pointer to expand the window between left and right as we do this we store the information of all the characters present inside the window we keep incrementing the right pointer and updating this information until we find a character that’s already present in the window we have reached the maximum window size because the right index can not be part of this window due to the repeating character so we will update the answer and start shrinking the window by incrementing the left pointer until the repeating character goes outside the window as we increment the left pointer we will remove the characters that are no longer there in the window from the stored information once the left pointer reaches its final state we start incrementing the right pointer again to expand the window and repeat this process to help you understand this algorithm better i will provide the link to this code in the description at number 3 we have backtracking in backtracking we explore all possible solutions by building them step by step when we reach an invalid state we backtrack or go back and start exploring other possible solutions backtracking is usually implemented using recursion i know that none of this makes sense right now so let’s understand backtracking with the help of this very famous problem called combination sum in this problem you are given a list of positive numbers and a target sum you need to pick some numbers from the list so that they add up to the target sum in the end you have to return all unique ways or combinations that satisfy this condition you are allowed to pick a number more than once in this example 2 3 and 3 add up to the target sum of 8 so it’s one of the combinations in the answer pause the video if you need more time to understand the problem let’s create different combinations from scratch we start at index 0 with an empty combination and current combination sum of zero wherever the total sum of a combination is more than target we backtrack or return because adding more positive numbers to the combination will only increase the combination sum and can’t lead to a valid answer if the combination sum is the same as the target we add it to the answer and return otherwise for every number that comes after the current index we add it to the combination update the combination sum update the current index and call the function recursively updating the current index ensures that we only get unique combinations in the answer i will link this code in the description for you to check out backtracking is used in many problems like word ladder permutations and sudoku solver at number 2 we have dynamic programming in backtracking we explored all possible solutions from scratch piece by piece in dynamic programming we are more thoughtful about the solutions that we explore while still building our solutions from scratch and we do this by breaking a problem into smaller subproblems let’s take the example of combination sum and see how we can solve it with dynamic programming the problem asks us to find all possible unique combinations that add up to target sum using all the numbers or candidates but let me change this problem a little bit imagine that i give you all the combinations that add up to target sum target sum  1 target sum  2 using all the given numbers except the last one and now i will give you the last number can you use this new information to find all the combinations that add up to the target sum using all the numbers you can pause the video and take a moment to think you can start from the left until you reach the target sum equal to the last number do nothing for the target sum equal to the last number you can simply add the last number by itself as a new combination for the target sum equal to last number  1 you can just add the last number to all the combinations that add up to 1 and all those combinations would now add up to the last number  1 add the last number to all the combinations with target sum equal to 2 and all those combinations would now add up to the last number  2 and you can keep doing this until you reach the target sum and voila you have found your answer if you look at the code you keep track for all sums from 1 to target with this array for target sum equal to 0 add a combination which is an empty list now start with the first number and keep adding more numbers with this for loop and for a particular target sum just add more combinations by using all the combinations for target sum  current number i will leave a link to this code in the description at the very top we have breadth first search and depth first search i have kept them together because both of them are used for graph traversal and are very similar lets start with depth first search or dfs in dfs you start from a vertex and explore as far as possible along each branch if you reach a point where there is no unvisited neighboring vertex to explore you backtrack and try to find another branch that is unvisited in bfs you explore the neighboring vertices first before moving onto the other deeper univisited vertices dfs is implemented using a stack whereas bfs is implemented using a queue that’s because in dfs you want to explore the neighbors of the last vertex that you visited first so you want last in first out which is what stack does in bfs however you want to explore the neighbors of the first vertex you visited first so you want first in first out which is what queues are for i will link a couple videos in the description that explain this in much more detail bfs is used to find the shortest path from vertex a to vertex b another famous algorithm that does the same is dijkstra’s algorithm an algorithm that is closely related to dfs and is a must for coding interviews is topological sort i recommend you to read dijkstra’s algorithm and topological sort on your own to master all the algorithms we discussed today you need to have a deep understanding of data structures and you can not crack coding interviews just with these 5 algorithms obviously if you want to know how i mastered data structures and algorithms watch this video my name is sahil and i will see you in the next one 