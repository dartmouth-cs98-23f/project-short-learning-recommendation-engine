in a bit either 0 or 1 and returns a bit it is given to us as a sort of black box we cannot look inside this function to see what it does or try to understand how it works the only thing we can do is send in a bit and read the output bit our task is to find out if this function f is constant or balanced if a function is constant then the output is always the same no matter the input heres a truth table for the constant function constant zero which always returns zero there is also constant one which acts in the same way always returning one balanced functions on the other hand return zero half the time and one half the time if we look at the not gate truth table it is balanced since it returns zero for one input and one for another input the number of inputs resulting in zero is equal to the number of inputs resulting in one if we want to find out if a function is constant or balanced we can reframe this problem into figuring out if f of 0 equals f of one since if the function is constant this will hold true whereas if the function is balanced f of 0 will not equal f of one for a classical computer the number of calls needed to the function to solve the problem is two f of 0 and f of 1 both need to be calculated to find out if f of 0 does or does not equal f of one so both zero and one need to be input taking two calls over the function with quantum computers however deutsches algorithm needs only one call of the function to find out if its constant or balanced before we can understand how this is done however we must first discuss how we run functions on quantum computers we normally think of functions like this where we input x and get some output f of x this works fine for classical computers but in quantum computation all gates and operations must be reversible to understand how we can make functions reversible we will look at how a classical gate can be made reversible and then use the same techniques to create our quantum function or oracle if a function is reversible then given the output we can determine the input for example if we have an operation that negates the first bit we know what the input was as each row of the outputs in the truth table can uniquely identify the input if we look at the and gate truth table however we cant tell what the input was if it outputs a zero it could have been any one of these three different inputs thus the gate is not reversible but we can use some pretty awesome techniques and make any get we want reversible one way is by returning the inputs as well as inputting another bit lets call it c and exclusive oriented with the output f x if we now look at the truth table each output for each input is unique this technique allows us to make any operation reversible we use the same technique when making quantum oracles a standard quantum oracle looks like this where we input x and y x being the input to the function and y being the target qubit to write the answer to we then output x as well as y exclusive order with f of x this ensures the oracle is reversible if we look at it in terms of transformations the oracle acts on the state x y and turns it into x y x or f of x now you might be looking at this and thinking that this is a very obscure way of crewing a function but if we input y is zero then the rightmost cube it becomes f of x since zero exclusive ord with a bit value of x always returns x so in the case where y is equal to zero the oracle transforms the state x 0 into x f of x now to get the function output all we need to do is measure the rightmost qubit giving us f of x one last thing we need to understand before tackling deutsches algorithm is a special case of quantum oracles called the phase oracle if we set the target qubit to the minus state we get a thing called phase kickback where instead of the function output being applied to the target qubit a phase is applied to the input qubit lets quickly prove this result as it is used in many quantum algorithms we start with the input as an arbitrary bit x and the target in the minor state when we query the oracle since the target is in a superposition the unitary matrix u of f acting as the function gets distributed into the superposition and acts on each of the superposition states individually solving the exclusive ores we get 1 over root 2 x f of x minus x not f of x now we get two cases if f of x equals zero then the state becomes one over root two x zero minus x1 which if we factor out the x the state becomes x minus if however f of x equals one then the state becomes one over root two x one minus x zero we can take out effective negative one making the state negative one over root two x zero minus x1 simplifying the state becomes negative x minus we can generalize these findings through the equation negative one to the power of f of x x minus as you can see the target qubit was left unchanged and a phase of negative one to the power of f of x was applied to the input qubit querying a quantum oracle in this way with the target qubit in the minor state its called a phase oracle and its an integral part of many quantum algorithms now we get to the fun part we can finally understand how deutsches algorithm works this is a circuit for the algorithm lets label different parts of the circuit with psi so we can keep track of where we are in the circuit initially the qubits are in the state zero zero at psi sub 1 the qubits are in the state 0 1 then at psi sub 2 the state is plus minus after a hadimod gate is applied to each of the two qubits for clarity we will rewrite the plus state as one over root two zero plus one and distribute the minor state into the plus state we now query the oracle since the input state is in a superposition we distribute the unitary matrix acting as the oracle function into each of the superposition states now if we look at the form of each of the superposition states theyre in the phase oracle form so applying u of f to the first state with x equaling to zero in our general phase oracle equation it becomes negative 1 to the power of f of 0 0 minus and the other state with the input being 1 becomes negative 1 to the power of f of 1 1 minus to clean up the equation well quickly just factor out the minus key a bit and well also emit it from the rest of the computation since it is not needed anymore now our computation is in this state lets consider two different scenarios the outputs f of 0 and f of 1 could be equal to each other or not equal to each other in the case where they are equal the equation becomes 1 over root two zero plus one if f of zero and f of 1 equals zero and 1 over root 2 negative zero minus one if they are equal to one but in this case we can factor out a global phase of negative one so the equation becomes negative one over root two zero plus one with that we can combine these two equations for both cases and so that when f of zero equals f of one the state becomes plus or minus one over root two zero plus one on the other hand if f of zero does not equal f of one then the state becomes one over root two zero minus one if f of zero equals zero and f of one equals one or one over root two negative zero plus one if its the other way around in the second case we can factor out a negative one as a global phase leaving a relative phase of negative one in the state once again generalizing when f of 0 does not equal f of one the state becomes plus or minus one over root two zero minus one putting these side by side you can start to see the differences in the states we can rewrite the state where f of zero equals f of one as the plus day and the case where f of zero does not equal f of one in the minor state now we do the final part of the algorithm applying a hard mud gate to the first qubit this in the case where f of 0 equals f of 1 brings the qubit to zero and in the case where f of zero does not equal f of one brings the qubit to one now we can measure the first queue bit and we are done with the algorithm if we measure a zero then the function is constant as f of zero equals f of one on the other hand if we measure a one then the function is balanced as f of zero does not equal f of one and just like that we have determined if the function was constant or balanced in a single query even though this may not seem very useful as finding out if a function is constant or balanced doesnt have many applications this algorithm does showcase quantum supremacy and a lot of the techniques used in this algorithm are used heavily in other algorithms from here id recommend learning the deutsche dozer algorithm as is an algorithm that deals with the same problem of finding if a function is constant or balanced but instead of one bit as an input it is a general case that accepts any number of bits as an input to the function 