hundreds of influential speakers from around the world including leading scientists renowned experts in technology book authors and leading academics and makes videos of these lectures freely available um this is kind of a strange talk for me to give two years ago ive done a lot of things that microsoft had been here a long time and two years ago i got asked to join the quantum computing effort and i thought that in itself was kind of strange because im not a researcher im not a physicist im not a mathematician i ship products you know i built a lot of stuff and i write code im an architect and wasnt quite sure what i would do so i started looking around and the first thing i look for tools i build tools i try to make people more productive and i started looking around this whole field at what tools were available and the answer was none there was basically nothing out there everybody would write what they needed for their thesis get it done ship it and throw it away so i started building a platform and then i went around talking to all the top names in the field what would they do with a quantum computer if they actually had one and it gave him some sizes gave him some reason ille technology and they all had things they would do some pretty surprising but none of them had an idea of how they would do it so they knew they had problems to solve but no one really had ways of doing it so this talk is about trying to fill some of that void its a tool that weve built that is evolving that weve done some things further than anyone else has ever done in the field ive thrown back some slides that ive been havent used for the rest of this trip because theres the first computer science based group ive talked to theyve all been mathematicians and experimental physicists and theoretical physicists and i get to put some comp side back in so hopefully some of those slides will be interesting to the audience but liquid is designed so that we can create a simulation environment um to make it easy to really complicated quantum circuits and youll see how complicated in a little bit efficiency a real problem if i could do quantum simulation easily i would need a quantum computer so how big can you go what can you do on conventional hardware and how efficient can you be and actually those are the slides i threw back in to give an idea of how hard that is circuits have to retarget about for many purposes um what i did is started in the middle pretty much how you would for conventional computer science i started with an abstract idea of what a quantum computer is logic gates that level and then work my way up into circuits into if you will assembly code equivalence going up and find that we hit a language at the top that you can actually express in and compile down into that abstract model we did that first now were going the other way from the abstract model down into target hardware so noise what things fall apart communications limitations only certain things can talk to certain things how do you compile down into that how do you optimize for actual experiments youre going to do in the lab and machines are going to build it turns out theres different ways you can attack this because again you cant do it all on conventional machine you can pick specific things youre good at you can be good at noise you can be good at physical modeling you can be good at circuit modeling so weve built different simulators that all plug into the same environment so you can write it once and then run two different simulations and trade things off and then flexibility im an architect i like platforms so how do you make it so you can plug in your own modules change the definitions extend this over time i dont like things that are right and get thrown away six months later so lets talk about the platform itself yes simulating go away how far away is the real computer the one time wheres about were going to talk a little bit about one we can buy today okay so were not that far away in terms of what people will tell you is a quantum computer and the question is it is a paper that just came out that we just did but realistically to a real universal quantum computer minimum 10 probably closer to 20 years thats about the time frame talking about now pieces already exist experiments exist demonstrations exist but the real thing that lets say i put up in the cloud youre going to connect with azure and use it as a service and run you know big simulations on 10 years minimum the yuhlgoel here is the by the time of their lives we want to be ready to program well plus i need to program it so id use this as the front end to program it thats why theres the back end right so by time you get used to running the simulation you could also instead target the real machine so were gonna start with the language i spoke to don last night he said youve got to push f sharp gotta push after don always says ive got to push so ive got my f sharp mug here im one of the few people he has to tell that to ive been using since before it was version one everything ive written in the last many years has been in fsharp and im a functional programmer from way way back so preaching to the choir here but ill show you why its good why it works well this is also why its language embedded quantum operations think link this is a monad thats been implemented inside of the language and weve extended the language in some nice ways but again its a dotnet language so you can come it well it for f sharp can come from scripting level in fact you dont have to compile anything the whole thing would be run from scripts which means we can put this service you can just submit the script you can come from c sharp or any other language that can link with the library so the whole thing is contained in a library you can get to it from any language you like its just for me the most natural and basically designed for f sharp as the top level everything compiles into gates when you see gates think function so everything has a definition a logical gate is just you know a function that implements an and or an oar or specific quantum gates that were going to talk about once this all gets compiled its gets sent to simulators we have three simulators currently the first is a universal simulator this will do anything any quantum computer we might build will do but it comes at a price you can only do on a typical 32 gigabyte laptop about thirty cubits its 2 to the 30th just complex numbers to store and then you have to operate on that so you do the math you actually do pretty well fitting into 32 gigabytes you want another cubit double the memory you know the cubit double the memory so i have a simulation running right now this were going for 16 days thats running in a 96 gigabyte machine and thats nowhere near big enough we actually have a bunch of machines ordered that are a terabyte to do a lot of the problems we want to do but theres another way to go dont make it universal get rid of a lot of the gates that make it that complex to simulate and theres a version of us of the simulator uses only clifford group operations dont have to worry what that is but theyre called stabilizers the interesting part is every quantum error correction code only uses stabilizers so you can do research into very sophisticated quantum error correction well talk about that a little later but i can do tens of thousands of qubits as soon as i dont make it universal so this is where you can trade off the number of qubits versus the operations youre allowed and then theres a hamiltonian simulator this lets you do actual physics and it turns out a lot of the types of machines were talking about depend very much on the actual physics you cant just abstract it away and are times you dont want to there are things problems youd like to set up especially in machine learning that require the actual hamiltonians again this is universal again takes about thirty cubits in 32 gigabytes but its slow so now youve traded off from the universal to make it more physically accurate now you have to run much slower because you have to fix up all the problems of basically doing a differential equation that youre solving along the way it buys you physical modeling so for instance i can actually do time derivatives i can actually watch the times i actually say spin glass problems we can do some of these where i actually have to be flipping key im doing a kneeling and to do a kneeling up the drill to drop a temperature and to drop the temperature i have to actually do not each gate but between each the the interactions between all the gates over time as we go from gate to gate most physical simulation of the machine yes but that doesnt change the appt with each other well no its not too i the way no no if im doing annealing right when you do a kneeling do similar to kneeling on a regular classical machine you have to break it up to do time simulation right youre actually going thats what the hamiltonian will do as opposed to saying if i just went from here at a to be i lose all the dynamics in between i wont get the right answer right is doing the voltage is actually different problem in coding completely right and so we actually have different ways of looking the problem and liquid will let you write it once and then send it to different ones and see how they operate and how they work yep whatever youd like to define if you know the physics youre doing a trotter ization and you get to pick the trotter number so if you want a thousand twenty four steps between each and you want to do the problem is i dont want to go too far down this track but and we can do it offline but the problem is the terms that are in this equation arent commutative and you dont know what order you actually have to have to compute them in because they really want to all be done in parallel so you have to do is do five enough time steps to get rid of the come utility the anticom you tivity problems and thats the trotter ization so by picking a finer and finer cauterization get a more accurate answer but each one is x is twice as slow every time you had a charter number its twice as slow so everything in this game is exponential and you have to trade off very carefully because things can take literally forever run time so have 31 times currently the client runtime this will run on your laptop your desktop you just bring it up put it in the script or write the code it works service its a virus on purpose you sit there here in the lab and you say i have accounts on all those machines on my land itll self install itself across all of them itll become a windows service theyll all look up and talk to each other now you can run ensemble simulations across all the machines in the lab and they have them take themselves down and d install nobody knows you were there theres nothing to tune other than xml file that says here are the machines i have accounts on and heres where to run the executable from everything else is automatic and since we can do that we can go to the cloud you have a cluster you want to run an azure you hear you submit a script it goes off pence ends the script across to i dont know five thousand machines does your ensemble brings it back im using the word ensemble because you dont ever break up a computation across machines youll see why in a few minutes its just too inefficient theres no way you can afford it but most of these are statistical computations so you want to run thousands of them anyway so you might as well put one per machine and then use all the threads available on those machines but nice thing about f sharp its introspective we have reflection so we go download through all these functions instead of running them we have them describe themselves back we build the ast we read the ast and we actually create a data structure which is now the circuit that r is represented by all those functions once you have a data structure we can do anything we want to it we can optimize it and then send it back down through the simulators again we can do quantum error correction we can apply just like you would do in the classical case replace each one of these gates with a error corrected version that runs on multiple bits or in this case qubits at the same time does voting does correction fixes things up based on error models we could do some examples soul of a cat i of this most your computations are rotations there are things you want to move and the problem is physical hardware can only let you usually move in certain discrete rotations this lets you build equivalent circuits that gets you to any exact rotation you want by doing these course ones along the way and so this will say i need a 10 to the minus sixth accuracy angle and this will put the thousand gates together necessary and replace that one angle with the gates you actually have on the physical machine so this is going down now from the abstract level saying here the gates i actually have replaced them all as needed noise noise is a big problem well talk about that in a little bit but if you look at something quantum it falls apart looking at it doesnt mean you looking at it it means the environment interacting with it things d co here no matter what you do and so you have to be able to handle that noise is the quantum error correction but you also have to be able to model it the simulation wont do you much good unless you know whats happening so there are different types of noise bit flips phase flips just bleeding of energy off to the environment as things slowly d cojiro over time all of thats modeled in the system and you can apply that to all of your circuits will show you what that looks like oh yeah oh im going to be doing details i need this is just to show the architecture okay lets get there okay so im going to just quickly finish this export just let you take these data circuits and send them to backends we have two types classical we have people of giant super computers and want to be able to run this so we give them in a form they can do linear algebra and say go run and then quantum as i mentioned you have a lab experiment you actually want to output to control that lab experiment and finally rendering everybody hates drawing all these circuits for technical journals this draws them for you and youll see examples okay lets actually get into things im going to skip the bit of f sharp syntax im going to shoot su most people in the room have an idea but you know  ends our association arrays lists how you call things you can pipe what no looks like and then weve added some operators so weve overloaded all the usual math operators do complex arithmetic nothing you wouldnt expect we have chronic or products we have vector matrix multiplies all these are full precision complex operators there are convenience operators that let you for instance map one gate to a bunch of qubits they do this gate on all these qubits just things that make your life easier um theres just some nice things that say no matter what i have its a bag of stuff look in there four cubits turn it into a legalistic cubits to use so again convenience functions when i talk gates this is what im talking about so these are our bottom level logical operations that weve been talking so an x which is a flip in one dimension so were in three dimensions here we can flip an x flip and why flip and z so hes just saying flip this state its a vector in on a sphere and were flipping wherever its pointing in the x direction the y direction of the z it is well its a unit its yes its a its its always unit and so its only a 2 angles basically right where it sits and so theres two complex numbers and what the arch your pointing at is the north pole is 0 the south pole is one thats the basis here and youre just giving the magnitude in each direction in between those two complex which gives you the phase as well and thats how everything in the entire system looks is this collection of complex numbers that describe a state with all the qubits are pointing in the 01 sphere in effect its actually gets more complicated as soon as you have two of them you cant actually visualize it but one that works um but the matrix is what you have to do thats what you multiply your your two complex numbers by and if its a one cubit gate to get the output of applying that gate so one of them flips it in one direction one room flips it along the imaginary axis one flips it along the in the other case the z axis the z is the north pole and south pole so zero is this way and one is that way um everything including z down z str4 our examples of rotations that are going half an angle further each time so z were flipping the whole way as for moving half t one quarter oneeighth and you can do as many as you want but just showing thats what the rotations theyre just the bottom corner going higher and higher or smaller and smaller in terms of the value identity why do you need identity you multiply you get the same thing out for noise things that just sit there go bad over time so you want to be able to insert identities and watch them going bad hadamard is what gives you super position if i put in somebody who is pointing at the north pole his value is zero and i run them through a hadamard i get somebody whos half pointing at zero half pointing at one hes in superposition so the difference here is think of as a probabilistic bit you can have it anywhere between zero and one with a probability the reason its more than just that it also has a phase so you can point to anywhere the sphere were straightup would be zero straight down would be one they are yes okay and in effect theyre actually in all that its when you read when you try to look at it you get a probability of seeing the zero or seeing the one they become probability when you look at them theyre actually wave functions if you want to be exact the equivalent of inclass compute you have an and gate and build everything out of nand gates here you have a see not so controlled not if the top is a zero the bottom goes through unchanged at the top is a one the bottom gets flipped thats the controlled not but remember its some probability in some directions its a combination of 0 1 and that passes through and get a combination of the controlled not out the other end swap flips the values measure is how you get actual conventional data out you put a qubit in you measure it and with those probabilities youre either going to only get a 0 or a 1 out you get a bit and thats how you collapse everything down to a bit you can of course use a bit to say whether or not to do a gate so what youll see when you see the double bar that means its a bit so theres a bit on top of that x that says if its a 1 do the x if its a zero dont do the x and then finally i want to create a qubit i put in a binary value in this case 0 and i get a qubit back out the other end so these this is pretty much with the zoo at the bottom looks like you just want to give a feel for what youre going to see on other diagrams all of these are unitary operators except for the last three unitary means when i pass them through in one direction i can play them back in the other direction and i get the same thing i started with so every quantum circuit you see outside of when we measure is playable all the way from the beginning to the end and from the end all the way back to the beginning always and there are a number of things that does for you in natural physical side theres no heat dissipation it actually takes no energy to do this youre running super conductive and everything stays in a superposition but what it also means if i had an and gate cant actually do an and gate because you lose information when you go through the end so you have to do two wires one is actually the end and the others the information it back if you go the other way and thats why all of these look like this with the matrices because you can run them in either direction okay hello world is what we would do for the canonical example for conventional lets do the canonical hello world for quantum which is called teleport alice and tangles two qubits so we have two qubits on the left starting in zero were going to superimpose the one qubit so hes between zero and one the controlled not entangles them together so this is called an epr gate or an epr circuit einstein podolsky rosen i always get it wrong but all it means we have two qubits that are maximally entangled at this point they completely share mutual information we somebody wants all flat explain all the math and how it all goes together but bob is going to take one of the cubas to the other side of the universe ok bob walks away with this guy alice is given a qubit with a message on it its somewhere on that that sphere we talked about a vector pointing somewhere she entangles it with the qubit she still has and then shes going to measure both qubits know what i should mention is as soon as she entangled it bobs qubit changed no matter where he is in the universe and he actually has the answer but it turns out he cant see it the answer is encoded in a way theres no way so we didnt it looks like we broke relativity that we can go faster than the speed of light and take this thing from one end of the universe and send it to the other but the information hasnt been transferred yet the state of the qubit changed but you cant do anything with it until she actually reads out the state of her two qubits trance them but transmits them by a classical channel which means now shes got to send these two bits across the universe were back to the speed of light and then bob can use it to decode the qubit those two bits are enough to get back an infinitely accurate representation of what was put in so he was able to transfer a lot of information but he still needed those two bits to get it back out dont worry about what it all means what im trying to show is the way these circuits work they look like a staff of music each one is a qubit you gates on or between them along the way and everything moves left to right this is how you draw a circus this is how the gates look in them and this is believe it or not about the simplest example you can do our bob recovers the sent message and everybodys happy lets actually look at the fsharp code okay again im not going to detail this isnt a course on quantum computing im trying just give a feel for what this looks like when you play with it i should also mention i didnt draw this circuit when you write the code the circuit comes out automatically so everything gets rendered for you as you go so that epr circuit is just an fsharp function it takes a list of qubits for its a hadamard on the first element in the list and a controlled not on the first two elements of the list so you can hand in variable lists and all the gates operate on however many qubits they need from the top of the list the actual the rest of the algorithm teleports a function im going to name the first three cubits in the list im do an epr function on q1 and q2 see not the first two and how to marred measure it by a control it measure it binary control it and theres the circuit so its not a lot of code you can very quickly build these up and of course each one of these you build is a gate or is a function and so you can build them all the way up as deep as you like theres also some soo degay pseudo gate so i can put little labels like the source and the zero and the destination on there i can do some simple optimization fold says move everybody to the left that doesnt hit someone else this is things you could do in parallel in a machine and now everything lines up nicely looks prettier if youre doing a journal article instead of saying giving me svg code in html you can say now give me latex source and so this is q circuit output inlay tech so every paper weve been publishing it just auto generated by the simulator all the circuits we do now this is this the slides i threw back in for this audience just to show you what it takes to do this on the computer science side so we have these gates the gate is a unitary operator thats 2 to the n by 2 to the n and so if you have n qubits thats 2 to the 30th by 2 to the 30th its big the state vector keeping track of all of these qubits is also 2 to the 30th in size you multiply each of these gates by that so if you do this its extremely inefficient takes ridiculous amounts of memory its not pretty you run out of simulation address quickly you run out of memory quickly everything just goes bad the state itself only gets that big when qubits are entangled like we showed in the teleport example so if things are in registers theyre separate from each other you really dont need that big a vector youll have to keep the things that are entangled together other things that are separated or very small when you start out with 30 cubits it only takes 30 memory elements the entangle two of them those two just became for entangle that with another two that becomes 16 and so that if you keep track of the entanglement you can be very efficient about the size but you cant compress it further its dense at that point theres nothing else you can do with it the operator is really sparse may just have these yep probabilistic way and when were doing inference and machine learning context in very large state spaces somehow we always never try and actually represent every possible state exactly and i guess its certainly if there are known in dependencies between the levels of qubits and we factor thats a way of reducing and the state start easy but then nice people often use approximations that can be extremely accurate cant do it here and the problem is its not probabilistic its fully deterministic until you measure it and those effects can be extremely fine grained you dont know to the end what you can approximate there is nothing you can approximate is where you fall apart here let me i did large scale you know machine learning for years and that was great now i can take massive problems and you know the size of the web right and bring them down and here you dont have the luxury you actually have to keep every you know full precision complex number all the way to the end and then you can actually measure it out probably in throat away but you dont know until the end because youre actually keeping all the fine grain interactions you dont know which ones are important and so its frustrating as hell but if you really want to similarly what goes on in the machine you cant throw it away thats sort of the bottom line we can talk about it if you like okay yeah so the prop you have a really sparse operator but again its its massive and its hard to keep track of and remember even if ive got a little gate i have to expand it out to the size of the state vector to multiply the two so i have even for little gates i have the same problem so when act to the standard talk this is just f sharp code so we put it in a classical rapper you call the function just like any other phone classical function in here every top initial one is a random state vector we started with simons question theres your magnitudes on the complex number on zero the complex number on one saying where that vector is in the sphere we go through we read out the bits that says whether do the x or the z flip and lo and behold we get the same vectors back out you know hello world works this is the equivalent of you run it through comes out you get in hello world everything worked your simulator actually does something useful this can also be run as a script so youve got multiple options you can just run fsi directly on the script and say do it you can do a use which lets you stay in the simulator after it runs you can look at the states and the values and all of that you can have liquid run it for you which will take the script compile it into a dll and then reload the dll back in of course now you have a dll s you can also run the dll directly its got lots of options from a script level if you dont want to actually get into visual studio environment i said i wanted to make this fully extensible heres the actual controlled not gate this is all the code for it everything thats in here can be rewritten by the user can be extended they replaced and so you have a name for it some help you have a sparse matrix definition that says here are those elements of the matrix i showed you on the earlier slide and drawing is the latex commands for q circuit parameterised so you can say put this on this cubic but this here heres how i want to drawn and thats it so thats all you need to do to do a gate i also said you could take those same functions and turn them to circuits this is how you do it into a data structure a circuit compile of the teleport function give it some cubits if i say dump the data structure back out you get back out a definition of all the different gates that were in teleport what matrices what wires there on and then from this you can go to anything you like and go a supercomputer you can go to actual control of a system you just want to show you how compact this can be this is an entanglement test that says superimpose one cubit and then entangle it with everybody and then measure them all well since everybodys fully untangled if i look at one of them theyre all going to collapse to the same thing so if you look we get with about fifty percent probability sometimes well get zeros sometimes we get ones no matter which one you looked at first all the others collapse to the same thing to generate that circuit we created a function that just said hadamard the first qubit remember him mapped to the tale a scene up between him and everyone else and then map a measurement across all the qubits so you get very complex very quickly with very small amount of code parallel version this is a little more complicated version that i said fold it and now everybody moves in time the 48th time steps really only takes ten time steps to execute so you do analyses of sequential versus parallel times on a target computer and see what it would look like this is the actual f sharp code not going to go into it in waiting is interested i can i can explain the lines but thats how we generated the previous circuit and this is it running so this is 20 entangled qubits takes about two seconds thats in the brackets each time we get all zeros and all ones as wed expect this is running on my cluster so anywhere from 80 to 100 percent utilization that took a thousand runs of 22 entangle qubits in three and a half minutes so now were starting to get into some more interesting scaling it yeah yeah this is all universal only talking universal at this point so this you can do anything in this one um well lets do some thing that everyone knows shors algorithm lets factor okay thats it soon as you say quantum everybody says oh were going to break our essay and not so much but this is a simple circuit i should say the biggest number you see in any of the published papers factoring is the number 15 okay four bits four cubits in this case as a 4bit number takes eight nine ten eleven cubits to do the circuits actually 8200 gates one of the nice things about the circuit renderers you can say give me different levels like this is a more abstract level i have mutt modular multipliers here as units i could say go inside of those show me the circuits go inside of those and go at any level you like but like i said four bits ad tourniquet thats about what everyones done weve done 13 bits which was the number 8189 its about half a million gates and the one running at home i think i mentioned at the beginning well go for 28 days and hes doing for a 14 bit number at the moment just to show you what the circuits look like this is the modular adder you have sharp code i wont do it in detail but theres a controlled controlled adgate so heres the problem you want to add two numbers together and you want to keep them from overflowing its a modular adder simple except the entire circuit has to be reversible as i said earlier everything has to be kept unitary so here we do the controlled control dad and were actually doing this in fourier space so now that weve done the ad we have to bring it back out we do an inverse excuse me this is the yeah this is the inverse of the no its not the qft this is an ad oh im sorry were going to subtract off the number that were modding to see if we over float or not so we subtract the number off now we take it out of fourier space we do an inverse qft quantum fourier transform and we remember the top bit if the top bit overflowed we know we have to go back the other way otherwise we dont so we remember the bit in an ansel ax or the qubit in this case now we put it back in the qft now we really do the ad based on whether we would have overflowed if we had done the ad so this did the modular ad and now the whole rest of the circuit were going to an inverse add inverse qft were going to clear top cubit we have to leave everything back the way we found it so hes got to go back to being a zero now we qft now we add again and now were done and you can run this circuit forward and backward and everything is left in the right state and everything works correctly but this is why its not as trivial as just say take your classical algorithm and drop it into a quantum algorithm either we are working on that also someone else has a simulator theyve written where you take a classical algorithms say make this reversible then take that reversible algorithm make it quantum so were going to be adding that thats higher level things were adding to the simulator over time okay so what do we get when we do this heres an example of factoring all sorts of numbers times they took probably much easier to look on a graph the blue diamonds are the first version of the simulator we wrote second version is the red and the orange is as of two weeks ago so we went from three years to four months 24 days to do that 13 bit number and as i said the one thats factoring at home the red line would be a month it looks like this will be about 28 days to factor for the last one and thats not anybody cares thats you know my dog can talk not how well my dog can talk but again most everything published to this date has been way down all the way at the lowest on the left is the biggest anyones done before this so this just gives you an idea the complexity of the full universal simulator what youre able to do the promise of factoring big numbers my using gotomeeting we could do it way faster than we could an orderly computer mmhmm however i was here factoring a yahoo could be done really fast so theres a really very normal slow down factor for so between so the promises the corner beauty is going to be fantastically much faster yes here its kind of like taking months to do something oh no no but this is do this is doing a simulation of a simulation of a simulation so the real quantum computer will do this blindingly fast okay im doing all half a million gates and having do them on a classical machine to simulate them if i actually was doing this i can do this on a quantum computer thats actually not the prime very fact i can break our essay on a chronic peter the problem is the number of qubits it takes number of gates it takes to fix up all the noise along the way to get there and on and on us when you actually yeah and so for some and im going to show you places where its not where we actually do get an exponential win but factoring works but the actual technology you need to build the machine is a good 2030 years away before you could really build the machine to break our essay and by then rsa is bigger or whatever youre going to use for cryptography there is also quantum cryptography by the way you can really nicely entangle those qubits like we just showed you with bob and alice and if anyone eavesdrops on it you destroy it so anybody trying to look at the channel will destroy the channel so you cant get the information without somebody knowing and then they cant get the key because the key was moved quantumly and on and as a whole quantum key cryptography area to um so lets talk about noise a little bit im not going to go again into detail its one get of a field theres an abstract class you derive from and say i have a quantum error correction code i want to try this happens to be whats called a steam 7 code and this guy generates a circuit that says given one logical qubit replace it with 7 physical qubits and this encodes the seven into that code space so i now have a nice encoded value that i can check for errors as we compute this is the guy that actually does the checking so the bottom seven is the encoding of the logical qubit the top six are the ones who read everything on the qubit measure it out and then decide to apply x and z flips depending on what went wrong and so this will actually fix all one qubit errors will detect all 2 cubed error sounds just like you do normal coding classically but this keeps everything quantum this lets you actually apply this throughout the system and this is what our friend teleport looks like once you run it through this quantum error correction application it goes through and rewrites the circuit with and of those syndromes and then every place you had an ex gate you now have seven of them or the c knots or any of those other gates you saw you now have seven copies that happen at once and then you check if we got what you expected so yes your number of gates blow up very quickly and the number of qubits blow up very quickly we also finished a brand new noise model thats much more physically accurate whats nice as you can say specific gates have different noise models you can say how many qubits are going to operate on how long in physical time the gate takes to work a see not a to cuba cape may take a lot longer than you know in 20 to 50 nano second stead of 10 nanoseconds for an x gate and then you provide a noise model for what you want to use so now for different types of qubits different types gates even in the same system they may be hybrid you can apply your own noise models the system gives you back events this noise event happened at this time on this qubit on this gate and this is what it did also your error correction circuitry is also going to be noisy and thats a problem it turns out if your gates arent good enough about the threshold the error correction makes it worse because youve added more gates and the gates are noisy and everything gets worse so you actually wind up coming up with a threshold value of at what point to your physical gates have to be how good are you qubits before you can even fix them and so theres a whole interesting area christus evora who heads the research group thats her expertise thats her main area is noise modeling and correction but the one thats new that again nobody has is we actually do non unitary noise we do whats called amplitude damping so if you read in the papers you know ibm now has a qubit that lasts one or two milliseconds sometimes you hear t1 there t1 time for decoherence thats this you can we can now model actual decoherence of the individual qubits as youre going you can actually put different probabilities on different qubits so you have semiconductor cubed you have quantum dots various other technologies you can put different decoherence in so heres a simple circuit again ive got a how to marge some super putting a superposition two cubits and im see nodding together and then a bunch of idols infinite number of idols what happens well heres what the damping probability what happens we start out with twenty five percent probability for each of the four possible states because you could read out the other at 0 0 0 1 1 0 1 1 when i measure it but youll notice everything with a 1 and it starts falling off and the zeros start climbing and then we get this non unitary event the thing just d cohered and so two of them drop the 0 2 of them popped up a little basically the first qubit went to 0 so the 10 and the 11 state disappeared and now you can see the 10 keeps keeps bleeding way to the environment is the 00 keeps going up until he d coheres now everybody is 00 youve lost your qubits theyre gone so this first time that i know of anyones actually built a simulator that will actually let you do the physical modeling of whats happening with the qubits and for sanity check we took our friend teleport added quantum error correction on top of it the steam 7 code put in some probabilities that were published by others for actual physical qubits and we going to fall off at about 3 minus 3 where the whole thing cant keep up the code cant keep up and theres this threshold and it turns out thats exactly what steam predicted the threshold would be right in that area for when you have physical qubits and they look like this this is about where everything would stop working so about 3 d minus 3 has to be your your t one time for your qubits if you want to be able to correct them if you cant keep them at least in this millisecond range youre not going to be able to fix them um yeah kind of honorees of how these you busy ever again i mean let me let me let me give you hope the reason microsoft is in this at all is we have an area were working in and our focuses is called topological quantum computing and i can talk to people separately about it i wasnt going to do it in this talk about meyer anas and these quasiparticles were using but it turns out instead of having say a single electron that youre flipping the state on you actually have a particle that two of them make up the electron or the fermi on actually and theyre really one item but theyre separated in space so these decoherence of x effects if they hit one of them they dont hurt the other one you have to hit both at the same time extremely unlikely the times for these look like they could be in the years you dont have the equivalent of computer memory where these qubits can last virtually forever it also means your error correction now became easy because they dont go away you can you actually the gates are done by braiding them around each other so as long as you braid them and you dont get them near each other you can actually do all of these gates and you have fully fault tolerant computing now theres lots of caveats im gonna leave all of that out for now but the point is this is why microsoft is so interested we have the only fields medalist working in industry michael friedman whos down in santa barbara and its station q and this is what we focus that whole effort around is these topological qubits now in semiconductor cubicin like you up into the milliseconds range no reason it cant go higher and thats enough you know as soon as we get into the tens of milliseconds and a little beyond we can correct them we can keep them alive forever so were on that the verge even for the more traditional or conventional qubits so it looks pretty good oh its all done superconducting let these are 20 millikelvin most of this is run at i can talk about fridges too i got lots of pictures on my phone that people want to see ive been ive been going to all of our labs and europe is why im here and so weve got some very cool experiments going on im just going to mention the stabilizers these the ones we can do tens of thousands of qubits you can take your normal circuit you compile it into stabilizers this is teleport again running and stabilizers im not going to do any detail here but for people who do this work you can also get statistics out of where you are in the stabilizers and what the space looks like but all of those error corrections we were looking at only were flipping x and z and turns out stabilizers know how to do x and z and so you can do all your error correction let me do a machine learning ok page rank were going to start with a standard stochastic probability matrix the g matrix or google matrix if you like but were going to turn it into a hamiltonian i think the identity minus g adjoint it and identity minus cheat turns out that gives you a hamiltonian that represents those stochastic probabilities converted to a unitary this is gets back to our hamiltonian simulator we were talking about so now remember the unitary czar and we have all their from a starting state of static probabilities you know the one over n you would use for pagerank type thing and then we do an adiabatic evolution i wont describe the term unless somebody wants at the moment but theres a way to do these hamiltonians and guarantee you can get to the lowest energy state we accumulate the average probabilities so here i do a synthetic web graph using recursive matrix generation so its a nice power law graph 256 pages by the way takes eight cubits so i can do two billion pages and 32 cubits and shows you very quickly we can do big problems on tiny machines in here you can see regular page rank and quantum pagerank we get the same answer this is good i can do extremely dense encoding and i can pull pagerank off ah theres a bunch of caveats youd never do this in real life and i can tell you all of them but lets just say it takes you exponentially long to actually get this answer out its there it works but you wouldnt do it this way and the problem i have with a lot of the papers out there everyone leaves the real costs out and so what weve been doing a lot is i wont ill use the word here debunking a lot of thee this is exponentially faster no it isnt you know this is quadratically faster well only if you ask the question once and only want one bit of accuracy out you know that type of thing but dont worry im going to end on a positive note you know its not all bad news this is talking about the hamiltonian simulator now one of the most popular or useful techniques is called spin glass so what youve got think of boltzmann machines think think of just standard simulated annealing i have something that can flip up or flip down im going to hook them together with strengths positive and negative and i say go and everything flips around and id lower the temperature until everything stabilizes out okay standard technique the way we label it here or do we do it here the first term in the xdirection basically is think of it as your temperature if i have that really strong i turning off all the other links or im overriding by saying push everybody in one direction im going to make everybody go in the x direction im going to lower the x direction and increase the h eyes are saying im going to clamp somebody up or down so this would be like the inputs to your prob right youd say these are my input ones that are a 1 0 1 1 0 and then the ji js are connecting them with everybody else you let this thing cool down and all the others flip to an interesting state and some of them you defined as your outputs and this is normal simulated annealing miss known as a spin glass problem theres a company in canada called dwave who ships a quantum computer back to the question of when were going to see quantum computers at least thats what they say and we can reproduce on the simulator everything theyve published in nature and science and all the rest give an example using ferromagnetic chains we turn this into a circuit so what youre seeing is the first column or all the xs then im clamping the left and the right because the ferromagnetic chain and say theyre up there down there opposite and then im going to link them together those are the ji js and finally at the end ive got the exs again because were doing a higher order approximation back to the other question on trotter ization you can ask for higher order trotter is a shins as you break the differential equation apart be more efficient and we get all the answers that everybodys published and we can do noise modeling and tangle matt entropy all sorts of other things on here youre interested this is going into nature its being out for review right now but they let us put this up theres been so much buzz they let us put it up on the archive and theres a link there if anybody wants to read it theres a big big paper on this and all the details traveling salesman heres an example of a hamiltonian for traveling salesman what youre doing is encoding the edges so youre going to say i want to drop down edges between cities oh they are i know weve reached eleven oclock so its okay okay im getting to the end here and anyone who wants to leak out feel free its okay i just want to mention the same problem with doing this classically is weve just naively put in traveling sales when you start getting problems where you get disconnected roots instead of the full because there is no higher order constraints we can do eight cities twenty eight cubits other people publish papers saying oh a higher order constraint lets me do more like a four body instead of a two bodies simulation yeah i get a doubling in the speed this solves at butts four times the amount of work and thats the part that gets left out of the papers and egopay poems in terms of what no no no no no no never said that all im trying to do is reduce the prefactor okay i never made a claim that you know p equals np or b qp is p or any of that no no no okay ill finish fast unfortunate this is probably the best part of it but well just leave it i took too much time on the other theres another hamiltonian model second quantization this lets you do molecular chemistry um this is h to two hydrogens together this is simulating it the blue is our simulator compared to publish results we actually get more more accurate results were actually telling you naturally where the two nuclei will come together to balance out the energy you can run the whole thing from script mode you can run this on a cluster this is all of water being simulated so this actually is doing bond lengths and angles to show you what a water molecule this is were back to what fineman said youd use a quantum computer for is simulating quantum physics again we get different numbers and the traditional approaches but you solve it exactly what we get is exactly the right answer to the precision we asked for the problem here this takes thirty four thousand gates then you got to run a two to the 14th times get 14 bits back to see then another two to the 10th time to get rid of the cognitive ed problems and then about 50 samples per point to make sure you got the ground state and 546 points for the plot this is 10 to the 16th gate ops we can cheat and so we do with the quantum chemist oh im not going to go into this now everyone interested this is a linear algebra you can do to get your two to the 15th by 2 to the 15th matrix down to 441 by 441 oh and by and once youve done that your exponential powers of two just become matrix multiplies times themselves and thats how i solve this actually okay i cant actually run the gates for the length of time it would take these are all the raw numbers for if you now add oh i dont have all the rotations oh i have errors all high oh this gets very big and in fact theres an irp challenge using a molecule called ferredoxin which takes about 10 to the 23rd gate operations thats a century and a half at current technology speeds back to when will we have this however weve come up with a new technique that will let you take the scaling down from n to the fourth where n is the number of orbitals of the molecule down to n squared with no reduction in error and in fact if youre interested this isnt out yet but theres a paper coming that if you notice at the bottom theres a 58 billion gate operations needed for ferredoxin weve got it down to thirtyseven thousand which took your century and a half down to a week and a half now its reasonable and thats with todays cubed technology in terms of speeds so weve now reached a point where we can do it you build a machine that can do this you can do much further than chemists can do today they can get to maybe a hundred orbitals if theyre lucky we can get the hundreds above that and solve very complex molecular problems im going to give you one more example that im also working on right now with matthias you can also do simpler hamiltonians you effective models and when you do that this is called the hubbard model this scales linearly with the size of the problem so i can actually simulate entire sheets of superconductors and design hightemperature superconductors this way so in fact on the right is from a paper he previously published on the left is liquid simulation of the material these r coupe rates which are hightemperature superconductors and by the way the numbers arent the same because again we went built it did the simulation and found their numbers were wrong so in lots of cases here when you actually implement it give you one example shors algorithm when we implemented it we found the paper was completely wrong they left a gate out that all you get is random answers you will actually get the real solution and no one ever knew it because no one ever simulated it and theres lots of documentation i can give anyone who wants this paper were actually going to put it up externally which is just an overview of what this talk talks about its also an 80page users manual theres msdn documentation and thats probably enough for today so im here for two days anybody wants to talk my schedule right now is wide open and im at your disposal questions sure in the remark and you were saying you need to keep track of the whole space them either no theory around you know getting inside from what youre going to query in the end and get some variation of bounds profitez your entangled as soon as you have entanglement you cant even look at the state im one of the things we didnt talk about in here at all these debugging how do you figure out where you are in all of this even before you can do it variation else i even have to understand the system and i cant and i have there a bunch of techniques weve started putting quantum debuggers together but you cant like single step and ask what are the values of the variables because its distributed across two to the 30th elements what do you do well it turns out there are ways you can make believe you measured we can do things youre not allowed to do quantumly but thats a whole separate we can talk about but its really its its terrible you cant buy that you also cant clone these are linear types if you prefer once youve read it you cant read it again and its gone from where you read it so you cant copy anything you cant look at it without destroying it on and on and on and on now again were simulating which means we can cheat so things we can do you copied all the state vector and do stuff to it thats illegal and then keep the rest of it going okay but even so the analysis is such that i said if they werent entangled i could bring this thing down i dont know when things arent entangled you have to tell me as a user ive just separated these the circuit did the right thing there now disentangled but you can say check that im right which is extremely expensive and it goes through and figures it out and lets you know if it is then it really disentangled otherwise it says you have a circuit bug that type of thing so we do have all of that implemented but automatically in any efficiency being able to do that is virtually impossible frustrating its fun but its frustrating yeah for the results age talked about at the end of your talk on molecular simulations how much of that is done using your current simulation and how much of it is waiting for actual quantum computer all events with the current simulator all of it now should let me caveat everything through water water h2o i can fit in under thirty cubits the others i can compile the circuits and get all that all the numbers in those tables are from the simulator but i cant run them right but we verified the techniques were doing this multiresolution trotter ization that we can actually throw away ninetyeight percent of the matrix this is again do its basically doing a multiresolution decimation of the matrix so we precondition the matrix to figure out what doesnt matter and throw them away below the accuracy you care about and by doing that these are a lot of its standard linear algebra techniques or hpc techniques that have never been applied in this field so but in answer to your question all everything you saw up there of h 2 h 2 o those have all been fully simulated and actually water only takes about a minute for me to do once ive done all of those classical tricks on a quantum computer it would take longer actually because thats do all the games give the transition from the gaze to the amazonian a gate is a summary of a time step of a hamiltonian so e to the i ht is the unitary so over a period of time when you run those gates they go to a steadystate so the x the y the z that the hadamard see not i will steadystate solutions to apply in the hamiltonian that so the hamiltonian is the transition to get from one to the other normally thats fine if im doing digital operations then im fine im saying i want to flip this bit well i have to move it after actually moved the qubit and flip it and thats the hamiltonian doing that the unitary is the effect of that as as simon was saying that you know the whole point is why cant i just do that well the problem is if im doing spin glasses and things theyre all flipping and while theyre partially moving theyre talking to each other and so now i actually have to go down into the hamiltonian actually do traveling salesman or or whatever the machine learning type problem and mapping on to it pagerank is like that for example you are solving trig equation yeah the hamiltonian does is full schrodinger wave equation basically yeah april like i said im available 