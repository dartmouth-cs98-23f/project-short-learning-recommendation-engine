channel welcome to the brand new series on git in this video we are going to see why we need version control key benefits of using version control two major divisions of version control one based on topology of the project and another how we represent the versions so based on the topology we have centralized version control and decentralized version control centralized version control example is svnda centralized version control is git based on how we represent version it is classified into snapshot based version control and delta based version control and we will also see what is good and benefits of using git and introduction to key terminology in git this is part one of this series we will cover a lot about git in the coming videos if you havent subscribed till now try subscribing this channel that will motivate me to put more videos and thanks if you have already subscribed this video is divided into chapters so that you can navigate to any particular chapters with the timestamp we are going to see why we need version control in the first place and why it is mandatory for a developer to work with version control version control is a system that requires changes to a file or a setup file over time so that you can recall specific questions later version control is also called as revision controller source control for example you are editing image today and opening it tomorrow and making some more changes then you feel like you messed up something today and we want to go back to the previous version which you have saved yesterday one way to handle this without version control is save each version daily make a copy of yesterdays version and work on it this will work well if you have minimal change and what happens if you are working on a very big project which spans over a year and daily you want to create multiple versions on one biggest problem is it will become clumsy and data size increases what if multiple people want to contribute to the same project this is where we need version control and provided we are working remote now the version control tool is mandatory if you are a graphic or web designer or a software engineer and want to keep every version of image or layout or code base which you would most certainly want to a version control is very wise thing to use it allows you to revert selected files back to a previous state revert the entire project back to the previous state compare changes over time compare between different branches and see who last modified something and that might be causing a problem who introduced the issue win and more using a version control also means if you screw things up or lose files you can easily recover in addition you will get all this with a very little overhead there are lots of benefit if you use version control system now we will discuss about some of the key important benefits first thing is code together now in current world code together is very essential because you are from any part in the world version control synchronizes versions and make sure that your changes dont conflict with other changes from your team members your team relies on version control to help resolve and prevent conflicts even when people changes at the same time so developers can work remotely and still make sure that the changes are not conflicting with each other and they can work on same feature parallely if theres a conflict they can resolve at the earliest stage possible for example there are two developers who are working on the same project one developer commit the initial version to the remote repository and another developer who can be working from a different geographical area can take this file and modify this file and push it back to the same remote repository by this way they can code together on the same code base using this version control tool next is versioning think the software which you are creating as different versions in this case you can easily create multiple branches and that multiple branches can support different versions so version control allows you to save changes to each version individually and without affecting other version and you will also work on multiple versions parallelly you no need to wait for one version to go to production to work on the different version next important thing is keeping a history version control tags the history of changes as your team saves new version of code this history can be used to find who when and why changes are made and even what changes are made history gives you the confidence to experiment since you can roll back to any previous good version at any time history lets your base work from any version of code such as to fix a bug in the previous release for example here there are two developers who are working remotely each commit made by a developer has the information such as when the commit is made who did the commit and descriptive message developer added to the commit change history and unique commit hash we also have some of the very important benefits in todays world that is cicd version control automation features it saves your team time and generate consistent results ultimate unit testing static code analysis security vulnerabilities at the earlier stage possible and deploy when the versions are saved to version control and you can even set up your own continuous integration continuous deployment to a code base so that whenever user commits to a particular branch it will be deployed to any environment possible and you can also automate different tasks whenever a user commits to the repo workflow version control workflows prevent the chaos of everyone using their own development process with different and incompatible tools version control system provides process enforcement and permissions so everyone stays on the same page for example lets consider two developers working on a javascript project for which they are not using version control lets take one using gulp js to automate time consuming task and another one using grunt to automate time consuming task now when they want to merge their code they need to use not two but one so it requires substantial changes to unify the project to same tool this can be avoided easily if everyone is using version control from the day one and version control avoids this kind of conflict next we will see about two major divisions of version control there are two major divisions one based on the topology of project and another based on how we represent the versions based on topology it is divided into centralized version control and decentralized version control centralized version control systems are based on the idea that there is a single central copy of your project somewhere probably on the server and programmers will commit the changes to the central copy committing a change simply means recording the change in the central system other programmers can see this change here checkout means taking the latest version of code from the central server and history will be always preserved in the server only if server data gets corrupt the user cannot get the history of files example of centralized version control systems are svn and cvs people are not using centralized version control system much people have moved towards decentralist there are some legacy applications still using svn so understanding svn also vital if you are supporting a legacy project next we will see about decentralized version control decentralized version control system do not necessarily lay on a central server to store all the versions of a project file instead every developer machine clones a copy of a repository and has the full history of the project on their own hard drive this copy our clone has all the metadata of the original the act of getting new changes from a repository is usually called pull and the act of moving your code changes to this capacitor is push in both cases you move change sets that is changes to file groups as a coherent holds not single file difference advantages of using decentralized version control performing actions other than push and pull change senses extremely fast because the tool only needs to access the hard drive not the remote server so for push and pull you need active internet connection if the server is down or server data get deleted the developer will have the history of files in the local one developer can clone a version from other developer since we have history of files in their hardware examples of decentralized version control systems are git and mercurial now we will see based on how we represent the version it is divided into delta based version control system and snapshot based version control system delta based version control system store information as list of file based changes this system thinks information restore as a set of files and changes made to each file over time this is commonly described as delta based version control so we will see this with the example here i am creating a file named testxml i am committing this testxml for the first time so this is the initial version first it stores the complete testedxml file i am committing again without doing any modification to the testedxml this will be stored as the version 2 in the version 2 no code changes are stored now i made some changes to the testerxml and committing it again now it is stored as version 2 only the modified information is stored here 36 card replaced with 40 so it stored the delta as 36 as deleted and 40 has added and i added react and get to the content so it is stored the delta as iot python react git as newly added and iot python got deleted in the delta based version control not storing the full file only the changes are stored as the delta now if you rename the file testxml to test underscore rnxml it will be stored as file rename and this will point to the original testxml what is snapshot based version control this system thinks of its data more like a series of snapshots of a miniature file system with snapshot based version control every time you commit or save the state of your project it basically takes the picture of what all your files look like at that moment and stores a reference to that snapshot to be efficient if the files have not changed it does not store the file again just a link to the previous identical file it has already stored git things about its data more like a stream of snapshots we will see this with the example here we have the same testedxml and i am committing its initial version here it got saved as complete file with a unique hashcode for the sake of simplicity lets take the commit hash as x8n so this is the ash code here x8n hash key holds the complete file information i am committing the testxml again without doing any modification so now in the version 2 we have same commit hash for the file which refers to the initial version of the file i am committing another version by adding some modification to the text xml now this will store the complete file with a new hash code this is the main difference between snapshot based version control versus delta based version control as we seen in the delta based version control this got saved as a delta file difference whereas here in the snapshot based version controller it is saved as a complete file with a different ash code representing this commit if you rename this file from testedxml to test underscore r and xml the file got renamed but it still points to the previous commit hash if you are familiar with git you find some discrepancies here with the file name we will cover more about this when we discuss git mv command in the coming videos next we will see why we need git git is the most commonly used version control system today git is mature actively maintained open source project originally developed in 2005 by linux star walls the famous creator of the linux operating system kernel a staggering number of software projects lay on grid version control system you may be very familiar with github kit lab bit bucket all those are laid on git technology including commercial projects as well as open source these are important benefits of using git git is a distributed source control system and snapshot based version control system git does not necessarily lay on central server to store all the versions of a projects files instead every developer clones a copy of a repository and has a full history of the project on their own hard drive git scales massively because of the distributed nature of git it can scale massively git is initially developed for linux project requirements today linux kernel has over 15 million lines of code and more than 1200 developers across the globe and git is free and open source there are many commercial projects which are based on git and you can also find free and open source system which are based on git one great example is github because of its distributed nature most operations in the git are local so you might not need active internet connection most often git as a very active community and it is evolving day by day it has already become mature but it is evolving day by day so that most of the answers which you are looking for is already answered by someone so it has a very active community and you can find answers to every problem you face now we will see about some of the key terminologies and basics about git every time you save your work git creates a commit a commit is a snapshot of all your files at a point in time if a file has not changed from uncommit to the next git uses a previously stored file commits create links to other commits forming a graph of your development history you can revert your code to the previous commit inspect all files change from one commit to the next and review information such as where and when changes were made commits are identified in git by a unique cryptographic hash of the contents of the commit because everything is ashed it is impossible to make changes and lose information or corrupt files without git detecting it each developer saves changes to their own local code repository as a result you can have different changes based of the same commit git provides tools for isolating changes and later merging them back together a branch and git is simply a lightweight mobile pointer a default branch name in git is master but this is completely customizable as you initially make commits you are given a master branch that points to the last commit you made every time you commit it moves forward automatically branches which are lightweight pointers just created for each and every future are epic once your feature are epic is completed and you have tested that feature then you can move the branch to the team main branch so here branches will be created for individual developers so if the developer works on a particular feature he or she will create a branch tagging that particular feature once that feature is done he or she can merge it back to the master branch files in git can be in one of the three stages one is working directory next is staging area and the third is the remote repository when you first modify a file the changes exist only in the working directory they are not a part of the commit or your development history here i have created three files html a css and a image file in this working directory you must stage the files you want to include in your next commit here you can do that by using the command git add and pointing to the files you want to add to the staging area and you can even omit files that you wish to commit separately by doing add with one file and then you can commit and you can add another file and then you can commit here i want to stage only the css and image file so that it will be included in the next commit the staging area contains all the changes that you will include in our next commit once you are happy with the staged files commit them with a message describing what changed this commit message might be really important because this may be served as a documentation for you and your teammates this commit becomes a part of your development district here when i hit the commit the staged css and image file got committed here everything happens in local so it does not require active internet connection if you are from a svn background or centralized repository background then their commit is different and here the commit is different in svn world if you commit that means you are pushing to the central repository but here if you commit you are pushing only to the local repository you are not pushing to the centralized global repository or the remote repository so all the operations can be done offline here once you are finally okay with the changes you can push the local commits to the remote repository this is when you need active internet connection because you are trying to contact the remote repository i believe you have learnt a lot in the first part of this kids series subscribe to this channel for more videos on git and hit like if you have enjoyed this content and share it with your friends thanks for subscribing and watching this video 