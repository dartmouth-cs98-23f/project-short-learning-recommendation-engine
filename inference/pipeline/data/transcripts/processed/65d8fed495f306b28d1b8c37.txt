provided under a creative commons license your support will help mit opencourseware continue to offer highquality educational resources for free to make a donation or view additional materials from hundreds of mit courses visit mit opencourseware at ocwmitedu ana bell all right lets begin as i mentioned before this lecture will be recorded for ocw again in future lectures if you dont want to have the back of your head show up just dont sit in this front area here first of all wow what a crowd you guys were finally in 26100 60001 made it big huh good afternoon and welcome to the very first class of 60001 and also 600 this semester my name is ana bell first name ana last name bell im a lecturer in the eecs department and ill be giving some of the lectures for today along with later on in the term professor eric grimson whos sitting right down there will be giving some of the lectures as well today were going to go over some basic administrivia a little bit of course information and then were going to talk a little bit about what is computation well discuss at a very high level what computers do just to make sure were all on the same page and then were going to dive right into python basics were going to talk a little bit about mathematical operations you can do with python and then were going to talk about python variables and types as i mentioned in my introductory email all the slides and code that ill talk about during lectures will be up before lecture so i highly encourage you to download them and to have them open were going to go through some inclass exercises which will be available on those slides and its fun to do and its also great if could take notes about the code just for future reference its true this is a really fastpaced course and we ramp up really quickly we do want to position you to succeed in this course as i was writing this i was trying to think about when i was first starting to program what helped me get through my very first programming course and this is really a good list the first thing was i just read the psets as soon as they came out made sure that the terminology just sunk in and then during lectures if the lecturer was talking about something that suddenly i remembered oh i saw that word in the pset and i didnt know what it was well hey now i know what it is right so just give it a read you dont need to start it if youre new to programming i think the key word is practice its like math or reading the more you practice the better you get at it youre not going to absorb programming by watching me write programs because i already know how to program you guys need to practice download the code before lecture follow along whatever i type you guys can type and i think also one of the big things is if youre new to programming youre kind of afraid that youre going to break your computer and you cant really do that just by running anaconda and typing in some commands so dont be afraid to just type some stuff in and see what it does worst case you just restart the computer yeah thats probably the big thing right there i should have probably highlighted it but dont be afraid great so this is pretty much a roadmap of all of 60001 or 600 as ive just explained it theres three big things we want to get out of this course the first thing is the knowledge of concepts which is pretty much true of any class that youll take the class will teach you something through lectures exams will test how much you know this is a class in programming the other thing we want you to get out of it is programming skills and the last thing and i think this is what makes this class really great is we teach you how to solve problems and we do that through the psets thats really how i feel the roadmap of this course looks like and underlying all of these is just practice you have to just type some stuff away and code a lot and youll succeed in this course i think ok so what are the things were going to learn in this class i feel like the things were going learn in this class can be divided into basically three different sections the first one is related to these first two items here its really about learning how to program learning how to program part of it is figuring out what objects to create youll learn about these later how do you represent knowledge with data structures thats sort of the broad term for that and then as youre writing programs you need to programs arent just linear sometimes programs jump around they make decisions theres some control flow to programs thats what the second line is going to be about the second big part of this course is a little bit more abstract and it deals with how do you write good code good style code thats readable when you write code you want to write it such that youre in big company other people will read it other people will use it so it has to be readable and understandable by others to that end you need to write code thats well organized modular easy to understand and not only that not only will your code be read by other people but next year maybe youll take another course and youll want to look back at some of the problems that you wrote in this class you want to be able to reread your code if its a big mess you might not be able to understand or reunderstand what you were doing so writing readable code and organizing code is also a big part and the last section is going to deal with the first two are actually part of the programming in introduction to programming and computer science in python and the last one deals mostly with the computer science part in introduction to programming and computer science in python were going to talk about once you have learned how to write programs in python how do you compare programs in python how do you know that one program is better than the other how do you know that one program is more efficient than the other how do you know that one algorithm is better than the other thats what were going to talk about in the last part of the course ok thats all for the administrative part of the course lets start by talking at a high level what does a computer do fundamentally it does two things one performs calculations it performs a lot of calculations computers these days are really really fast a billion calculations per second is probably not far off it performs these calculations and it has to store them somewhere right stores them in computer memory so a computer also has to remember results and these days its not uncommon to find computers with hundreds of gigabytes of storage the kinds of calculations that computers do there are two kinds one are calculations that are built into the language these are the very low level types of calculations things like addition subtraction multiplication and so on and once you have a language that has these primitive calculation types you as a programmer can put these types together and then define your own calculations you can create new types of calculations and the computer will be able to perform those as well i think one thing i want to stress and were going to come back to this again during this entire lecture actually is computers only know what you tell them computers only do what you tell them to do theyre not magical they dont have a mind they just know how to perform calculations really really quickly but you have to tell them what calculations to do computers dont know anything all right weve come to that lets go into the types of knowledge the first type of knowledge is declarative knowledge and those are things like statements of fact and this is where my email came into play if you read it all the way to the bottom you would have entered a raffle so a statement of fact for todays lecture is someone will win a prize before class ends and the prize was a google cardboard google stateoftheart virtual reality glasses and i have them right here yea i delivered on my promise thats a statement of fact so pretend im a machine ok i dont know anything except what you tell me i dont know i know that you tell me this statement im like ok but how is someone going to win a google cardboard before class ends right thats where imperative knowledge comes in imperative knowledge is the recipe or the howto or the sequence of steps sorry thats just my funny for that one so the sequence of steps is imperative knowledge if im a machine you need to tell me how someone will win a google cardboard before class if i follow these steps then technically i should reach a conclusion step one i think weve already done that whoever wanted to sign up has signed up now im going to open my ide im just basically being a machine and following the steps that youve told me the ide that were using in this class is called anaconda im just scrolling down to the bottom hopefully youve installed it in problem set zero ive opened my ide im going to follow the next set of instructions im going to choose a random number between the first and the nth responder now im going to actually use python to do this  and this is also an example of how just a really simple task in your life you can use computers or programming to do that because if i chose a random number i might be biased because for example i might like the number 8 to choose a random number im going to go and say ok wheres the list of responders it starts at 15 actually it starts at 16 because thats me were going to choose a random number between 16 and the end person 266 oh we just got oh ok ok im going to cut it off right here 271 ok 16 and 271 perfect ok im going to choose a random number im going to go to my ide and you dont need to know how to do this yet but by the end of this class you will im just going to use python im just going to get the random number package thats going to give me a random number im going to say randomrandint and im going to choose a random number between 16 and 272 ok 75 ok great i chose a random number and im going to find the number in the responders sheet what was the number again sorry 75 ok up we go there we go lauren zov yeah nice youre here awesome all right thats an example of me being a machine and also at the same time using python in my everyday life just lecturing to find a random number try to use python wherever you can and that just gives you practice that was fun but were at mit were mit students and we love numbers here at mit heres a numerical example that shows the difference between declarative and imperative knowledge an example of declarative knowledge is the square root of a number x is y such that y times y is equal to x thats just a statement of fact its true computers dont know what to do with that they dont know what to do with that statement but computers do know how to follow a recipe heres a wellknown algorithm to find the square root of a number x lets say x is originally 16 if a computer follows this algorithm its going to start with a guess g lets say 3 were trying to find the square root of 16 were going to calculate g times g is 9 and were going to ask is if g times g is close enough to x then stop and say g is the answer im not really happy with 9 being really close to 16 so im going to say im not stopping here im going to keep going if its not close enough then im going to make a new guess by averaging g and x over g thats x over g here and thats the average over there and the new average is going to be my new guess and thats what it says and then the last step is using the new guess repeat the process then we go back to the beginning and repeat the whole process over and over again and thats what the rest of the rows do and you keep doing this until you decide that youre close enough what we saw for the imperative knowledge in the previous numerical example was the recipe for how to find the square root of x what were the three parts of the recipe one was a simple sequence of steps there were four steps the other was a flow of control so there were parts where we made decisions are we close enough there were parts where we repeated some steps at the end we said repeat steps 1 2 3 thats the flow of control and the last part of the recipe was a way to stop you dont want a program that keeps going and going or for a recipe you dont want to keep baking bread forever you want to stop at some point like 10 breads is enough right so you have to have a way of stopping in the previous example the way of stopping was that we decided we were close enough close enough was maybe being within 01 001 whatever you pick this recipe is there for an algorithm in computer science speak its going to be an algorithm and thats what were going to learn about in this class were dealing with computers and we actually want to capture a recipe inside a computer a computer being a mechanical process historically there were two different types of computers originally there were these things called fixedprogram computers and im old enough to have used something like this where theres just numbers and plus minus multiplication divide and equal but calculators these days are a lot more complicated but way back then an example of a fixedprogram computer is this calculator it only knows how to do addition multiplication subtraction division if you want to plot something you cant if you want to go on the internet send email with it you cant it can only do this one thing and if you wanted to create a machine that did another thing then youd have to create another fixedprogram computer that did a completely separate test thats not very great thats when storedprogram computers came into play and these were machines that could store a sequence of instructions and these machines could execute the sequence of instructions and you could change the sequence of instructions and execute this different sequence of instructions you could do different tasks in the same machine and thats the computer as we know it these days the central processing unit is where all of these decisions get made and these are all the peripherals the basic machine architecture at the heart of every computer theres just this basic architecture and it contains i guess four main parts the first is the memory input and output is the other one the alu is where all of the operations are done and the operations that the alu can do are really primitive operations addition subtraction and so on what the memory contains is a bunch of data and your sequence of instructions interacting with the arithmetic logic unit is the control unit and the control unit contains one program counter when you load a sequence of instructions the program counter starts at the first sequence it starts at the sequence at the first instruction it gets what the instruction is and it sends it to the alu the alu asks what are we doing operations on here whats happening it might get some data if youre adding two numbers it might get two numbers from memory it might do some operations and it might store data back into memory and after its done the alu is going to go back and the program counter is going to increase by 1 which means that were going to go to the next sequence in the instruction set and it just goes linearly instruction by instruction there might be one particular instruction that does some sort of test its going to say is this particular value greater or equal to or the same as this other particular value thats a test an example of a test and the test is going to either return true or false and depending on the result of that test you might either go to the next instruction or you might set the program counter to go all the way back to the beginning and so on youre not just linearly stepping through all the instructions there might be some control flow involved where you might skip an instruction or start from the beginning or so on and after youre done when you finished executing the last instruction then you might output something thats really the basic way that a computer works just to recap you have the stored program computer that contains these sequences of instructions the primitive operations that it can do are addition subtraction logic operations tests which are something equal to something else something less than and so on and moving data so storing data moving data around and things like that and the interpreter goes through every instruction and decides whether youre going to go to the next instruction skip instructions or repeat instructions and so on so weve talked about primitives and in fact alan turing who was a really great computer scientist he showed that you can compute anything using the six primitives and the six primitives are move left move right read write scan and do nothing using those six instructions and the piece of tape he showed that you can compute anything and using those six instructions programming languages came about that created a more convenient set of primitives you dont have to program in only these six commands and one interesting thing or one really important thing that came about from these six primitives is that if you can compute something in python lets say if you write a program that computes something in python then in theory you can write a program that computes the exact same thing in any other language and thats a really powerful statement think about that today when you review your slides think about that again thats really powerful once you have your set of primitives for a particular language you can start creating expressions and these expressions are going to be combinations of the primitives in the programming language and the expressions are going to have some value and theyre going up some meaning in the programming language lets do a little bit of a parallel with english just so you see what i mean in english the primitive constructs are going to be words theres a lot of words in the english language programming languages in python there are primitives but there arent as many of them there are floats booleans these are numbers strings and simple operators like addition subtraction and so on so we have primitive constructs using these primitive constructs we can start creating in english phrases sentences and the same in programming languages in english we can say something like cat dog boy that we say is not syntactically valid thats bad syntax thats noun noun noun that doesnt make sense what does have good syntax in english is noun verb noun so cat hugs boy is syntactically valid similarly in a programming language something like this in python in this case a word and then the number five doesnt really make sense its not syntactically valid but something like operator operand operator is ok so once youve created these phrases or these expressions that are syntactically valid you have to think about the static semantics of your phrase or of your expression for example in english i are hungry is good syntax but its weird to say we have a pronoun a verb and an adjective which doesnt really make sense i am hungry is better this does not have good static semantics similarly in programming languages and youll get the hang of this the more you do it something like this 32 times 5 is ok but what does it mean whats the meaning to have a word added to a number theres no meaning behind that its syntax is ok because you have operator operand operator but it doesnt really make sense to add a number to a word for example once you have created these expressions that are syntactically correct and static semantically correct in english for example you think about the semantics whats the meaning of the phrase in english you can actually have more than one meaning to an entire phrase in this case flying planes can be dangerous can have two meanings its the act of flying a plane is dangerous or the plane that is in the air is dangerous and this might be a cuter example this reading lamp hasnt uttered a word since i bought it whats going on so that has two meanings its playing on the word reading lamp thats in english in english you can have a sentence that has more than one meaning thats syntactically correct and static semantically correct but in programming languages the program that you write the set of instructions that you write only has one meaning remember were coming back to the fact that the computer only does what you tell it to do its not going to suddenly decide to add another variable for some reason its just going to execute whatever statements youve put up in programming languages theres only one meaning but the problem that comes into play in programming languages is its not the meaning that you might have intended as the programmer thats where things can go wrong and theres going to be a lecture on debugging a little bit later in the course but this is here just to tell you that if you see an error pop up in your program its just some text that says error for example if we do something like this this is syntactically correct incorrect syntactically incorrect see theres some angry text right here what is going on the more you program the more youll get the hang of reading these errors but this is basically telling me the line that i wrote is syntactically incorrect and its pointing to the exact line and says this is wrong so i can go back and fix it as a programmer syntax errors are actually really easily caught by python that was an example of a syntax error static semantic errors can also be caught by python as long as if your program has some decisions to make as long as youve gone down the branch where the static semantic error happens and this is probably going to be the most frustrating one especially as youre starting out the program might do something different than what you expected it to do and thats not because the program suddenly for example you expected the program to give you an output of 0 for a certain test case and the output that you got was 10 well the program didnt suddenly decide to change its answer to 10 it just executed the program that you wrote thats the case where the program gave you a different answer than expected programs might crash which means they stop running thats ok just go back to your code and figure out what was wrong and another example of a different meaning than what you intended was maybe the program wont stop its also ok there are ways to stop it besides restarting the computer so then python programs are going to be sequences of definitions and commands were going to have expressions that are going to be evaluated and commands that tell the interpreter to do something if youve done problem set 0 youll see that you can type commands directly in the shell here which is the part on the right where i did some really simple things 2 plus 4 or you can type commands up in here on the lefthand side and then run your program notice that well well talk about this i wont talk about this now but these are on the righthand side typically you write very simple commands just if youre testing something out and on the lefthand side here in the editor you write more lines and more complicated programs now were going to start talking about python and in python were going to come back to this everything is an object and python programs manipulate these data objects all objects in python are going to have a type and the type is going to tell python the kinds of operations that you can do on these objects if an object is the number five for example you can add the number to another number subtract the number take it to the power of something and so on as a more general example for example i am a human so thats my type and i can walk speak english et cetera chewbacca is going to be a type wookie he can walk do that sound that i cant do he can do that but i cant im not even going to try and so on once you have these python objects everything is an object in python there are actually two types of objects one are scalar objects that means these are very basic objects in python from which everything can be made these are scalar objects that cant be subdivided the other type of object is a nonscalar object and these are objects that have some internal structure for example the number five is a scalar object because it cant be subdivided but a list of numbers for example 5 6 78 is going to be a nonscalar object because you can subdivide it you can subdivide it into you can find parts to it its made up of a sequence of numbers heres the list of all of the scalar objects in python we have integers for example all of the whole numbers floats which are all of the real numbers anything with a decimal bools are booleans theres only two values to booleans thats true and false note the capitalization capital t and capital f and this other thing called nonetype its special it has only one value called none and it represents the absence of a type and it sometimes comes in handy for some programs if you want to find the type of an object you can use this special command called type and then in the parentheses you put down what you want to find the type of you can write into the shell type of 5 and the shell will tell you thats an integer if you happen to want to convert between two different types python allows you to do that and to do that you put the type that you want to convert to right before the object that you want to convert to so float3 will convert the integer 3 to the float 30 and similarly you can convert any float into an integer and converting to an integer just truncates it just takes away the decimal and whatevers after it it does not round and keeps just the integer part for this slide im going to talk about it but if youd like if you have the slides up go to go to this exercise and after im done talking about the slide well see what people think for that exercise one of the most important things that you can do in basically any programming in python also is to print things out printing out is how you interact with the user to print things out you use the print command if youre in the shell if you simply type 3 plus 2 you do see a value here five right but thats not actually printing something out and that becomes apparent when you actually type things into the editor if you just do 3 plus 2 and you run the program thats the green button here you see on the righthand side here it ran my program but it didnt actually print anything if you type this into the console it does show you this value but thats just like peeking into the value for you as a programmer its not actually printing it out to anyone if you want to print something out you have to use the print statement like that in this case this is actually going to print this number five to the console thats basically what it says it just tells you its an interaction within the shell only its not interacting with anyone else and if you dont have any out that means it got printed out to the console all right we talked a little bit about objects once you have objects you can combine objects and operators to form these expressions and each expression is going to have a value so an expression evaluates to a value the syntax for an expression is going to be object operator object like that and these are some operators you can do on ints and floats theres the typical ones addition subtraction multiplication and division if for the first three the answer that you get the type of the answer that you get is going to depend on the type of your variables if both of the variables of the operands are integers then the result youre going to get is of type integer but if at least one of them is a float then the result youre going to get is a float division is a little bit special in that no matter what the operands are the result is always going to be a float the other operations you can do and these are also useful are the remainder so the percent sign if you use the percent sign between two operands thats going to give you the remainder when you divide i by j and raising something to the power of something else is using the star star operator and i star stars j is going to take i to the power of j these operations have the typical precedence that you might expect in math for example and if youd like to put precedence toward some other operations you can use parentheses to do that all right so we have ways of creating expressions and we have operations we can do on objects but whats going to be useful is to be able to save values to some name and the name is going to be something that you pick and it should be a descriptive name and when you save the value to a name youre going to be able to access that value later on in your program and thats very useful to save a value to a variable name you use the equal sign and the equal sign is an assignment it assigns the righthand side which is a value to the lefthand side which is going to be a variable name in this case i assigned the float 314159 to the variable pi and in the second line im going to take this expression 22 divided by 7 im going to evaluate it its going to come up with some decimal number and im going to save it into the variable piapprox values are stored in memory and this assignment in python we say the assignment binds the name to the value when you use that name later on in your program youre going to be referring to the value in memory and if you ever want to refer to the value later on in your code you just simply type the name of the variable that youve assigned it to so why do we want to give names to expressions well you want to reuse the names instead of the values and it makes your code look a lot nicer this is a piece of code that calculates the area of a circle and notice ive assigned a variable pi to 314159 ive assigned another variable called radius to be 22 and then later on in my code i have another line that says area this is another variable is equal to this is an assignment to this expression and this expression is referring to these variable names pi and radius and its going look up their values in memory and its going to replace these variable names with those values and its going to do the calculation for me and in the end this whole expression is going to be replaced by one number and its going to be the float heres another exercise while im talking about the slide i do want to make a note about programming versus math in math youre often presented with a problem that says solve for x x plus y is equal to something something solve for x for example thats coming back to the fact that computers dont know what to do with that computers need to be told what to do in programming if you want to solve for x you need to tell the computer exactly how to solve for x you need to figure out what formula you need to give the computer in order to be able to solve for x that means always in programming the righthand side is going to be an expression its something thats going to be evaluated to a value and the lefthand side is always a variable its going to be an assignment the equal sign is not like in math where you can have a lot of things to the left and a lot of things to the right of the equal sign theres only one thing to the left of the equal sign and thats going to be a variable an equal sign stands for an assignment once weve created expressions and we have these assignments you can rebind variable names using new assignment statements lets look at an example for that lets say this is our memory lets type back in the example with finding the radius lets say pi is equal to 314 in memory were going to create this value 314 were going to bind it to the variable named pi next line radius is equal to 22 in memory were creating this value 22 and were going to bind it to the variable named radius then we have this expression here its going to substitute the values for pi from memory and the value for radius from memory its going to calculate the value that this expression evaluates to its going to pop that into the memory and its going to assign because were using the equal sign its going to assign that value to that variable area now lets say we rebind radius to be something else radius i is bound to the value 22 but when we do this line radius is equal to radius plus 1 were going to take away the binding to 22 were going to do this calculation the new value is 32 and were going to rebind that value to that same variable in memory notice were still going to have this value 22 floating around but weve lost the handle for it theres no way to get it back its just in memory sitting there at some point it might get collected by what we call the garbage collector in python and itll retrieve these lost values and itll reuse them for new values and things like that but radius now points to the new value we can never get back 22 and thats it the value of area notice this is very important the value of area did not change and it did not change because these are all the instructions we told the computer to do we just told it to change radius to be radius plus 1 we never told it to recalculate the value of area if i copied that line down here then the value of area would change but we never told it to do that the computer only does what we tell it to do thats the last thing next lecture were going to talk about adding control flow to our programs so how do you tell the computer to do one thing or another all right 