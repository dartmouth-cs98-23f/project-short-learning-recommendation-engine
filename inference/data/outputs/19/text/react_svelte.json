{
  "introduction": "This video compares React and Svelte, two popular JavaScript frameworks used for building web applications. The video explores common patterns and design choices by the framework creators and highlights the differences in rendering, component state, props, side effects, computed state, templating, and shared state.",
  "sections": [
    {
      "title": "Section 1: Rendering",
      "content": [
        "React uses a runtime called the virtual dom to keep track of data changes in the application and render them in the actual DOM in the browser.",
        "Svelte uses a compiler to eliminate the need for a runtime and takes your Svelte code and converts it into vanilla JavaScript, resulting in a far smaller hello world using a compiler.",
        "React is just JavaScript whereas Svelte can take non-JavaScript code to allow developers to do things more efficiently than they could otherwise.",
        "Vanilla JavaScript libraries tend to be much easier to work with in Svelte when compared to React."
      ],
      "topics": ["React", "Svelte", "Virtual DOM", "Compiler"]
    },
    {
      "title": "Section 2: Component State",
      "content": [
        "React uses functions to create components and then adds reactive state to them with the use state hook that returns a reactive value and a setter function to update the state.",
        "Svelte defines the logic within the script tags to create reactive state all you do is create a variable with the let keyword from there, we can define a function on the click event that mutates the value directly.",
        "Svelte code is able to be more concise because it doesn't require any imports or function calls to initialize the state.",
        "React has a massive ecosystem of dedicated libraries to help you get things done."
      ],
      "topics": ["React", "Svelte", "Reactive State", "use state hook"]
    },
    {
      "title": "Section 3: Props and Children",
      "content": [
        "React defines props as function arguments which are typically destructured like so in Svelte, putting the export keyword in front of a variable allows it to be passed in from the outside on the click event using props looks basically identical in both frameworks although Svelte does use some syntactic sugar allowing you to more easily match variable names to props.",
        "React allows components to be passed as props and rendered directly in the jsx in addition if we want to insert ui inside of a component we can use the built-in propschildren value you now in Svelte, we have an entirely different system called slots the default slot is the equivalent to propschildren however you can also create name slots that allow you to insert ui at specific points in this components markup that gets the job done but I kind of miss the ability to use components as props and so now lets look at how we might run code when a component is initialized in React we have the use effect hook which takes a callback function followed by an empty array to signify that it doesnt have any dependent data so it only runs once in Svelte we have a similar pattern with the on mount function its more readable but more importantly it can handle an async function which is not possible in React which means you need to jump through this extra hoop of defining your own async function.",
        "React uses jsx where you put your html in your javascript whereas Svelte has its own templating approach where you bring javascript into your html jsx is one of reacts great innovations if you like some of the ideas of svelte but dont like its templating system a good alternative is solajs which is kind of like react with a smelt style compiler when it comes to conditional logic and react we cant directly use an if statement because a function component needs to return a javascript expression that represents a single value to represent a basic ifel statement or true false situation we can use a ternary operator and represent everything with a single line of code now remember svelte uses a compiler which means it can come up with any kind of templating magic that it wants to it allows you to create if else statements in the html very similar to how you would in normal javascript its a bit more verbose but more readable in my opinion and the readability is very noticeable when you have multiple conditions like an if else statement because in react you'll occasionally see nightmare code like this of nested ternaries although there are better ways of doing this like extracting the logic to its own dedicated component and now lets take a look at loops the most common way to loop and react is to use the map function on an array this allows you to define a callback function that returns the ui for each item in that array in addition we can make it a key loop by adding a key prop to the child in silt we can loop over an array of data within each loop it creates a template variable for each item and then we can use its data inside the tags you make it a key loop we can add parentheses with the value for the key inside of the each block now lets switch gears to the big complicated topic of shared state like how do I take one reactive value and share it throughout the entire component tree react doesnt really have a primitive way to do this out of the box and you'll typically need to bring in a state management solution like mobx or redux or my personal favorite joe tai which means state in japanese with joe tai we create an atom to represent a value then in one or more components we can use the use atom hook to access that value instead of using the built-in use statehook and react we can now use that state in multiple places because its been decoupled from the component spelled has a similar mechanism built in called stores which are very similar to observables in libraries like rxj s we can create a writable store to represent a value whats crazy though is that we can then subscribe to the value of that store inside of any component both in the templates and in the javascript all we have to do is put a dollar sign in front of it thanks to the magic of the compiler as a spell user myself i cant even begin to tell you how much complexity and code this one little mechanism will eliminate from your code base it allows you to use reactive data throughout the entire application with surgical precision and zero boilerplate on top of that it knows when to automatically unsubscribe from data when it no longer has any listeners and that can be extremely important when using real realtime data like firestore for example speaking of async data lets talk about promises react has a new use hook thats currently experimental that can be used to unwrap promises directly in a component its essentially the equivalent to the await keyword which resolves the value of the promise into the variable however you'll also likely want to show a loading state and handle errors one way to do that is to wrap this component with suspense which will render this loading spinner as a fallback while the promise is being resolved and then we could wrap all of that in an error boundary to show an error page if its rejected this code is a bit intimidating and requires a lot of knowledge of react to even understand what the hell is going on in svelte we can actually unwrap promises directly in a template using a weight while awaiting show a loading spinner then when the number resolves show the main ui otherwise if theres an error show the error ui its easily understandable for any javascript developer who knows promises and finally if you want to see some full stack comparisons on the server become a fireship pro member to get access to these full courses huge thanks to everyone whos already supported by work there and today is the last day to get 35 off a membership using that code below thanks for watching and i will see you in the next one",
      "topics": ["React", "Svelte", "Virtual DOM", "Compiler", "Props", "Children", "React Hooks", "Svelte Hooks", "State Management", "Shared State", "Async Data", "Promises"]
    },
    {
      "title": "Section 4: Side Effects and Computed State",
      "content": [
        "React uses the use effect hook to create side effects and computed state, it takes a callback function followed by an empty array to signify that it doesnt have any dependent data so it only runs once in Svelte we have a similar pattern with the on mount function its more readable but more importantly it can handle an async function which is not possible in React which means you need to jump through this extra hoop of defining your own async function.",
        "Svelte uses reactive declarations that start with a dollar sign and a colon this looks kind of weird at first but what it does is rerun the code whenever any dependent data changes in this case the compiler knows that this code is dependent on the count value therefore it updates the document title whenever the count changes not only is it more concise but it also tends to be more reliable than react because its easy to screw up the dependencies array and get unexpected results that are hard to debug.",
        "React doesnt really have a primitive way to do this out of the box and you'll typically need to bring in a state management solution like mobx or redux or my personal favorite joe tai which means state in japanese with joe tai we create an atom to represent a value then in one or more components we can use the use atom hook to access that value instead of using the built-in use statehook and react we can now use that state in multiple places because its been decoupled from the component spelled has a similar mechanism built in called stores which are very similar to observables in libraries like rxj s we can create a writable store to represent a value whats crazy though is that we can then subscribe to the value of that store inside of any component both in the templates and in the javascript all we have to do is put a dollar sign in front of it thanks to the magic of the compiler as a spell user myself i cant even begin to tell you how much complexity and code this one little mechanism will eliminate from your code base it allows you to use reactive data throughout the entire application with surgical precision and zero boilerplate on top of that it knows when to automatically unsubscribe from data when it no longer has any listeners and that can be extremely important when using real realtime data like firestore for example speaking of async data lets talk about promises react has a new use hook thats currently experimental that can be used to unwrap promises directly in a component its essentially the equivalent to the await keyword which resolves the value of the promise into the variable however you'll also likely want to show a loading state and handle errors one way to do that is to wrap this component with suspense which will render this loading spinner as a fallback while the promise is being resolved and then we could wrap all of that in an error boundary to show an error page if its rejected this code is a bit intimidating and requires a lot of knowledge of react to even understand what the hell is going on in svelte we can actually unwrap promises directly in a template using a weight while awaiting show a loading spinner then when the number resolves show the main ui otherwise if theres an error show the error ui its easily understandable for any javascript developer who knows promises and finally if you want to see some full stack comparisons on the server become a fireship pro member to get access to these full courses huge thanks to everyone whos already supported by work there and today is the last day to get 35 off a membership using that code below thanks for watching and i will see you in the next one",
      "topics": ["React", "Svelte", "use effect hook", "on mount function", "Side Effects", "Computed State", "Reactive Declarations", "Dependencies Array", "MobX", "Redux", "Joe Tai", "Stores", "Observables", "rxj", "Async Data", "Promises", "Suspense", "Error Boundary"]
    },
    {
      "title": "Section 5: Templating and Shared State",
      "content": [
        "React uses jsx where you put your html in your javascript whereas Svelte has its own templating approach where you bring javascript into your html jsx is one of reacts great innovations if you like some of the ideas of svelte but dont like its templating system a good alternative is solajs which is kind of like react with a smelt style compiler when it comes to conditional logic and react we cant directly use an if statement because a function component needs to return a javascript expression that represents a single value to represent a basic ifel statement or true false situation we can use a ternary operator and represent everything with a single line of code now remember svelte uses a compiler which means it can come up with any kind of templating magic that it wants to it allows you to create if else statements in html very similar to how you would in normal javascript its a bit more verbose but more readable in my opinion and the readability is very noticeable when you have multiple conditions like an if else statement because in react you'll occasionally see nightmare code like this of nested ternaries although there are better ways of doing this like extracting the logic to its own dedicated component and now lets take a look at loops the most common way to loop and react is to use the map function on an array this allows you to define a callback function that returns the ui for each item in that array in addition we can make it a key loop by adding a key prop to the child in silt we can loop over an array of data within each loop it creates a template variable for each item and then we can use its data inside the tags you make it a key loop we can add parentheses with the value for the key inside of the each block now lets switch gears to the big complicated topic of shared state like how do I take one reactive value and share it throughout the entire component tree react doesnt really have a primitive way to do this out of the box and you'll typically need to bring in a state management solution like mobx or redux or my personal favorite joe tai which means state in japanese with joe tai we create an atom to represent a value then in one or more components we can use the use atom hook to access that value instead of using the built-in use statehook and react we can now use that state in multiple places because its been decoupled from the component spelled has a similar mechanism built in called stores which are very similar to observables in libraries like rxj s we can create a writable store to represent a value whats crazy though is that we can then subscribe to the value of that store inside of any component both in the templates and in the javascript all we have to do is put a dollar sign in front of it thanks to the magic of the compiler as a spell user myself i cant even begin to tell you how much complexity and code this one little mechanism will eliminate from your code base it allows you to use reactive data throughout the entire application with surgical precision and zero boilerplate on top of that it knows when to automatically unsubscribe from data when it no longer has any dependent data and that can be extremely important when using real realtime data like firestore for example speaking of async data lets talk about promises react has a new use hook thats currently experimental that can be used to unwrap promises directly in a component its essentially the equivalent to the await keyword which resolves the value of the promise into the variable however you'll also likely want to show a loading state and handle errors one way to do that is to wrap this component with suspense which will render this loading spinner as a fallback while the promise is being resolved and then we could wrap all of that in an error boundary to show an error page if its rejected this code is a bit intimidating and requires a lot of knowledge of react to even understand what the hell is going on in svelte we can actually unwrap promises directly in a template using a weight while awaiting show a loading spinner then when the number resolves show the main ui other