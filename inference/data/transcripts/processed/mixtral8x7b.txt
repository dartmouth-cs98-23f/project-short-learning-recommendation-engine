hello guys welcome back to my channel today we are going to talk about mistral so as you know mistral is a new language model that came out a few months ago from mistal ai which is a one of the hottest startup right now in europe for language models it also became a unicorn recently and we will exploring both the models they released one is the 7 billion and one is the 8 by7 billion model so lets review the topics of today the first thing i will introduce you is the architectural differences between the vanilla transformer and the architecture of mistal later we will see what is the sliding window attention and how it is related to the concept of receptive field a concept that usually we find in convolutional neural networks i will briefly review the kv cache because i want to introduce the concept of rolling buffer cache and also how it is done with prefilling and chunking uh we will see what is sparse mixture of experts model sharding with a little with a very brief introduction with the pipeline parallelism and last but not least we will also go through the code of mistal because there is a lot of innovations in the code especially when they use the x forers library with the block attention so i want to guide you into understanding the code because it can be really hard for beginners to understand and find thems around there are some topics that are related to mistal but will not be covered in this current video because i already covered them in my previous video about llama and in particular i will not be talking about the rms normalization the rotary positional encoding and the group query attention because i already um teach them in depth in my previous video on llama so if you want to know about them please watch my previous video on llama another the only prerequisite that i hope you have before watching this video because the topics we are going to touch are quite advanced is that you are familiar with the transformer model so if youre not familiar with the transformer model and the attention mechanism in particular and in particular the self attention mechanism please go watch my video on the transformer in which i teach all this concept very thoroughly very in detail these are really a prerequisite for watching this video because the top the topics here are quite advanced okay lets proceed further so lets watch the differences between the vanilla transformer and mistal at the architecture level as you can see from the um image here which i built by myself using the code because they didnt release any architecture picture in the paper u the architecture of mistal first of all lets talk about some terminology when you have a model like this made up of many encoder layers plus linear and the soft max we are talking about a decoder only model because this part this model here looks like the decoder of the vanilla transformer you can see here except for the cross attention because as you can see here there is no cross attention when we have a model without the linear and the softmax we call it an incoder only model for example bir is an encoder only model because birth has some heads at at the end which is one or more linear layers depending on the application but it self birth doesnt need a head because it can be used for multiple downstream tasks so its called an encoder only model because it resembles the encoder side of the transformer because as you can see in the encoder side there is no linear and soft max so mistal is a decoder only model and its very similar if not equal to llama the differences between llama and mistal are highlighted here in red the first difference between llama and mistal is that in the self attention we use the sliding window attention and we still use the group query attention but and also the kv cache for inferencing but this is a rolling buffer kv cache and its actually related to the fact that we are using sliding window attention so later we will see all these concepts and the another difference is that the feed forward layer here instead of using the reu function that we used in um in the vanilla transformer or the zigo function that we us in lama here in mistal we use the ceu function um and the feed forward is one in case of mistal 7b so the first model they released and its it can be eight feed forwards uh networks in parallel with each other which are the experts of this mixture of expert in the case of mral 8x 7b um we will see later how it works so for now you just need to understand that mistal is made up of okay the input which are converted into embeddings then we have this block which is repeated n times and we will see that in the case of mistal is repeated 32 times one after another such that the output of each layer is fed to the next layer as input and the output of the last layer is then sent to this rms norm to the linear and to the softmax to produce the output of the model and um this is exactly the same as what we do with any other transformer model usually we have many of this blocks here now in the code of mistal this part here is known as transformer block but its also known as encoder block or decoder block depending on the in the contents of this um block here i will refer to it as an encoder block because if you look at it it looks like exactly as the block of the encoder side so it has a multi header tension od and norm a feed forward and other norm the only difference is that the normalization here comes before the uh the the bl of the feit forward and the self attention okay lets move forward now lets compare the the two models so one is mistal 7b and one in mistal 8x 7b the parameter dim indicates the dimension of the this the dimensions of the embedding vector so how big is the embedding vector so each token is represented by an embedding vector of size 496 dimensions we have 32 of the encoder layers so this block here is repeated 32 times the head dimension indicates as you remember in the multiad attention we have um each head is watching the entire sentence but only a part of the embedding of each token and this indicates how much how many dimensions each head will attend to in each um for in the multiad attention and the hidden dimension here indicates the hidden dimension of the feed forward layer so if the in the case of the fit forward layer we have two linear layers one that converts the the dimension of the embedding vector into the hidden size then another one that converts the hidden size back into the embedding vector dimensions so in the case of the mistal they are using as a hidden size 14336 usually this is a multiple of the dimension and it looks like its 35 the dimension here the number of heads of attention for the query is 32 two while the number of heads for the k and v so the key and values is eight and they are not equal because of the grouped query attention so if you remember from my previous video on lama in which we talk about the group query attention um in the very simple case of the group query attention we have the multiquery attention which means that only the query have the multiad while the key and v dont have the multihead attention uh which means that you may have eight heads for the query and only one head for the k and v in the case of the grouped query attention means that each group of query will have one um attention head for the k andv so in this case every four query have one attention head for the keys and values if this concept is not clear i describe it very thoroughly in my previous video on lama the window size is the size of the sliding window that we used in the um calculation of the attention and we will see later how it works the context length is uh what is the context size of upon which it the model was trained upon uh and its much bigger for the 8x 7b the vocabulary size is the same for both and then the last two parameters you can see here are related to the sparse mixture of experts and we will see later uh how it works but we just remember that we have eight experts and for each token we use two experts but later i will clarify how it works lets proceed further so lets talk about the sliding window attention but before we talk about the sliding window attention i need to review a little bit of the self attention mechanism so what is self attention self attention is a mechanism that allows the model to relate tokens to each other so tokens that are in the same sentence are related with each other through the self attention mechanism this is why its called self attention because each token is watching other tokens of the of the same sentence and when when and this is means basically that the query key and values are the same metrix um so imagine we have the following sentence the cat is on a chair we have our query which is a matrix made up of six tokens each token represented by 4which is the dim parameter that we saw before this is multiplied by the transpose of the keys which is 496 by 6 but its just the query matrix transpose because the query key and values are the same matrix in the case of self attention this will produce a matrix that is 6x 6 because the inner two dimensions kind of cancel out and the outer dimensions indicate the dimension of the output matrix here now what is the values what are the values in this matrix representing the first value here indicates the dot product of the first token with the first uh the first row of the query with the first column of the keys so basically the dot product of the embedding of the first token with itself the second value here indicates the dot product of the first row of the query matrix with the second column of the key matrix here the transpose of the keys matrix here which basically means that its the dot product of the embedding of the first token so the with the embedding of the second token which is cat and etc etc for all the other values dont concentrate too much on the values because all the values i put here are random and also the fact that these numbers are less than one its not necessary because the dot product can be bigger than one its not a uh condition of the dot product usually in the formula we also normalize here we divide by the dimension of the dc dk basically is the um the size the part of the embedding to which this particular attention head will attend to but lets pretend that we only have one one ahead so dk is equal to d model so basically this head will watch the full embedding of each token okay you usually we train auto regressive models so language model is an auto regressive model it means that the output depends on the previous the next token depends only on the previous tokens and this is why we apply a cal mask cal mask means basically that in the attention mechanism we dont want to relate a word with future words so words that come after it but only with words that come before it so for example we dont want the word the to be related to the word cat because um the word cat come after the word the but on the other hand we want the word cat to be related to the word the because it comes before it and for this reason we apply this cal mask because the attention mechanism uses the soft max function we can see here the soft max function basically um will transform all this minus infinity into zero because the formula of the soft max has at numerator an e to the power of x and when x goes to minus infinity e to the power of minus infinity will go to zero so this is why we apply a mask in which we put all the values that we dont want all the interactions that we dont want between tokens we just mask them out by replacing them with minus infinity so that when we apply the softmax the softmax will take care of um transforming them into zeros okay also the softmax will do another thing because it will not only convert this minus infinities to zero but it will also modify the other value for each row such that they sum up to one so as you can see now these values here they dont sum up to one for each row right because this is 02 01 and 0 they dont sum up to one but the soft marx will convert the minus infinities into zero and the remaining values for each row such that they sum up to one now lets talk about sliding window attention so we applied the causal mask to hide the interactions between the words a word and all the future words but with sliding window attention we also dont want the word to watch other words that are outside its local context what do i mean by this in the previous case when we only applied the cal mask the word chair for example was being related to all the previous tokens as you can see so the the token chair here is related to itself but also to the a on is cat v so it could watch basically all the sentence but in the case of sliding window attention we dont want the word chair to watch words that are further than the sliding window size from itself so uh the sliding window size in this case is three so tokens that are distance more than three from the word uh we are considering so the word the chair should not be related to the word is because the distance is four and the word a should not be related to the word cat because the distance is four and of course we still want the mask to be cal because we dont want the model to uh each token to watch future words because we are training an auto regressive model so the sliding window attention basically reduces the number of dot products that we are performing and this will improve the performance during the training and the inference because as you can see when we only apply the cal mask we are performing all these dot products you see here but with the sliding window attention we are performing less dot products because all the other will be masked out sliding window attention however may lead to degradation of the performance of the model because as you can see here the word chair and the word the are not related to each other anymore right so the information uh will not be conveyed from the word the and the word chair the word chair will only be related to other tokens that are belonging to the local context of this particular token so only the tokens that are in the same in inside this sliding window this may be if this window is too small it may reduce the performance of the model but it may also be beneficial because for example imagine you are reading a book you dont care about relating the word in chapter five with the words in chapter one because most of the books they they could be talking about totally different things and you dont even care about relating these two tokens but for sure you want to relate the tokens uh in the chapter five with other tokens in the chapter five because the local context matters but i want to introduce you the concept of receptive field because when we use sliding window attention even if the word chair and the are not related to each other actually because in mistal and in all transformer models we use multiple layers of encoders we will see that the information so the the word the chair and the the will still be kind of related to to each other not directly but indirectly in a concept that is very similar to the receptive field of the convolutional neural networks so lets talk about the receptive field as you remember in convolutional neal networks we have um a mask a kel that we run through an image so imagine this is our original image uh this one here and we run a mask that is a kernel that is 3x3 this one here when we run a kernel it will produce an output feature so for example this feature here this is the output produced by applying the caral to the first 3x3 grid here this value here the second value here in yellow it will be produced when we will move our kernel to the next group of 3x3 pixels so let me draw lets use the pen so this value here will be produced when we will move our kernel in this grid here and uh this value here is also a an output feature of a convolutional kernel that is 3x3 applied to this layer two so this is a 3x3 kernel that is applied to this layer two so apparently there is no connection between this one this pixel here and this one but because this this uh output feature depends on a kernel applied in this grid and this grid includes this feature here which depends on this pixel here we can safely say that this feature here depends indirectly also on this feature here even if they are not directly related to each other and this is the concept of the receptive field so basically one feature of the convolutional neural networks can watch a much bigger receptive field uh down upward in the layers because of this um sequential application of kels in the convolutional kels lets see how this concept is related to the sliding window attention now now after we apply the soft max to the mask that we have seen before as i told you before all the minus infinities are converted into zero and all the other values are changed in such a way that they sum up to one so lets go back as you remember here we have the minus infinities here here here here here and here so now we apply the soft max and it will become zeros zeros here also let me okay all the zeros here all the zeros here and all the other values are changed in such a way that they sum up to one what is the next operation that we do in in self attention we then take the output of the softmax and multiply it by the v matrix so lets do it uh the v matrix is basically the same as the initial sequence because i told you this is self attention so the query key and values are the same matrix so this means lets analyze what happens by hand when we do this multiplication so let me change to the pen okay the v matrix here is um is a sequence of tokens where each token is vector represented by 4can say that its the output of the self attention if you watch the dimensions of these two matrices so its a 6x 6 and the 6x 496 the output will be another matrix that is 6x 496 so it will have the same dimension as the v matrix and also as the qu and the query matrix because they have the same dimensions so it will be six tokens as output okay lets analyze what is the first dimension of the output this one here so this uh first value of the output so the value on the row one column one of the output matrix will be the dot product of the first row of this matrix here so this row here with the first column of this matrix so the first column we can see here and as you can see most of the values here are zero which means that all the rows from the one to five sorry from two to six will not be used but only the first row here only the values of the first row will be used because if you remember the dot product is the first dimension with the first dimension of this column and the second dimension of this row with the second dimension of this column the third dimension of this row with the third dimension of this column and then we sum up all these values so this first value of the output will only depend on the first token of the v matrix you can see here lets check the second one the second dimension of the the the first dimension of the second row of the output matrix will be the dot product of the first row of this matrix here with the first column of the v matrix but most of the values are zero which means that this uh dimension here and all the dimensions in this row will depend only on the first two tokens of the v matrix and we can say the same for the third lets analyze the sixth one here so the first dimension of the sixth to row of the output matrix this value here comes from the dot product of this row and the first column of the v matrix but most of the values at the beginning are zero which means that it will only depend on the uh four five and sixth token of the v matrix and so will be all the dimensions here because in each column uh whatever the column we use from the v matrix the first values will always be multiplied by 0 0 0 so it will only use the values in these three rows here so we can safely say that the sixth token of the output matrix we of this self attention mechanism will be a vector that will only depend on the last three tokens of the v matrix and because we are talking about self attention the v matrix is equal to query matrix so we can say that the output of the self attention is a matrix that has the same shape as the input sequence but where each token now captures some more information about other tokens which tokens depending on the mask we have applied so our mask says that the first token can only watch itself so the first output token will be an embedding that will only depend on itself the second token will only depend on the first two tokens the third output token will only depend on the first three tokens the fourth will depend on the token number two because the first token is not used the token number two the token number three and the token number four etc etc until the last here the last token will depend only on the last three tokens because the first three tokens are masked out and this is the importance of the mask that we apply in the self attention mechanism this concept that i show you now is very important to understand the rest of the video so please if you didnt understand it you can take a little pause you can try to do it by your by yourself because its really important that you understand how the self attention mechanism works with the mask okay now that we have seen this concept i want to introduce you to the next one so as we saw before the output of the self attention mechanism is another matrix with the same shape as the query matrix in which each token is represented by an embedding of size 496 but each embedding now captures information also about other tokens according to the mask and if we check the um this mask here so the output here we can safely say that the input of our slide uh sliding window attention was the initial uh sequence d cat is on on a chair but after applying the self attention the first token is now related to itself the second token is related to itself and the token before it the third is related to the token before it and the one also before it the last one only depends on the previous two tokens etc according to the mask right now what happens if we feed this one because as you know in the transformer word and also in mistal and also in lama we have many layers of encoders one after another which are also called transformer block in the code and the output of each layer is fed to the next one so this is the first layer of the uh transformer so we take the input sequence and we feed it to the first layer which will produce a list of tokens where each token now captures information about other tokens but this will become the input of the next layer where we we it will produce an output this output i will prove you that will capture information about even more tokens even if the sl in window attention says that they should only be able to watch the previous two tokens because the sliding window size we chose three as a sliding window size uh i want to prove it so imagine this is the output of the first layer so its a a list of tokens that capture information about other tokens and its the the the metrix that we built in the previous slide lets use it as an input for another layer of of the encoder so we multiply the query mul um we multiply the query and the transpost of the keys which will produce a matrix like this one in which each token is not only one token but its capturing already information about multiple tokens right according to the mask so im im taking this one and this one will become query key and values so if we multiply the query by the key it will return a metrix like this so the first token only depends on itself the second one depends on himself and the previous one so the embedding of this token captures information about two to tokens and the ming of this token capture information about three tokens etc lets try to do the multiplication again so we have that our v matrix is again a list of tokens and the output will also be a list of tokens but each one will capture information about other tokens okay lets analyze the dot product here so the first value of the first row so the first dimension of the first row of the output matrix will be the dot product of the first row of this matrix here so this row here with the first column of this matrix here so this column here but because of this cal mask with sliding window attention mask that we can see here it will the output will only depend on the first row of the v matrix but because the v matrix is a matrix that is made of these tokens here it it will only depend on the word the so as we can see here the output of the second layer only depends on the word the and so will be this second one so dick uh lets check the fourth token for example here this one lets check this fourth token here so this value here will be the product of the fourth row of this matrix dot product of this row with the first column of the v matrix so this column here but the first token will not be used because its we are multiplying it with zero whatever value we have here we will not be using it we are using the second token the third token and the fourth token and each token actually they are aggregating this um this values here this token here is already uh aggregating the value of two tokens which is d and cat so this embedding here is already about talking about d and cat and this uh token here is talking about is aggregating the information about the cat and is so the cat and is and the fourth token is aggregating the information of the cat is on so cat is and on because as we saw before the fourth token here cat is on which is the result of the previous self attention that we done so this output value here will depend on three tokens that already include information about other tokens so this value here will aggregate information about the union of all these tokens so it will for sure depend on the word the because its included in the second token we are multiplying it with it for sure it will include information about the word cat because its included in this token as well for sure it will include information about is because its included in the second value we are multiplying it with and for sure it will include about the token on because its present in the the fourth token of the v matrix for with which we are app multiplying it because this value is not zero so as you can see after applying another layer of the encoder the fourth token now includes another token in in its information before it was only uh including these three tokens but now it also depends on a new token which is the word v and we can prove the same for the fifth token and the sixth token so at every application of the encoder layer one after another we keep increasing the number of tokens that get uh accumulated in these thought products and i made a notebook in pon to visualize this so if you look at my github repository uh you will see this notebook called the sliding window attention in which i help you visualize this process and i also share the code on on how i do this self attention basically i represent each token as a set so each each token instead of being represented as an amending as a set of all the words upon which that token depends depends then i apply the sliding window attention which basically means that i take the two tokens that the from the sequence and i accumulate i make the union of the two sets they contain because i am multiplying two vectors that already include information about multiple tokens so what is the output is the union of the two sets when i multiply by v i do the same thing and i can visualize it so after we apply the first layer we will see that the input of the first layer is just our normal sequence so the cat is on a chair the output of the first layer will be another sequence that in which each position includes information about multiple tokens depending on the mask that we have applied and i also show the mask that we apply after we apply the second layer we can see that the information increases so this last token now is not watching only the previous three tokens but the previous four tokens uh sorry not only the previous two tokens but the previous four tokens so every every uh step we do with the sliding window size of three we include two tokens at every layer and uh here i show it for five layers but its not necessary because after a while the the sequence will reach the maximum length if you want you can increase the sequence length here by including more tokens so this is the concept of the um the receptive field applied to the self window attention so basically with the sliding window attention we are not uh directly connecting connecting two tokens with each other but if we apply multiple layers after one after another this information will get will get captured by the embedding in successive applications of the layers such that the last layer basically will be able to watch all the sentence even if its very long and this is actually uh shown by the um myal paper in this picture you can see here so basically this is our input sequence so let me write so this is our input which is a the original sentence so the cat is on a chair the fourth token of the first layer so this is the output of the first layer so layer one one uh we have see that the fourth token here depend with a sliding window size of four this will depend on the itself on the previous token on the one before and also this token here and it will produce um this uh this embedding here in the fourth position which includes information about the previous token as well but then this will become the input of the next layer which is the layer number two and this will produce an embedding at this position for example that will depend for sure on the previous four tokens because the sliding window size is four but because for example this token here is already the aggregation of the previous four tokens it will actually multiply the visibility of his sliding window so this token here is not related directly to the first one we can see here but indirectly through the uh this intermediate token we can see here i hope this um i hope this concept is clear if its not clear i try i i i recommend using my notebook so that you can experiment by playing with multiple sequences and you can see how the information flow will go through all the layers all right lets talk about our next topic which is the k cach because i want to introduce the kv cach which i already explain in my previous video on llama but i want to introduce it again and review it because i want to introduce later the rolling buffer cach so lets start start by talking about first of all how we train language models because this is needed to understand the k cach so uh the language models are trained using what is known as the next token prediction task so given a prompt the goal of the language model is to predict what is the next token that makes sense with the prompts that we have given and imagine we want to train a language model on dante aligs poem uh divine comedy and in particular we will training it on a line that you can see here in um this one in english so love that can quickly seize the gentle heart how does it work we prepare an input for our language model which is the the line that we want to teach it with a token prepended called start of sentence and then we build the target which is the same line but within token at the end called end of sentence we run the input through this transformer model it will produce an output sequence so as we saw before the in the output of the selfa ension is another sequence with the same length as the input sequence but the embedding is modified in such a way that each token capture information about other tokens and this is what we use uh to actually train a model so if we feed the model with with nine tokens the model will produce nine tokens as output and how does it work basically the model will learn a mapping between input and output such that if we give to the model as input the token start of sentence only it will produce the first token as output which is the word love if we give to the model as input the first two tokens so start of sentence love the model will produce the two tokens as output so love that it will feed the model as input three tokens so start of sentence love that the model will produce love that can so when we train the model we train it like this we prepare the input like this the target like this we calculate the output we calculated the loss using the cross entropy loss and then we run back propagation and this is done in all one step when we do the inference we do it in multiple steps so when we do the inference at time step one we feed the model only the first token so the start of sentence and the model will produce the output love then we take the output the last token of the output and we prepend it to the input which becomes the input as time step two so it becomes start of sentence love so the motel will produce love that we take the last token of the output and we prep append it to the input for the temp step three and this will become the new input which will produce love that can then we take the last token of the output and we append it to the input for the time step four so it will become the new output will become love that can quickly then we take this word quickly we append it to the input for the next time step and it will produce the next token as output etc etc until the last token until we see the end of sentence token as output then we know that the model has stopped uh um has stopped producing new tokens and we can stop the inference now at every step the inference we are only interested in the last token output by the model because we already have the previous one but of course we need to feed all the previous tokens to uh to to the model which is belonging to the prompt because the model needs to access the prompt to understand which token to produce next so for example we cannot produce the word gen only by giving the word the we need to give all this sentence to produce this output gentle here but at the same time we are only interested in the last word gentle and this is the reason we introduce the k cach because the k cach allow us to reduce the computations that we are doing by only producing one output at a time the one that we need but um without doing all the intermediate computations for all the other tokens that we never use so basically basically when we want the word heart we dont want to produce the output for the word love that can quickly seize the gentle because we already have them in the prompt we dont need to produce all these tokens we just want to produce the output for the token heart so we want to reduce the computation that we are doing lets see how it works now in the self attention mechanism you know that we multiply the query which can be thought of as a list of tokens where each token is an embedding of size 4becomes the is multiplied the transpose of the keys are multiplied by the queries to produce this matrix here and then we multiply by the v matrix to produce the output of the self attention you can see here lets do this one token at a time so when we inference a language model we start with our first token which is the start of sentence this is one token represented by an embeding of size 496 we multiply it by the transpost of the keys which is again one token its because its a self attention so uh the query the key and the value are the same matrix so this is just the transpose of the query basically and so its a column vector and it will produce a 1 by one matrix we multiply by v and it will produce an output token we take this output token we send it to the linear layer and then to the soft marx to understand which token this corresponds to in our vocabulary we take this token from our vocabulary and we append it to the query for the next inference step to the keys and the values and then we compute again the product of the query multiplied by the keys we multiply then the result by v and it will produce an output made up of two tokens because we have two tokens as input it will produce two tokens as output but we are all interested in the last token so we take this output token two we send it to the linear layer then to the soft max this will result in what token is corresponding to in our vocabulary we take this token from our vocabulary we append it for the next step to the query key and values we do again this iterator this process and then we take the last token as output you can see here we send it to the linear layer then the soft marx we understand which token it corresponds to we append it to our query key and values and then we compute again the self attention but we already start to notice something because first of all we in this metrix here which is the result of the query multiplied by the transpost of the keys we have a lot of dot product at each step that were already computed at the previous step let me show you at the time step four we are computing all these dot products as you can see at the time step three we already computed this uh this dot products and the time steps four we are computing them computing them again as you can see these dot products here so and the second thing is that usually when we uh we deal with the language model we have a cal mask so we do not even care about computing the dot products that we see here in the dark violet because they will be anyway masked out by the mask the by the cal mask that we apply because we dont want the first token to watch the token number two the token number three the token number four we only want the token number four to watch the previous one so the token number four should be related to itself the previous one the token number two and the token number one but not the opposite and also we dont want to produce all these output tokens because we are all interested in the last one we are all interested in knowing what is the last uh token uh produced by the attention so that we can send it to the linear layer and then to the soft max to understand what is the word corresponding in our vocabulary so that we can use it for the prompt to inference the next token again so now lets introduce the kave cas and how the k cach solve this problem what we do with the k cache again we start from our first step of the inference so we start from our start of sentence token which is multiplied so the query is only the start of sentence token we multiply by the transpost of the keys this will produce a 1 by one matrix here then we multiply by the v and it will produce our uh first token as output we send it to the linear layer then to the soft marx then we know which token it corresponds to now in the k cache instead of appending this new token that we have produced as output to the query key and value we only append it to the key and the value and replace entirely the previous query with this new token so before without the cach we were appending the every output token so the last token of the output to the query key and values but in with the k cach we dont pend it to query key and value but only to the key and values and we only use the last output token as query for the next step so if this is the first the output of the first step so the output corresponding to the token start of sentence we take it we use it as query for the next step but we append it to the key and values and this is why its called kv cache because at each step we are keeping a cache of the previous k and v but not for the query because we are entirely replacing all the queries with the last token anyway this will produce a product so this this matrix multiplied by this matrix will produce a matrix that is 1 by two we multiply it by v and we will see that this produces only one token as output then this we take this token we send it to the linear layer to the software then we know which token it corresponds to then we use it as query for the next iteration but we append it to the only the k and the v matrix this will produce a 1x3 matrix um which is then multiplied by the v which will produce the uh this output token this is the one we are interested in basically then we use it as query for the next iteration but we append it to the k and v etc etc so as you can see at the fourth step of the inference we are producing only the last row that we were interested in when we didnt have the kvk so let me show you this is the fourth time step with the kv cach lets look at the fourth time step without the kv cach as you can see we are only producing this uh row here this is the only one we are interested in to produce this last token so with the k cash basically we reduce the number of computations that we are doing at every step because the some of the dot products we have already done in the previous steps and we only produce one token as output which is exactly the one that we need for predicting the next token okay now lets talk about the rolling buffer cach so since we are using the sliding window attention with a size of w and in the examples i show you before i was using a sliding window size with a si with a size of three we dont need to keep all the possible k and v in the cach but we can limit the k and the v on only to w tokens because anyway we will not be computing uh attention outside of this w window so we do not need imagine our window is 10 tokens we do not keep the previous 1attention will only be calculated on the previous 10 tokens so this is the idea behind the rolling buffer cach lets see how it works imagine we arrive at the token eight of inference using the kv cach if we have a kv cach and we are using the sliding window size of four for example we will see that query as query we will use the output of the previous step and as key and values we will use the entire cache which is made up of eight tokens but with because of the uh mask that we are using with the sliding window attention we are not interested in the computation of these dot products because anyway they will be masked out because the distance between this token and this token is outside of the sliding window attention so we are not interested ed in this calculating these dot products because um we will not they will be masked out and secondly we are not interested in keeping this one because anyway because this these values will be masked by our mask for the sliding window attention which basically will result in zeros here uh we are we do we do not care about producing these first four rows in the value matrix because anyway they will be multiplied by zeros so they will not contribute to the output token so here you have to imagine that let me draw here you have to imagine that the mask will take care of making this one zero this one zero this one zero this one zero and this one will be a dot product this one will be a dot product this one will be a dot product this one will be a dot product so whatever value there is here whatever value there is here here or here will not contribute to the output of this token because anyway they will be multiplied by zeros here so we do not need to keep this value also in the v matrix or in the k matrix because they anyway they will not be used by the the the sliding window attention so thats why we can limit the size of our k and v uh cach only to w tokens where w is the size of the sliding window attention that we are using now lets see how this rolling buffer cach was implemented so basically rolling buffer cach is a way of limiting the size of of a cache to a limited size in this case w so imagine our w is only four imagine we have a sentence the cat is on a chair and we want to use it or for our k cach at the first inference using the kv cache we will add the first um the first token to the kv cache then we will add the second one the third one and the fourth one but now the kv cach is full how do we proceed further basically we keep track of where we added the last item using a pointer that we keep track of and when we will arrive at the next token which is the token a we basically replace the oldest value here starting from the beginning and we update the value of the right pointer but now how do we uh go back because now the order of the tokens is not matching the sentence because as you can see now the the cash contains a cat is on but this is not the order in the original sentence in the original sentence the order should be cat is on a so what we do is we do the unrolling or un rotation and how do do it basically because we kept track of this right pointer we just need to take all the values after the right pointer and then we put the values from zero to the right pointer itself so all the values after the right pointer and then all the values before the right pointer and this is how we un rotate and this operation is done in the code in a function called un rotate you can see here uh which basically will have this condition so if the cach is not full we can just ignore the unfilled item so if the cache in is in this situation then we take all the values from the zero up to the right pointer if the cache is full then we take the value from zero up to the uh the the value of the right pointer and if the value of the right pointer is already overwriting some value then we need to ar rotate and this is done in the uh third condition here so we take all the values after the pointer and then the value up to the pointer and this is how we un rotate this uh buffer cash okay lets talk about another concept that is very important which is chunking and prefeeding basically when we generate text using a language model we use a prompt and then we use this prompt to generate future tokens when dealing with a cy cach we need to build up this kv cache so we need to add the tokens of our prompt to the kv cache that so that we can then exploit this kv cache to build new tokens future tokens now the prompt is known in advance right because because its the input of our user its what you ask to ch gpd for example right tell me a poem tell me write me a poem or tell me a joke this is our prompt so its known in advance so we dont we dont need to generate it okay so what we can do is we can prefill the kv cache using the tokens of the prompt but there are many ways to do it like we were doing before when i was teaching you about the k cach we work with one token at a time so one way to um to add the tokens to the k cach is to add one token at at a time but this can be very time consuming because imagine you have a very large prompt which happens with retrieval augmented generation which we have very big prompts like 5even bigger so this if we add one token at a time it will mean that we have to take 5network which is can be very time consuming and also doesnt exploit our gpu very much the other way is to take all these tokens and feed them all at once to the model but that may be limited by the size of our gpu because imagine we have 10prompt then maybe our gpu cannot even hold 10hold 4depending also on the w size of the attention sliding window attention that we have chosen the solution in this case is to use chunking basically we divide our prompt into chunks of a fixed size and this size is equal to w which is the sliding window attention size so imagine we have a very big prompt and we choose a sliding window size of four for the calculation of the attention and imagine that the prompt is this one so can you tell me oops can you tell me who is the richest man in history the way we work is this basically we take our first chunk of the prompt so because we chose a sliding window size of four we also will choose the chunk size to be four so we take our first token of the prompt so can you tell me and we compute the self attention in the attention uh self attention in the first layer of the model how do we build the attention mask basically as queries we take all the incoming tokens in this chunk so as this is you can think of this column as the queries and this column as the keys and this is the result of the query multiplied by the transpose of the keys plus the mask so our query we take the first incoming chunk and as keys i will show you later we take the current content of the k cash but initially it it is empty plus the incoming tokens of the current chunk and this is made it this is made for a very specific reason that i will show you in the next step so in the next step basically we take the current chunk which is the tokens who is the richest and we aggregate it with the content of the k cach using the tokens of the previous chunk so let me go go back at the first step of this prefilling we take the first chunk of the prompt so can you tell me we calculate the attention mask using as query the first four tokens and s keys as the con as keys and values the content of the k cach which is empty plus the tokens of the first chunk and then we update the content of the k cache using this uh the tokens of this chunk after we have computed the attention so at the next step the k cach now contain the previous the tokens of the previous chunk so can you tell me but now the current chunk has become who is the richest so as query again we take the tokens of the current chunk but as keys and values we take the the content of the kv cach plus the tokens of the current chunk why because uh as you can see when we were doing token generation when i was teaching you the kv cache we first add the last output token we add it to append it to the k and the v and we use it as the query for the next iteration this is not what we do here here we first calculated the attention and then we update the k cache and when we use the when we build the query the query we use only the tokens of the current chunk and as key and values we take the content of the k cache so the content of the previous chunk plus the tokens of the current chunk why because imagine if we didnt do we didnt use the content of the previous chunk what would happen is this we would have a attention mask that is only comprised of the tokens of the current chunk so it would be only limited to this metrix here let me draw it so only this matrix here but if we only use this matrix here the word who would not be able to to would not be related to the word me tell and you even if with the sliding window size they should be able to watch each other so because we want to relate the current chunk to the previous chunk we basically take uh as a key and value the content of the k cas plus the tokens of the current chunk so that we can build this attention between chunks otherwise this attention would not be built and as query we always use the tokens of the current chunk lets review how this me mechanism is built in the code so basically the prefilling is done in by chunks there is the first chunk and then there there are subsequent chunks and finally there is token generation after we have prefilled our k cach with the prompt during the first prefill which means that we are doing it for the first chunk of our prompt as attention mask we only consider the size of the incoming tokens in the current chunk but for any subsequent chunks so after the first chunk as to build the attention mask for the query we just use the size of the incoming chunk but for the k and v we use the size of the kv cache which is this one so cashed s you can see here plus the size of the current chunk which is this s variable you can see here and for token generation we do the same system that we did before when i was teaching with the k cach so one token at a time we take it we append it to the key we append it to the value and we replace the the query with the previous the the output token from the previous step so the last chunk in our case will be the tokens men in history and what we do is basically we take the the the current chunk so men in history which becomes the query while the key becomes basically the previous chunk plus the tokens of the current chunk uh so the who is the richest plus the tokens of the current chunk so men in history and the reason we do it because otherwise the word in the current chunk would not be able to be related to the word of the previous chunk which is necessary okay guys lets talk about sparse m mixture of experts so mixture of experts is an example technique in which we have multiple expert model which each of these model is trained on a subset of the data such that each model will specialize on a subset of this data and then when we produce the output of this mixture of experts we take the output for for each of these experts we combine it usually by using a weighted sum or by everying to produce one single output in the case of mistal we do not talk about only mixture of ex but we talk about a sparse mixture of experts because we have many expert model but we only use some of them let me show you in the case of mistal we have eight experts which are present as the feed forward the layer so after we calculate the self attention as you remember we have this feit forward network in the case of mistal 8x 7b we have eight feit forward layers we have to think of them in parallel and the gate is a function that basically will decide for each token which expert so which feed forward network should be working with that token and it will choose two feed forward network for each token it will run the token through these feed forward networks will take their output and will wait it according to the logics this gate produces to produce a weighted sum which will become the output of the self attention for that particular token let me show you with an example so uh this is the architecture of mistal as you can see we have the input of this um encoder layer we first run the self attention using the sliding window attention and the kv cach etc etc then we run the normalization and finally we have this gate function here which is basically just a linear layer that will produce logits eight logits which will be values lets say lets call them score values for our expert the two best performing experts so the two highest score will indicate which expert that token should work with then we run each token in it in their own two best performing experts then we take the output of these two experts we combine it with the weight what is the weight basically the uh logits produced by the gate are suppose eight values here yeah i draw only four because i dont have space but you imagine you have eight values then we take the top two so 15 and 34 in this case these are the two exper through which we will run the token we take the soft max of the two best performing values this will be the weight that well be using for the weighted sum and basically why do we do it so the the why do we do it uh because uh by using sparse m of experts we can have many expert model but during inferencing only two out of eight will be activated so as you remember the feed forw network is basically two linear layers so the linear layer can be thought of as a matrix multiplication of a weight matrix with the input so if we didnt use a sparse mixture of experts we would run the token through all the eight experts which means that we need to compute eight matrix multiplications but by using sparse mixture of experts for each token we are only doing two matrix multiplications which makes the inference faster but at the same time allows us to increase the power of the model and the parameter of the model because we are only using some parameters for um a subset of the tokens so some tokens will use the expert number one some tokens will be used the token the expert number two and three some to tokens will be using the expert number eight and the three or some other for example the six and the four etc etc so we are not using all the expert for each token but only two of them this makes us this allow us to have each expert um specialized on a subset of tokens for example imagine the model has been trained on multiple language what could happen is that basically some ex some experts so some feed forward networks are specialized on japanese tokens some feed forward n are special on english tokens or some it could also happen that some are specialized in verbs some are specialized in nouns some are specialized in objectives etc etc so this is why we use mixture of expert because we want to increase the size of the parameters of our model so the mo model becomes more powerful at capturing information but at the same time we dont sacrifice on performance because we only use a subset of the experts for each token and this is the implementation as done in the code so as you can see in the case of mistal 7b we have as feed forward just a feed forward neal network which is two linear layers um in the case of mral 8x 7b its not only one feed forward network but its eight fit forward network so this as you can see its the uh its an array of eight fit forward networks with a gating function which is just a linear layer which converts from the embedding size to eight which is the number of experts so it produces for each embedding so for each token it produces logits which indicates for which um expert this uh token should run through and it will run through them to the top two experts so the two two experts with the top logic score okay why we apply the soft max after selecting the topk expert so as i show you uh here we have the getting function that produces some logics we select the top two logits to understand which expert we should run through our uh token and then we take the score of the best two performing uh experts and we take the soft marx of them to to create the weights that we will use to create the weighted sum but why we take the soft marx of the two best performing instead of taking the soft marx of everyone well the first problem is that if we take the soft max of all of the logits then the two best performing may not sum up to one which is um which is a condition that we need in case we want to train multiple models and compare them because im pretty sure that the guys at mistal did not only train one model maybe they trained multiple models with multiple hyper parameter maybe they tried with four mixture of four experts but also with three experts or two experts then they choose the best one so if you want to compare models you want the weighted sum to always perform the sum of the wids to be only one otherwise the output range may change from model to model and usually its not a good idea to have the range of the output to change from one model to the next so to keep the range of the output stable they apply the soft marx after they have selected how many uh experts they want to work with and choosing the logits of the best two performing uh experts okay the next thing we are talking going to talk about is model sharding which is also implemented in the code of the mistal model so lets talk about it when we have a model that is too big to fit in a single gpu we can divide the model into groups of layers and place each group of layers in a single gpu for example in the case of mistal we have 32 layers of encoders you can see here one after another i didnt do all 32 of them you just think that this is layer from one to eight this this is from 9 to 16 from 17 to 24 from 25 to 32 and we put each group of layers in a different gpu so we have four gpus the the way we inference a model like this is as follows so we have our input we convert it into embeddings and we run it through the first eight layers in the first gpu the first gpu will produce an output which will be the output of the e layer we transfer this output to the second gpu and we use it as input for the ninth layer then we run all the this input through all the layers one after another until it it arrives to the layer number 16 which will produce an output we take this output we move it to the next gpu so it will become the input of the layer number 17 and then we run iteratively to all the layers until the layer number 24 which will produce an output we move it to the next gpu we run it through iteratively until the layer number 32 then we take the last linear layer and then the soft max to produce the output put of the model however you can notice that this method is not very efficient because at any time only one gpu is working a better approach which is not implemented in the code of mistal but they reference it in the paper so i will talking about it is the pipeline parallelism lets see how it works uh this pipeline parallelism i will talking about the algorithm that was introduced in this paper so gipe basically it works as follows first let me introduce you the problem this actually its used usually when we are training a model not when we are inferencing but it can also be applied to the inference imagine we want to train a model on a sharded model so a model that is split into multiple group of layers each group of layer is present on a different gpu imagine we have four gpus each one with its own group of layers imagine we want to train this model so we run our input to the first gpu so we run the forward step to the first gpu we take this output and we feed it to the next gpu so then we run forward from there we take the output and we run it through the next gpu gpu number three we take the output we run it to the next gpu the gpu number four now we have the output of the model we compute the loss and then we can run back propagation the run back propagation does basically just the opposite we go from the last gpu to the first gpu so we run back propagation on the fourth gpu then we have calculated the gradients at the fourth gpu and we use them to calculate the previous gradients at the third gpu and then we take these gradients and we use them to calculate the previous gradients and then we use take these gradients and we use to compute the previous gradients so the forward step goes from the input to the loss the backward step backward step goes from the loss to the input and all the parameters which are also known as the leave nodes in the computational graph however also as in this case you can see that at each step we are only util utilizing one single gpu and all the other gpus are quite uh not working they are idle a better way is to use pipeline parallelism so imagine that the previous step of training was done using a very big botch suppose this batch is made up of eight items what we do with pipeline parallelism is we take this batch and we split into micro batch so instead of eight items we create micro batch so four micro batch of two items each what we do is we run the first micro batch from the in the first gpu this will produce the output for the first micro batch and we can feed it to the next gpu but now at the time step one we realize that the gpu one now is free so she can already start working on the second micro batch meanwhile the second gpu is working on the first micro batch and when she will finish she can send it to the next gpu and uh meanwhile we realize that now the second gpu is free so we can if the gpu1 has finished we can take the output of the gpu1 and transfer it to the gpu2 and the gpu one will be free so it can work on the third micr batch you can see here then after the third gpu has finished it will take the uh output of the third gpu we send it to the fourth gpu but we realize that the third gpu is now free so if the previous gpu have finished we can transfer the second micr batch to the third gpu the third microbatch to the second gpu and the first gpu which will be free can start working on a new micro batch which is the fourth micro batch and basically we do this uh job of time shifting the micro batches and this will result in a better utilization of the gpus because now at every time step we at this time step for example all the four the gpus are working and also at this time step here at the backwards step and for each micr batch we calculate the gradient but we do not update the parameters we do what is called gradient accumulation which basically means that we calculate the gradient for each microbatch and we keep summing it to the existing gradients but we do not update the parameters of the model after all the micro batch have finished processing the forward and the backward we update the parameters of the model uh the gradient accumulation is a technique that i have introduced my my previous video on distributed training so if you want to understand how it works i i refer you to my previous video on distributor training in which i explain also the math behind grit accumulation and how it works but b basically this is the solution with pipeline parallelism so we can actually divide our batch into micro batches and this can also work with inferencing because when we inference we just dont have this backward step here right so we just delete this second half of the table but we can still take our big batch at the beginning we split it into micro batches and we time shift them uh according to the availability of the gpu and uh this um pipeline parallelism basically introduces still some uh time steps in which not all gpus are working and these are called bubbles to avoid bubbles these big bubbles here what we can do is we can uh use a bigger initial batch size so we have multiple micro batches okay guys now lets go to the last part of this video i know that the myal code is much more complicated to understand compared to the lama code and i will show you why but i will also help you understand the most complex topic in the code which is the x forers library which is a trick they use to improve the inference performance and its actually a very advanced technique and i want to give you a glimpse into how it works so basically imagine you are running an ai company and you are providing llm inference service so you have a customer that has you for example provide an api and you have customer that send their prompts to your api and then one to run inference through your large language modules each prompt of course may have different length because each customer may be using the the large language model for different purposes for suppose simplicity suppose that each word is a token so suppose you have three customer the first customer says write a poem the second customer says write a historical novel and the third customer says tell me a funny joke of course you could process all these prompts one by one but that would not be very efficient because uh the two other two customer would be waiting for the first customer to finish and when you have a lot of customers thats not good and secondly you may not be fully utilizing the memory of your gpu so the best thing that you can do is to do batching you create all these prompts you create one big batch but the problem is that the prompt have different lengths so the first prompt is made up of three tokens the second prompt of four tokens and the third prompt of five tokens one solution is to to add padding to these tokens so basically we create a batch in which we append padding tokens to the input sequence until they all reach the same size then we can run this sequences this batch to our a large language model which could be for example llama or mistal as we saw before when we have a input sequence of end tokens the attention mechanism produces an output sequence of end tokens and we usually take the embedding of the last token send it to the linear layer then the soft max to understand what is the next token from our vocabulary but in the first prompt we see that we have added two padding tokens so we cannot use the embedding corresponding to the last two tokens because they correspond to the padding token what we should do is we should take the embedding corresponding to the last non padding token to and then send it to the linear layer and then to the softmax to understand understand what is the next token and in the case of the second prompt we should be using the fourth token not the last one only in the last prompt we can use the last token because its the last its a non not padding token now we have done this and how do we actually create a attention mask to to run it we basically just create an attention mask that is cal that will make each token only uh visualize the previous tokens so each token will be able to relate to previous tokens but not to future tokens and this mask here will work fine for all the three scenarios you can see here and i will show you later how we cannot use a different mask for each prompt because all the prompts are of the same length so all the mask must be 5x five because you cannot use a 3x3 mask for this prompt a 4x4 matx uh mask for this prompt and the 5x5 for this prompt because the input sequence is five so we must use a 5x5 mask and we have to use a 5x5 mask that is cal and also has the uh we can also mask out for example imagine the sliding window is size is four then we can mask out this value here also because we dont want the uh this token here to watch tokens that are distance of more than four for example so the problem here is that we are calculating a lot of dot products especially for the first and the second produ that will not be used let me show you why when we apply this mask so the 5x5 mask you can see here to this input sequence here which are i want to remind you is a batch it will produce the following attention mask in which all these value will be masked out because they are minus infinity minus infinity and its because of the causality of the mask uh we cannot mask um this value here because they are needed for the last prompt for example and we also cannot mask this value here which is needed for the last prompt but for the first and the second prompt we are doing a lot of dot products for example these ones between padding tokens and other tokens that we will not be using because if i i want to remind you that in the first prompt at the output of the model so we will be using the output at the third token at the for the second prompt the output at the fourth token and only in the last token we will be checking the last output of the output of the self attention but for the first two prompts we will not be even checking the last token output from the self attention because they correspond to the padding token so is there avoid a way to avoid these padding tokens uh being introduced in our calculation and calculating all these dot products which will result in output tokens that we will not even use well there is a better solution and the solution is this the solution is to combine all the tokens of of all the prompts into one big sequence consecutively and we also keep track of what is the actual size of each prompt so we know that the prompt are coming from our api because we are running an ai company and we have this api so we know that the first customer has a token size prompt of size three tokens the second one has four tokens and the third one has five tokens so we can keep track of these sizes in an array for example and then we buil this sequence which is a concatenation of all the prompts that we receive we take this mega sequence we run it through our llm ser llm model so it could be mistal or it could be llama this as i told you before uh and input sequence in a transformer will result in n output tokens in the output so we have uh here we have three  4 so 7 7  5 12 tokens as input it will produce 12 tokens as output to understand what is the next token for each prompt we need to check the the we need to check the embedding corresponding to the token number three for the first prompt to the token number seven for the second prompt and the last token for the third prompt so we take all these embeddings we run them through the linear layer then we apply the soft marks and then we understand what is the next uh token from our vocabulary but you may be wondering how do we even produce an attention mask that can work with multiple prompts that are combined into one sequence such that the token of one sequence should not of one prompt should not be attended to the tokens of the another prompt but only of the tokens of the same prompt right well the x forers library allow us allow us to do that using a method called block diagonal cal mask which is also used in the source code code of mistal so i want to show you how it works basically x forers this method called block diagonal causal mask will produce a mask like this it will be um group basically all the prompts into groups such that each token only can attend to the tokens in the same group here we have three prompts so the token po for example can only attend the token of the same uh prompt the token novel for example cannot be related to the token poem so it will put minus infinity here but all the token of the same prompt will be able to be attended by the the token novel while the token uh in the last prompt will be only be able to attend the other tokens in the same prompt and this is a special mask built by using the x forers library let me show you how it works in the code okay i want to show you actually how it works so in the mistal source code they are using this um library called x forers x forers library allows us to compute very complex attention mask and also to calculate the attention in a very efficient way using the memory efficient attention calculation which i will not show in this video maybe i will make a future video about it but basically what they do in the misal source code if you have multiple prompts they will create one big sequence and then keep track of the number of tokens of each prompt and then they use these methods made available by the x forers library to build this complex attention maps that keep track of the different size of the kv cache because each prompt may have a k cache that is different from another prompt because imagine you have a prompt with 5tokens of course you will have a k cach that is 5in in another case so the mask attention mask that we build should take care of this and the second thing is that each group of tokens should only be able to relate to the same to to the tokens of the same group not to other groups so not of of tokens from another prompt and this is done with the um block diagonal cal mask so basically we tell him okay the first prompt is made up of seven tokens the second prompt is made up of five tokens and the third prompt is made up of six tokens and we are also using a sliding window attention with a sliding window size of three and basically this will create the complex marx that we can see here this is the first group of tokens from 0 to six is the first prompt from 7 to 11 is the second prompt and from 12 to uh let me check 17 is the third prompt and as you can see it also takes into consideration the sliding window size so each token can only watch at most two previous tokens so the tokens in the in the contained in the sliding window size of size three the second one they use is the block diagonal mask and okay this one is used for the first chunk during the prefilling this one is used for subsequent chunks in the prefilling and basically it also takes in because during the first prefilling we dont have the kv cache because its initially empty but during the subsequent steps its not empty anymore so we need to take into consideration also the different size of the k cache uh so for example the first token may have a k cache of size 10 because the prompt is very short but the second prompt may be very big suppose 5have a k cach of size 5takes into consideration also the size of the kv cache and it will produce a um a mask that takes into consideration also the size of the kv cach the last uh method they use is this one block diagonal cal with offset padded keys mask because each prompt may have a different size for the k cache uh but only some tokens in this k so the k cach size is fixed its a tensor that is of fixed side w but only some tokens may be actual being filled in this k cach so only maybe the k cach the size is lets say 10 but because the first prompt is very short only three tokens are actually part in are in the k cach um but when we pass the k cach to the calculation of the attention we pass all the tensor which is all the 10 items so we need a way to tell to the mask that he should only use the first three items from the kv cach and not all the kv cach not all the tensor and this is done with block diagonal with offset pading mas so this method here its very long name very complicated but this is why they use it and it will produce a mask like this so it takes into consideration the actual size of the kv c even if the k all the kv cach have the same size because its a fixed size tensor but it tells you how many items there actually it should use from each cache okay guys it has been a very demanding video i have to say uh i had to record it more than once i actually had to cut some parts because i even i got confused sometimes uh its very complicated topics its a lot of things that you have to grasp but i hope that it will make your life easier when you want to understand the mistal code i actually am also putting online my notes the one that you have seen so the two notebooks that i have shown you plus also the code annotated by me on the mistal source code now the mistal source code i actually never run it so because my computer is not very powerful so i never run the actual model on my computer what i did to study the model was to run some random tensors through a model and i created basically a model with randomly initialized uh weights but with less number of layers so it could fit in my gpu and then i just run some random tensors to study all the shapes of the tensor and all the information passing so i dont know if the code works but i hope it will works i mean i didnt touch the logic i just add some comments uh anyway you can use the commented code by me to as um as a learning tool to complement with the official code of mistal so that you can understand uh more about the inner workings of this grd model i actually really enjoyed studying it i really enjoyed studying the code and i learned a lot of stuff you know um i think its very very good when you are doing something that is very complicated because it teaches you a lot because if something is simple then you dont learn much by the end of the day anyway guys thanks you for watching my video i hope you also enjoyed this journey with me even if it was very complicated i hope that you likeed this video and you will subscribe to my channel if you didnt please do it and the best way to support me guys is to share this video with all the people you know so share it on social media share it on linkedin on twitter etc because this is the best way to you can help me is to grow my channel and um please let me know if there is something that you dont understand i am always available to help and connect with me on linkedin byebye 