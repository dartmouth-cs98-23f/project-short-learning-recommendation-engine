"and I don't just mean your code and its librariesall pre-configured to run as soon as you deploy it. "That's a container. They're lightning fast"isolated environments that you can create in mere momentsand after this video you're going to wonder how you ever developed and deployed applications without them. But that's just a VM! "No"Okay"an OS"to spin upIf there was a scale with VMs on one side and normal native applications on the "otherVirtual machines are pretty much just tricked by the host's hypervisor layer into thinking they're actually running on real hardware. "Containers"emulate a minimal file system"the host's kernel. The kernel is the... noClose enough. The kernel is the core of any operating system. It's the bridge between what the software asks for and what the hardware actually does. It's responsible for all sorts of "critical low-level tasks like CPU and memory management"file systems"developers? Well"fingertipsenvironments at once without having to really compromise anything on our local "machine. For example"using the OS and package dependencies it was originally built on top ofwhile also being able to use bleeding edge tech for our next multi-million dollar project without having to worry about any conflicts in doing so. "We're also now able to put an end to the it works on my machine problem"which is a pretty common phrase to hear in the tech industry"Because a container is essentially a full OS at its coreyou can be sure that wherever it runs you're going to get the exact same "environment"machineNow we've got the basics out of the way. Let's see how we can make a container of our own. The first thing we're going to need is a container platform. This will give us all the tools we need to create and run "our containerjust because it's the most well supported. All containers run from a base "file system and some metadata"And the way container images work is kind of fascinatingbecause they are formed with overlapping layers. Here's a banana to kind of badly demonstrate this idea. "Okay"its source"differences to the previous layerthe final system state. It's somewhat similar to how source control tracks changes in your code. This concept is really powerful for "containersany previous image or image layer. There's loads of pre-made and officially "supported base images out there"requirements"To do this in Docker"file called a Dockerfile. Docker will execute each command in sequenceand then add each generated change to the final image as a new file system "layerlike from a single image. We can do this because when a container "is first created"layer"This means that we can make any runtime changes we like"other containers using that same image. What's more"until we delete the container"without losing any data. We can even enter our running containers"like we do with a VM. With Linux containers"we can start a shell prompt when executing itenvironment to explore and kind of just play around with as we please. "Communication between containers is usually pretty simple as wellas most runtimes virtualize a network layer for you. "When our app is ready to be published into the world"tag it with something uniqueit again later. We can then publish it to something "called a container registry"warehouse for our images. By default"using the official Docker registry. However"if you wish to use another. When it comes to deploymentcloud platforms have built-in support for deploying containers as "standalone units. Alternatively"compatible container runtime on whatever machine you want to usepull your image from the registry you pushed to earlier. "It does require a few more steps doing it this wayvalue for money and quite a bit more control. If you "want to go even deeperKubernetes essentially allow you to create your own container-based cloud. "You describe the desired state of your deployment declarativelyand let Kubernetes handle the details of how to get there. "And that's it. Oh"and with enough supportand I'll see you next time. 