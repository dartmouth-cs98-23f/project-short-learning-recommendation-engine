second,duration,transcript
0.08,3.76,in this episode of the back engineering
1.76,3.2,show i would like to talk about
3.84,3.919,threading
4.96,5.44,multi-threaded application
7.759,6.161,specifically within the context of
10.4,6.959,networking and connection management
13.92,5.68,to be more specific even than that tcp
17.359,5.361,connection management it's very critical
19.6,4.96,in backend applications that you have a
22.72,3.6,socket that you listen to
24.56,3.2,whether this is a
26.32,4.4,web server
27.76,5.92,whether this is a ssh server
30.72,6.24,whether this is a custom made
33.68,5.52,protocol that you built grpc
36.96,5.599,you know any other protocol
39.2,3.359,right but the the
42.719,7.041,the challenge becomes how do you accept
46.48,6.559,connections from clients and how much
49.76,5.04,uh can a single box
53.039,3.601,right
54.8,3.599,manage all these connections from all
56.64,3.919,these clients this is what i want to
58.399,3.121,talk about in this episode let's jump
60.559,2.48,into it
61.52,3.44,welcome to the backend engineering show
63.039,4.561,with your host hussein nelson and this
64.96,4.24,is our series our laid-back series where
67.6,3.28,we sit down and
69.2,4.32,and discuss
70.88,4.559,interesting topics and specifically to
73.52,3.919,back in engineering
75.439,4.241,it's a it's a podcast so you can listen
77.439,4.481,to it on your favorite podcast player
79.68,4.88,there's i usually don't add
81.92,5.28,any graphic at all it's supposed to be
84.56,4.32,just a talking head video so if you like
87.2,3.919,this kind of content
88.88,4.4,consider subscribing to this channel and
91.119,4.881,check us out on the spotify and apple
93.28,4.32,podcast yeah i do have other content on
96.0,4.24,this channel if you this is not your cup
97.6,4.64,of tea of course i understand i have all
100.24,4.08,sorts of other content i have crash
102.24,3.839,courses i have
104.32,2.799,you know tutorials
106.079,2.241,i have
107.119,4.481,hands-on
108.32,4.72,stuff using software you know with that
111.6,4.799,out of the way
113.04,7.039,let's get into it in the early days very
116.399,6.481,very very early days of computing
120.079,5.441,when you spin up a process
122.88,3.839,and you had a single cpu on your host
125.52,4.56,machine
126.719,4.401,and that process executes certain tasks
130.08,2.64,let's say
131.12,3.199,it accepts a connection and that
132.72,3.68,connection now
134.319,5.041,has some sort of a request
136.4,4.8,let's say it's an http request
139.36,3.04,once it
141.2,2.96,determines
142.4,3.6,where the request starts and where the
144.16,4.32,request ends
146.0,4.319,that logic of the
148.48,3.36,translation of a request will be taken
150.319,4.161,to the application and then application
151.84,5.44,start processing it whatever that means
154.48,5.36,you know if it's a git slash api that
157.28,5.36,will make a request to some other
159.84,4.88,database as somewhere else so we'll
162.64,5.28,establish another connection to other
164.72,5.04,database since the request since the sql
167.92,2.959,command
169.76,3.04,or the
170.879,3.521,you know
172.8,3.68,key value
174.4,4.32,request to get a value
176.48,4.88,regardless what is the processing some
178.72,5.439,of the processing will be
181.36,4.159,localized within that instance so it
184.159,3.201,will consume
185.519,4.72,cpu
187.36,5.12,power from that host some of the kind of
190.239,5.28,the request will be
192.48,5.119,not cpu bound maybe ioban whether this
195.519,4.8,is
197.599,4.961,a network call or a desk call hey i'm
200.319,3.92,going to the desk so that's why very
202.56,3.679,important to understand the nature of
204.239,7.121,your back-end and whether it's
206.239,6.56,does it cost cpu or does it cost io
211.36,3.28,and this is
212.799,4.321,an episode by itself you know because
214.64,4.239,you can scale differently based on that
217.12,4.72,but regardless if you
218.879,6.241,assume it's a cpu intensive app
221.84,6.56,where you're you're doing processing in
225.12,6.08,the machine itself right
228.4,4.88,even after sending a request to the
231.2,4.88,database getting response you kind of
233.28,4.48,doing localized processing even if you
236.08,3.6,don't know it
237.76,3.759,you are using you're probably using a
239.68,4.639,library that does that kind of
241.519,5.841,processing especially the serialization
244.319,5.761,deserialization that's costly encryption
247.36,5.599,decryption of tls all of this stuff is
250.08,4.32,happening without us knowing
252.959,4.24,and uh
254.4,5.359,i try as much as possible
257.199,4.241,at least this is for myself
259.759,3.601,to
261.44,3.6,erase
263.36,5.76,all this uh
265.04,6.879,m ambiguity and and you know the
269.12,5.359,vagueness of anything that i use by
271.919,4.481,understanding what every
274.479,4.401,single thing i use
276.4,4.32,what is actually doing right
278.88,3.759,it's not everyone's cup of tea i
280.72,3.919,understand but i like to understand
282.639,3.201,everything i use that's just me it's
284.639,3.921,just
285.84,5.84,gives you it keeps your eye open in the
288.56,4.88,old days when you have this single core
291.68,5.2,and you have single process
293.44,6.08,that core will be occupied to your
296.88,4.0,process right and you might your host
299.52,2.8,might have multiple processes and they
300.88,3.92,are sharing
302.32,4.96,you know time sharing this cpu and like
304.8,5.6,all right let's stop there i'm done
307.28,5.28,take over cpu right take over the next
310.4,5.04,process process three you can take over
312.56,6.079,and the operating system is scheduling
315.44,6.72,these things you know more few years
318.639,5.041,more few more years a decade maybe
322.16,3.52,in the future
323.68,6.079,and now we
325.68,5.44,were able to make cpus more
329.759,2.321,powerful
331.12,2.56,you know
332.08,3.76,uh we have
333.68,3.28,more power for cpus the single core is
335.84,2.639,powerful
336.96,3.04,move
338.479,3.681,a little bit forward
340.0,4.32,and now we have the ability to add
342.16,6.319,multiple cores
344.32,6.24,in a processor so you have a processor
348.479,5.041,but that processor will have multiple
350.56,4.079,cores so there's dual cores technically
353.52,2.0,think of it
354.639,3.28,two
355.52,3.28,cpus you know
357.919,3.921,and
358.8,4.56,we have four chords eighth chords
361.84,4.16,so on
363.36,4.48,with that in mind
366.0,4.24,we don't have contention between
367.84,6.88,different applications now
370.24,6.399,because if i if my single process app
374.72,4.08,will get a core
376.639,4.721,and the other host
378.8,4.959,processes can use other cores
381.36,3.52,that's pretty neat i no longer share one
383.759,2.88,core between
384.88,4.08,all the processing
386.639,3.761,but developers thought about it says
388.96,5.359,ha
390.4,6.32,that sounds like a great idea
394.319,4.241,what if my app
396.72,4.56,i'm greedy
398.56,5.44,i am greedy
401.28,5.84,my app is a single process but what if
404.0,4.639,my app actually consists of multiple
407.12,3.84,processes
408.639,3.12,or multiple threads
410.96,3.359,right
411.759,4.16,a process and a thread is very it's it's
414.319,3.28,almost like splitting hairs when it
415.919,3.441,comes to a process and a thread
417.599,3.921,especially in linux i think this process
419.36,3.2,is a thread it's just like they share
421.52,4.0,the same
422.56,4.88,memory sort of speak right
425.52,3.76,so what people invented was says all
427.44,2.96,right let's just spin up multiple
429.28,2.16,threads
430.4,3.28,you know
431.44,5.12,so multiple worker threads
433.68,6.16,and we have one main thread and let them
436.56,5.84,do the work in parallel why
439.84,4.4,because now not only i have access to
442.4,6.079,one core
444.24,7.04,my multiple threads can utilize multiple
448.479,5.521,cores you know at the same time
451.28,4.0,no sore
454.0,3.68,even
455.28,5.039,i'm starting to remember even in the
457.68,6.4,2000
460.319,5.041,six ish 2006 and 2007 multi-threading
464.08,2.88,was the
465.36,3.119,jam you know
466.96,2.959,like everybody was talking about
468.479,3.201,multi-threading
469.919,3.601,it's like oh yeah you have to get into
471.68,3.84,multi-threading like maybe it was
473.52,5.2,earlier than that but when i
475.52,4.799,because 2005 was the start of my career
478.72,4.479,and this is where i started hearing
480.319,6.481,about multi-threading that's just being
483.199,3.601,a lot of people start talking about it
486.879,3.76,so now a lot of people move to
488.96,4.079,multi-threading
490.639,4.721,because of the performance benefit that
493.039,4.081,mike they might get
495.36,3.76,right
497.12,3.759,because now i can share multiple cpu if
499.12,4.16,a single process
500.879,4.641,needs x amount of cpu
503.28,4.96,and i can parallelize that work let's
505.52,4.0,pin up multiple threads
508.24,2.88,right
509.52,3.519,and let
511.12,4.24,divide this work
513.039,4.88,and let them all
515.36,2.559,spin up
519.2,5.28,their own task and they execute these
521.68,5.04,tasks in parallel concurrently if you
524.48,2.24,will
526.8,6.039,that was a revelation so now we are
528.88,7.2,using multiple core so the app is is
532.839,5.081,faster but just like any
536.08,3.36,human
537.92,3.76,evolution
539.44,5.12,nothing comes
541.68,5.68,without its own problems almost every
544.56,6.64,solution we create as engineers comes
547.36,7.599,with its own downsides i can't think of
551.2,6.4,anything that we created
554.959,4.961,you know software engineering wise
557.6,5.359,that didn't come with its own downside
559.92,5.2,solos follow the case correct me if i'm
562.959,4.801,wrong what's the problem
565.12,6.159,with multi-threading
567.76,4.8,well the benefits of multi-threading is
571.279,5.281,obvious
572.56,6.16,the problems with multi-threading is
576.56,3.839,two things that i can think of first the
578.72,3.2,management of the threads and the
580.399,3.681,resource access
581.92,4.16,we mentioned that when you spin up a
584.08,3.199,process you are allocated certain amount
586.08,4.96,of memory
587.279,5.521,right it's called the heap you can dump
591.04,3.28,your stuff there
592.8,3.52,but then
594.32,3.519,and and we never had this problem before
596.32,3.92,with the single process because a single
597.839,4.401,process is a single process you know
600.24,4.4,it's when a single process want to write
602.24,3.76,a read a variable it can go ahead and
604.64,3.199,read that variable we need to want to
606.0,3.839,write the variable
607.839,3.041,nobody's writing to that variable except
609.839,3.44,itself
610.88,5.6,but with multi-threading
613.279,6.321,all these threads shares the same memory
616.48,4.96,it's a shared memory when it comes to
619.6,3.84,just that process
621.44,3.839,you can also have shared memory between
623.44,3.68,processes as well
625.279,3.601,i suppose
627.12,4.64,no i'm pretty sure you can
628.88,3.76,i think postgres has that concept
631.76,2.319,and
632.64,4.56,it's an operating system thing i think
634.079,4.801,you can have as dedicated share memory
637.2,4.8,but only do you have a shared memory
638.88,5.12,between these threads those guys
642.0,5.76,start competing
644.0,5.6,on these resources because no two thing
647.76,3.44,no two threads can access the same
649.6,3.2,variable at the same time
651.2,2.72,you might say why
652.8,3.76,they can't
653.92,4.919,sure they can let them do that
656.56,4.48,but you get undesired
658.839,3.721,results and this is a whole thing i talk
661.04,4.08,about in my database course when it
662.56,4.88,comes to the acid thing like atomicity
665.12,3.839,consistency isolation and durability we
667.44,3.44,have the same problem there right
668.959,4.161,because we are a concurrent system
670.88,4.079,database after all so you have two
673.12,3.76,transactions trying to update the same
674.959,4.161,row what does what does that mean what
676.88,4.8,is what do we do
679.12,3.76,so the simplest thing to do is to
681.68,2.8,acquire
682.88,3.12,a mutex
684.48,4.08,or a lock
686.0,5.12,i think it's the same thing no
688.56,5.519,where you if a thread wants to write
691.12,5.52,something it acquires a mutex on it it
694.079,4.961,locks it says hey hey this variable i'm
696.64,4.8,about to write to it nobody can write to
699.04,4.4,it or nobody can read to it at all
701.44,5.92,so if another if i want to do something
703.44,7.839,to that it's blocked see
707.36,5.76,then the management of this stuff
711.279,3.921,is absolutely
713.12,3.92,challenging a lot of people liked it in
715.2,5.04,the beginning but the more they got into
717.04,6.16,it the more complex your app becomes now
720.24,5.039,things that you use do not worry about
723.2,4.72,now you have to worry about them at the
725.279,5.281,cost of an additional cpu so you're
727.92,4.479,finding yourself serializing
730.56,4.48,things so
732.399,5.44,so you the multi-threaded apps all of a
735.04,4.96,sudden now if this uh if these threads
737.839,4.8,are completely isolated you you want the
740.0,5.76,jackpot but if they need to access the
742.639,4.721,same variable which guess what almost
745.76,3.44,most of the time you're going to need to
747.36,3.12,access the same variable either to read
749.2,4.24,or write
750.48,5.039,to increment the value even increment
753.44,4.0,is a very hard problem to solve like how
755.519,4.241,do you increment something
757.44,4.48,you have to serialize it when i say
759.76,4.4,serialized i mean you have to lock it so
761.92,4.56,that the other thread cannot
764.16,4.799,they cannot both of the time let's take
766.48,3.919,an example let's say increment the value
768.959,3.841,the variable
770.399,3.841,foo right
772.8,3.2,if you have two threads that doesn't
774.24,4.399,increment both of them will read the
776.0,4.56,value both of them will read zero both
778.639,3.921,of them will increment it and then both
780.56,3.2,of them will store one
782.56,3.44,that's not
783.76,4.639,correct right because incrementing in
786.0,4.56,that particular case should give you
788.399,3.761,0 1 and 2.
790.56,3.2,instead you've got one so that's just a
792.16,3.28,simple example of where things can go
793.76,2.8,wrong okay
795.44,3.399,but
796.56,4.0,so now we talked about multiple
798.839,3.24,multi-threading uh
800.56,3.04,of one of the problems with multi-thread
802.079,4.0,is the management of the the second
803.6,4.08,problem that i think of is
806.079,4.32,uh
807.68,2.719,isolation
810.88,7.04,in in a bad way
812.88,5.04,if every thread is running in isolation
818.24,3.839,we don't know
821.04,2.72,what
822.079,3.76,the workload
823.76,3.6,of these threads we don't know if this
825.839,4.0,thread
827.36,4.8,is overloaded compared to this thread
829.839,4.8,that is might not be overloaded so as a
832.16,5.679,result you might not have even load
834.639,5.041,balancing between these threads right
837.839,5.201,so in order to do that you have to
839.68,4.159,introduce a manager a coordinator
843.04,3.359,right
843.839,3.36,more complexity
846.399,2.88,but
847.199,3.841,it is it is what it is so why am i
849.279,3.761,talking about multi-threading right we
851.04,3.599,all know what multi-threading is but i
853.04,4.56,thought it's very critical to talk about
854.639,4.56,and then we're gonna link it back to
857.6,3.039,socket management and connection
859.199,3.76,management here
860.639,2.32,you see
864.48,4.88,when you have
866.24,5.12,when you have a web application and no
869.36,4.0,js application and node.js is a bad
871.36,3.599,example it's a single thread so let's
873.36,4.64,take it out of the equation let's say
874.959,5.521,you built your own app from using c
878.0,2.48,or go
880.639,5.361,and you have a single thread
883.44,5.28,and you said hey
886.0,6.639,i want to listen on port 80
888.72,3.919,that's a web app http
893.76,5.8,so would you listen
895.6,3.96,on port 80.
900.24,2.959,what happened is you're telling the
901.76,2.8,operating system
903.199,3.121,that hey
904.56,5.6,on this particular
906.32,6.48,ip address i'm listening to port 80 and
910.16,4.0,you can specify which ip address
912.8,3.2,might say what do you what does that
914.16,3.6,mean i should have only one ip address
916.0,3.519,nope you have
917.76,2.879,so many ip addresses
919.519,2.481,on your
920.639,4.32,machine
922.0,5.04,you have the loopback that's an ipad
924.959,4.56,you have
927.04,5.28,you might have an ethernet
929.519,5.521,that has an ip at us but i have a wi-fi
932.32,4.56,that has i don't know ip address
935.04,4.0,might have a
936.88,6.16,a docker
939.04,6.08,bridged in uh interface neck you might
943.04,4.08,have a virtual neck
945.12,2.88,you might have another ethernet port
947.12,3.6,yeah
948.0,4.48,and all you all of these network card
950.72,3.52,another nic i mean
952.48,4.24,can have their own ip headers they have
954.24,4.08,their own connected to their own gateway
956.72,4.08,and they have another completely
958.32,3.84,different ip and a different subnet
960.8,3.44,so
962.16,4.64,when you listen in a specific
964.24,4.959,interface right you can listen on all of
966.8,5.279,them if you want and
969.199,5.041,sadly that's the default and most
972.079,4.161,i didn't understand this before
974.24,2.88,i recently learned that like in the past
976.24,5.36,year
977.12,6.719,like listening is very expensive and i i
981.6,5.2,really
983.839,5.68,i'm really worried that the default
986.8,4.32,when you don't specify hey listen 80
989.519,4.32,even in node.js
991.12,4.639,most apps when you listen it's listening
993.839,3.841,on all interfaces
995.759,3.44,why
997.68,4.48,i would love
999.199,5.44,i guess they did it for simplicity but
1002.16,5.52,just like anything in engineering the
1004.639,6.801,more the if the moment you simplify
1007.68,6.079,the developer experience by making the
1011.44,5.8,code easier
1013.759,5.041,you're introducing your hiding
1017.24,3.08,abstractions
1018.8,3.839,right you're introducing abstraction
1020.32,5.519,which hides the complexity of these
1022.639,5.601,interfaces right
1025.839,4.321,and this is a perfect example when you
1028.24,3.839,just listen on port 80 i know i'm going
1030.16,3.12,all over the place but i think it's all
1032.079,3.76,related
1033.28,4.88,so if you listen on port 80 which is the
1035.839,3.761,default like without and was specifying
1038.16,3.039,a host
1039.6,4.079,what will happen is
1041.199,5.36,it will listen to and i a pseudo ip
1043.679,7.161,address called 0.0.0.0
1046.559,6.24,right which means listen on all
1050.84,3.8,interfaces and
1052.799,3.801,to nitpick actually i think it listens
1054.64,5.039,to all
1056.6,6.16,ipv4 interfaces
1059.679,5.12,right if you do
1062.76,4.44,fffffff that
1064.799,5.12,that listens to
1067.2,5.68,uh all ipv6 i might be wrong on that one
1069.919,5.12,but just just to guess right so this is
1072.88,3.039,all interfaces
1075.039,2.481,why
1075.919,4.64,what what if you're building like an
1077.52,4.08,admin api right
1080.559,3.281,and
1081.6,3.6,this admin api shouldn't only be
1083.84,2.64,accessed
1085.2,3.599,within
1086.48,5.12,the machine itself
1088.799,4.081,or within a specific
1091.6,3.12,interface
1092.88,4.64,so if that host happened to have a
1094.72,4.88,public ip address and you wrote your
1097.52,4.24,application in a way said
1099.6,4.959,such that it listens to all ipads by
1101.76,5.76,default then you just expose your admin
1104.559,2.961,api to the public
1107.679,4.0,that's why
1109.679,2.961,that's why all
1111.679,4.0,all these
1112.64,6.64,leaks happen with elastic search leak
1115.679,4.88,and mongodb leak and then
1119.28,5.279,postgres
1120.559,6.24,leak right because when you listen when
1124.559,4.881,postgres listen to us when mongodb
1126.799,5.201,listens it listens to all ip addresses
1129.44,5.68,i think the default should be changed
1132.0,4.72,the default should be hey you tell me
1135.12,4.4,which interface to listen to and i
1136.72,4.959,understand is that's not convenient
1139.52,3.84,for programming
1141.679,3.761,but
1143.36,4.8,i think we should at some point point we
1145.44,5.28,should stop simplifying everything
1148.16,4.8,because that's not the way to go
1150.72,3.52,right just simplifying everything
1152.96,3.44,because
1154.24,4.48,eventually you're gonna get you're gonna
1156.4,5.68,get bit in the ass that's what's gonna
1158.72,5.76,happen right yeah you simplify the api
1162.08,4.16,and that's true for everything we're
1164.48,4.16,doing in software engineering look at
1166.24,4.08,all the countless libraries
1168.64,3.919,all competing
1170.32,3.2,to
1172.559,2.641,make
1173.52,3.36,the code
1175.2,3.92,shorter
1176.88,4.159,instead of writing oh my code is only
1179.12,4.24,five lines of code oh my code is three
1181.039,4.561,client of code my card is one line of
1183.36,3.679,code in one line of code you can do all
1185.6,3.84,of this stuff
1187.039,3.201,these things really scares me because
1189.44,2.239,you
1190.24,3.36,the do you know the developer who's
1191.679,3.921,gonna use this you have no clue what's
1193.6,4.88,going on behind that one line of code
1195.6,5.6,you know and that is really creepy
1198.48,4.24,right hey if you know what's going on
1201.2,3.12,all power to you
1202.72,3.52,but if you don't and you're just using
1204.32,2.96,an app and this is hey one line of code
1206.24,4.72,and
1207.28,3.68,voila i built twitter
1211.52,2.72,that's a whole thing by itself i don't
1212.96,2.32,know
1214.24,2.559,yeah
1215.28,3.12,i know i know
1216.799,3.841,we'll come back to the point
1218.4,5.6,yeah so listening on port we talked
1220.64,6.0,about all these ipv4 thing ip interfaces
1224.0,6.0,but we listened we have a listener
1226.64,3.36,and it's a single thread listener
1230.159,3.041,so when you
1231.28,3.12,listen
1233.2,5.52,what happened
1234.4,6.639,is the operating system will allocate
1238.72,3.68,let's call the backlog for you the queue
1241.039,2.961,if you will
1242.4,3.519,okay
1244.0,5.44,now again this is just tcp let's not go
1245.919,6.721,through udp right now because http 1 and
1249.44,4.32,hdb2 is gcp so let's just assume tcp for
1252.64,2.72,now
1253.76,3.84,if you listen
1255.36,4.96,the operating system will like will
1257.6,4.48,allocate a q40 and you can specify the
1260.32,4.08,length of this cube i think it's a
1262.08,4.24,thousand by default
1264.4,5.519,and that queue
1266.32,7.28,is in the kernel memory
1269.919,5.361,so you're here at the user space
1273.6,3.76,you listened your application is running
1275.28,5.759,you asked the operating system hey i'm
1277.36,5.76,listening to port 80 the os will create
1281.039,3.601,all right it says okay
1283.12,4.32,i'm listening on the loopback one two
1284.64,4.32,seven seven zero zero one right
1287.44,4.0,let's say i'm
1288.96,3.76,i'm practicing hygiene here and i only
1291.44,2.96,listen to the loopback because i don't
1292.72,3.68,really need to listen to anything else
1294.4,5.519,so they always will clear this
1296.4,5.36,two cues for us something called the syn
1299.919,4.64,queue and something called the accept
1301.76,3.76,cue right what are these well we talked
1304.559,4.081,about
1305.52,6.159,how the tcp works right there is a sen
1308.64,4.72,snack and then ack which is the
1311.679,5.36,three-way handshake
1313.36,6.799,so every time a client want to connect
1317.039,5.841,to your server on that specific ip
1320.159,5.281,address on that specific port
1322.88,5.039,which is 80
1325.44,5.52,it will need to send a send
1327.919,7.521,packet tcp
1330.96,7.44,segment which is carried in an ip packet
1335.44,5.599,and is sent to that the operating system
1338.4,4.08,receives it through the network
1341.039,3.361,interface
1342.48,2.8,controller
1344.4,2.96,right
1345.28,4.08,or some people like to call it card
1347.36,4.72,network interface card
1349.36,2.72,same thing right
1352.72,6.56,that network card will take that
1356.48,4.72,frame and then package it up into an ip
1359.28,4.56,packet and then package it up to a tcp
1361.2,4.719,so i'm going to ship it to the
1363.84,3.839,to the operating system and i think it
1365.919,4.321,doesn't even do that it just takes the
1367.679,4.961,frame hey is it is it destined to is the
1370.24,4.559,frame tested into this machine yes yep
1372.64,4.08,just take it ship it to the os the os
1374.799,4.321,will take it oh it's a sin and it's
1376.72,5.36,listen to 80 as listen to this ipad is
1379.12,4.72,yup ask me let me add this
1382.08,3.92,to the syn queue
1383.84,4.719,and it will add it to the syn queue
1386.0,3.36,right the app doesn't know about it yet
1388.559,3.921,right
1389.36,5.199,now it adds that to the send queue they
1392.48,3.28,always kicks in and it will say all
1394.559,4.0,right
1395.76,4.32,let it's time to start finishing the
1398.559,4.721,handshake right
1400.08,4.719,so once it added to the syn queue the os
1403.28,2.96,will kick in and they say okay let me
1404.799,3.12,take this sin
1406.24,4.4,request because someone is trying to
1407.919,4.64,connect to me right at this point it's
1410.64,5.039,not a full-fledged connection yet it's
1412.559,5.521,just a request to connect if you will
1415.679,3.601,so the os will take that
1418.08,3.12,sin
1419.28,2.8,and they say okay then i need to send us
1421.2,2.479,a knack
1422.08,4.4,i agree
1423.679,4.24,synag will send us an act to the
1426.48,3.28,to the uh
1427.919,3.841,to the client
1429.76,4.399,and then we'll move on because it needs
1431.76,5.039,to receive the final act right so we'll
1434.159,4.721,move on so meanwhile lots of other sins
1436.799,4.961,are coming connection to request and
1438.88,6.24,they are added to the queue yeah that's
1441.76,4.399,by the way house sin flooding can happen
1445.12,3.6,right
1446.159,4.721,because because you're adding blindly
1448.72,3.439,adding the send
1450.88,3.679,packets
1452.159,4.0,to this queue this queue can easily get
1454.559,2.801,flooded right
1456.159,4.0,why
1457.36,4.96,very easy a client that's cinder sin
1460.159,3.361,and never acts
1462.32,4.0,okay
1463.52,4.88,just send sin sin sense and
1466.32,3.92,all of a sudden you're flooded nobody
1468.4,3.759,can else can connect why because there
1470.24,4.96,is a timer
1472.159,5.12,and the reason is every sin
1475.2,3.839,that is received
1477.279,4.241,all right
1479.039,5.281,is it automatically synacked
1481.52,4.48,immediately it will be try to send act
1484.32,3.52,the operating system will try to send us
1486.0,3.919,an act back and that will immediately
1487.84,2.88,fill back the backlog that we talked
1489.919,3.12,about
1490.72,4.16,so you can increase the backlog
1493.039,4.401,but or you can decrease the backup to
1494.88,3.279,prevent that sunflower has been solved
1497.44,2.88,with
1498.159,4.561,send cookies but we don't want to go
1500.32,4.08,that right now it's a different story
1502.72,3.92,for another day
1504.4,2.24,but
1506.88,4.159,that's how it works so let's say a
1508.799,3.12,legitimate client will send an act back
1511.039,3.601,so
1511.919,4.721,completing effectively the handshake so
1514.64,5.36,when the opponent system receives that
1516.64,6.639,final act it maps it back to an entry in
1520.0,5.279,the queue so oh you are from this guy
1523.279,4.241,because the sin will have a
1525.279,4.081,source port
1527.52,4.08,and a source ip
1529.36,5.84,and a destination port and a destination
1531.6,4.559,ip and those four tuples will be mapped
1535.2,1.839,to
1536.159,2.88,that
1537.039,3.441,queue effectively right
1539.039,3.921,and that will
1540.48,3.52,effectively complete the connection
1542.96,2.56,and the moment the connection is
1544.0,2.88,complete
1545.52,3.92,that pop
1546.88,4.08,it's popped from the queue
1549.44,3.04,and now there is another key that we
1550.96,3.76,talked about
1552.48,3.6,the accept queue which is basically a
1554.72,2.72,full-fledged connection to happen here
1556.08,4.16,so hey
1557.44,4.4,i i guarantee this client is good he
1560.24,3.039,finished the connection with us again we
1561.84,3.6,didn't send anything here we're just
1563.279,4.561,connecting we didn't even establish the
1565.44,4.96,tls i'm not even talking about tls right
1567.84,3.68,here right it's port 80
1570.4,3.36,right
1571.52,4.08,the next thing is to send an actual http
1573.76,3.12,request right but
1575.6,2.88,we send that
1576.88,4.08,and now
1578.48,4.799,that connection will be transferred to
1580.96,4.64,an accept queue
1583.279,4.88,all right what does that mean
1585.6,5.76,it means that it's
1588.159,5.361,the operating system does did its job
1591.36,3.679,it's up to the application
1593.52,3.68,which is moi
1595.039,4.081,remember i listened
1597.2,3.839,listening to an app doesn't mean you
1599.12,2.72,have connections right
1601.039,3.041,you
1601.84,3.6,as the application
1604.08,2.8,which is the backend application in this
1605.44,3.839,particular case
1606.88,6.399,have to accept connections
1609.279,6.88,actively accept connections so you have
1613.279,4.161,to technically ask the you the operating
1616.159,2.721,system
1617.44,3.2,do i have a connection do you have a
1618.88,2.88,connection you have a connection do i
1620.64,3.039,have a connection do you have a
1621.76,3.68,connection that's how it works
1623.679,2.801,today
1625.44,2.8,right
1626.48,3.52,and you can do this by calling something
1628.24,3.76,called accept
1630.0,4.88,and you might say i never did this with
1632.0,5.039,not js well node.js does that for you
1634.88,3.519,behind the scenes
1637.039,3.041,there is
1638.399,3.361,there is an infinite loop that just
1640.08,4.079,accepts
1641.76,5.76,what is this infinite loop we might say
1644.159,5.041,it is in your thread
1647.52,4.8,which is again we said it's a single
1649.2,3.839,thread app so we have one listener
1652.32,3.359,it
1653.039,4.721,it it it has a loop that and that's
1655.679,5.12,accepting all the connection
1657.76,4.96,and the way it works if it cause accept
1660.799,3.681,if the the the
1662.72,3.52,the function call except will go to the
1664.48,3.919,operating system say hey i want to
1666.24,4.88,accept the connection so sure you you
1668.399,3.921,have one right here in the accept queue
1671.12,3.84,take it
1672.32,4.479,and take it really means that it was
1674.96,4.8,going to be popped from the accept queue
1676.799,4.401,and a file descriptor a unique integer
1679.76,3.2,value
1681.2,4.079,will be returned to that
1682.96,4.079,thread that called accept whoever called
1685.279,4.0,it will get that
1687.039,5.041,file descriptor and that file descriptor
1689.279,4.801,will represent your connection
1692.08,6.0,and that is one
1694.08,5.76,client one connection one user connected
1698.08,3.12,to you
1699.84,3.92,and then you can
1701.2,4.479,exchange information using that file
1703.76,3.76,descriptor so the thread can write to
1705.679,3.281,the file descriptor and i can read from
1707.52,4.399,the file descriptor
1708.96,4.719,and that's its own story
1711.919,3.841,reading and writing
1713.679,4.48,there is asynchronously there is
1715.76,3.2,synchronous blocking reads and there is
1718.159,3.201,this
1718.96,5.599,whole new thing that
1721.36,6.48,linux built called iou ring which is a
1724.559,5.281,fabulous design for asynchronous
1727.84,4.88,reads and rides
1729.84,5.28,for everything files network calls
1732.72,4.88,pretty much everything right so
1735.12,4.72,i owe you ring that's what it's called
1737.6,4.64,but let's let's not get into a lot of
1739.84,4.48,details here let's keep this objective
1742.24,4.319,and
1744.32,3.52,yeah sure what's the problem i have a
1746.559,3.12,single thread
1747.84,3.52,that's single thread which is not js
1749.679,4.081,contrary to the belief
1751.36,4.08,not js is a single threaded app yeah it
1753.76,4.08,has multiple threading apps but has
1755.44,5.76,nothing to do with networking right the
1757.84,6.0,networking is still a single threaded
1761.2,5.28,experience in node.js the only time
1763.84,5.76,node.js uses a multi-threading and it's
1766.48,6.96,documented well documented in node.js is
1769.6,6.4,when it does dns entries and
1773.44,5.359,in specific
1776.0,5.44,libraries where it uses multiple
1778.799,5.041,but dns definitely right
1781.44,4.239,and i suppose when when it uses
1783.84,4.079,asynchronous
1785.679,4.161,file system reads i talked about through
1787.919,3.601,node.js threading uh check out the video
1789.84,4.079,there just type
1791.52,4.159,node.js studying hussein and you should
1793.919,3.681,find it
1795.679,3.12,but yeah
1797.6,2.559,but network
1798.799,3.921,also in girl thread
1800.159,5.201,so that means i have a loop that accepts
1802.72,4.8,connection and i have a loop
1805.36,3.919,that actually
1807.52,4.56,processes
1809.279,2.801,my request
1813.76,6.32,so that's actually pretty cool so
1816.32,5.44,that connection that thread will just
1820.08,3.92,accept the connections so i have a
1821.76,4.0,connection file descriptor what if what
1824.0,3.44,if another user came in another
1825.76,3.76,connection request well i'm just going
1827.44,3.68,to accept it again the thread if it's
1829.52,3.36,free it's going to accept the connection
1831.12,3.679,and now i have another file descriptor
1832.88,5.12,so now it's your responsibility to add
1834.799,4.24,it into an array so to speak right
1838.0,4.48,because
1839.039,5.281,if it's an http request you you you can
1842.48,4.559,do that right you there will be an event
1844.32,4.16,that will be called for you and they say
1847.039,3.52,hey there is an
1848.48,5.12,event an open i think connection open is
1850.559,5.281,called right in http library itself and
1853.6,4.48,that will be delivering you an actual
1855.84,3.199,connection object even fancier than that
1858.08,2.719,right
1859.039,3.681,and the connection object will have
1860.799,4.0,methods like write and read and this is
1862.72,5.04,how websockets
1864.799,5.521,work identically right the same thing
1867.76,4.56,and you'll build basically an array of
1870.32,5.359,connection in your thread in your
1872.32,6.56,process and uh you can talk to any of
1875.679,6.401,them right and every connection object
1878.88,5.84,will have an event associated with it so
1882.08,5.36,and what is happening is your app is
1884.72,4.16,constantly asking hey did i get a read
1887.44,3.599,here did i get a read here did i get a
1888.88,4.0,read here did i get it right here all of
1891.039,4.721,this stuff is really going to be
1892.88,5.36,managed by the node.js http library and
1895.76,4.72,says okay oh some something just came in
1898.24,4.319,from connection number one oh something
1900.48,4.0,came just coming from connection number
1902.559,5.12,103
1904.48,5.36,and so on right so we have one thread
1907.679,4.0,what's the problem of this it easily
1909.84,2.64,becomes the bottleneck right
1911.679,2.561,because
1912.48,3.199,if one of those connections sends you an
1914.24,4.4,http request
1915.679,6.561,and at that http request you're
1918.64,5.2,doing a blocking call
1922.24,3.6,that is
1923.84,5.28,computing
1925.84,4.4,a hash or doing something so expensive
1929.12,2.96,and let's assume you don't have
1930.24,4.24,threading because if you do like a
1932.08,5.12,specific krepto
1934.48,4.559,operation node.js will use threading if
1937.2,3.199,you enabled it but let's assume there is
1939.039,3.041,none right
1940.399,3.201,so if you're doing that compute that
1942.08,2.88,expensive let's say it's a loop while
1943.6,4.799,loop
1944.96,4.88,and while loop one through
1948.399,5.681,you're done
1949.84,4.24,basically why because now
1954.159,3.281,it depends on what node.js will do i
1955.84,3.52,keep talking about node.js as an example
1957.44,2.8,because it's a very popular backend
1959.36,3.439,right
1960.24,4.96,but if you build your own c application
1962.799,3.36,you have to do all this stuff yourself
1965.2,2.88,right
1966.159,3.36,so now you're blocked
1968.08,4.4,and that becomes
1969.519,5.201,quickly becomes the bottleneck
1972.48,5.679,the listening authority cannot do work
1974.72,5.12,technically you can of course you can if
1978.159,4.081,you know the limit
1979.84,5.12,but at the moment you do work in the
1982.24,4.799,listeners in the same thread then new
1984.96,4.719,connections cannot be accepted
1987.039,3.76,or they will be delayed because
1989.679,3.6,the
1990.799,3.441,moment that listener thread the worker
1993.279,3.041,thread
1994.24,3.919,will have a time to breathe
1996.32,4.8,finally i'm done with this test oh i'm
1998.159,5.36,go i'll go now go accept a connection oh
2001.12,3.52,i'll go execute a read right here oh let
2003.519,3.441,me go
2004.64,4.56,the user asked me to write something up
2006.96,3.839,so it's just busy doing stuff
2009.2,4.719,you will be
2010.799,5.36,facing blocking at some point right
2013.919,2.24,so
2016.559,4.881,now what do we do like one
2019.76,2.799,use case
2021.44,3.359,right
2022.559,3.761,is uh what memcache d does and we
2024.799,3.681,digested a
2026.32,4.32,crash course architecture
2028.48,4.16,crash course on memcache d what
2030.64,4.48,memcached does is it's exactly identical
2032.64,3.84,the same thing right it has one listener
2035.12,2.159,thread
2036.48,2.48,but
2037.279,3.601,that listener thread only accepts
2038.96,3.199,connection the moment it accepts a
2040.88,3.519,connection
2042.159,5.201,it spins up a new thread
2044.399,5.121,and since that thread that thread that
2047.36,3.12,connection file descriptor says hey
2049.52,3.04,thread
2050.48,3.84,take it that's yours now
2052.56,3.92,i'm gonna move on now
2054.32,4.319,you have the file descriptor you do a
2056.48,3.439,thing if there is a read
2058.639,3.28,that comes into that connection it's
2059.919,3.76,your responsibility if you want to write
2061.919,2.96,right to that i'm not involved anymore
2063.679,4.081,as a main
2064.879,4.321,listener thread my job has done i just
2067.76,2.639,accepted the connection i handed you the
2069.2,3.36,connection
2070.399,4.321,so the connection array
2072.56,5.039,if you will it's not in the listener
2074.72,4.8,main thread it's in the somewhere else
2077.599,4.24,keep shaking the table
2079.52,4.079,right it's in in the thread so another
2081.839,2.8,connection came spinnable another
2083.599,3.361,connection
2084.639,4.401,and there is a limit to the threads i
2086.96,4.879,don't know what is the limit i think
2089.04,4.879,it's a thousand right because it will go
2091.839,4.0,crazy after a while right that's why
2093.919,3.041,memcached say hey don't go above a
2095.839,3.121,thousand
2096.96,4.72,per instance goes there i don't know
2098.96,4.56,what will happen right
2101.68,3.84,it's fascinating once you know what's
2103.52,4.48,happening it's just
2105.52,5.36,so cool to understand really
2108.0,6.64,hey guys hussein from post editing right
2110.88,5.84,now and uh noticed that uh it might be
2114.64,4.0,this is slightly incorrect reading
2116.72,4.399,through the memcache d so i just wanted
2118.64,5.52,to clarify something it sounds like the
2121.119,6.081,default number of threads in memcache d
2124.16,6.24,is four you can up that
2127.2,5.919,but they do not recommend that right but
2130.4,4.88,every connection that comes in right
2133.119,4.401,will spin up a new thread
2135.28,5.28,but up until the maximum number thread
2137.52,5.04,allowed if the default is four those
2140.56,4.0,four will share these new connections so
2142.56,3.12,every connection that comes in
2144.56,4.559,will be
2145.68,6.72,given to one of the available threads so
2149.119,5.281,it's not one thread pair connection
2152.4,4.56,it's one thread
2154.4,4.88,multiple connections per thread
2156.96,4.639,otherwise bear as per the dock i'm going
2159.28,4.799,to share it below as well uh it's going
2161.599,4.0,to be a disaster if there will there
2164.079,3.921,will be like a thousand can actually
2165.599,3.841,have a thousand thread so one thread
2168.0,4.4,multiple connection pathways just a
2169.44,5.12,slight clarification there so just to be
2172.4,3.679,uh objective a little bit here back to
2174.56,4.88,the video
2176.079,4.961,yeah so that's one way so the work
2179.44,4.96,the compute
2181.04,5.12,is done in the threads right that's
2184.4,4.24,that's my point with the multi-threading
2186.16,4.32,so that's powerful so now
2188.64,4.08,i accepted the connection
2190.48,4.0,with the multi-thread right or when with
2192.72,3.119,the listener thread but the connections
2194.48,4.08,are being
2195.839,4.801,worked out in each and on thread so a
2198.56,2.88,read that is happening
2200.64,3.84,is
2201.44,5.04,a responsibility of the thread that can
2204.48,4.08,should continue to pull
2206.48,4.56,for read are you is there a read is
2208.56,5.76,there a read is there a read is there it
2211.04,6.079,right or a blocking grid or a iou ring
2214.32,4.48,read depends where we whatever you use
2217.119,4.401,the threads are doing this job now so
2218.8,4.559,that's a model that's one way to do it
2221.52,4.24,what so we talked about
2223.359,5.841,one way have one thread do do everything
2225.76,6.24,ex accept the connection and do the work
2229.2,5.36,doesn't scale well right
2232.0,4.0,another way memcache d
2234.56,2.72,have one thread accept all the
2236.0,3.2,connection but
2237.28,3.839,send off these connections
2239.2,4.08,spin up a new thread for each connection
2241.119,4.24,and let the connection do the thread
2243.28,4.799,what's the problem with that design
2245.359,4.961,the problem with that design is
2248.079,2.241,uh
2250.56,2.96,one connection
2253.839,2.881,not all connections are equal what does
2255.68,2.64,that mean
2256.72,4.16,a client
2258.32,5.279,that connected to my application might
2260.88,4.64,be greedier than other clients
2263.599,3.681,right
2265.52,4.0,one client might send
2267.28,3.44,very heavy requests and another kind
2269.52,3.36,might send
2270.72,4.32,lightweight request right
2272.88,4.719,another request by just just flood with
2275.04,4.799,me with requests that are so tiny
2277.599,4.721,so they are not equal what does that
2279.839,6.081,mean it means that you'll end up with a
2282.32,6.0,thread that is so overloaded and other
2285.92,3.679,threads that has connections have
2288.32,2.88,connections
2289.599,2.48,but they're relaxed they're just
2291.2,2.96,chilling
2292.079,4.161,sitting there chilling doing nothing or
2294.16,4.32,doing very minimum work
2296.24,4.8,so you wasted memory on spinning all
2298.48,5.76,these threads but those threads ain't
2301.04,5.52,doing much okay
2304.24,4.16,why why is this the case because that's
2306.56,3.84,part of the problem on multi-threading
2308.4,3.76,we talked about it initially right
2310.4,5.199,multi-threading is just there is no
2312.16,3.439,knowledge knowledge
2318.079,4.481,there is no knowledge
2320.24,4.32,it doesn't exist the knowledge doesn't
2322.56,4.24,exist between these threads so you'll
2324.56,4.72,end up with unfairness
2326.8,4.319,and this word that we live in is very
2329.28,4.16,unfair my friends
2331.119,3.281,it's very very unfair so one thread
2333.44,2.8,might do
2334.4,3.199,80 of the work
2336.24,3.599,while the other
2337.599,4.401,threads are sitting by the water cooler
2339.839,4.401,and drinking and chatting and
2342.0,4.0,just having fun
2344.24,2.96,you know
2346.0,4.16,so
2347.2,2.96,another model
2350.32,6.56,is as follows
2352.24,4.64,what if we do this what if
2357.28,5.6,let the
2359.76,3.12,so that's the third one now
2363.52,4.16,let there be one listener thread let
2366.079,3.76,that be multi-threading but here's how
2367.68,4.08,we're going to do it
2369.839,3.601,that thread is responsible to accept the
2371.76,5.2,connection so we have the connections
2373.44,5.04,but keep the connection arrays in the
2376.96,4.24,main thread
2378.48,4.72,um isn't that just the first one nope
2381.2,4.72,wait a second let's do that let's do
2383.2,4.0,that what if since
2385.92,4.32,since we're trying to solve this load
2387.2,5.919,balancing problem right
2390.24,2.879,what if we do this
2393.52,3.76,what if
2395.44,4.96,we accept the connections we have this
2397.28,5.36,connection array in the thread
2400.4,4.08,all the file descriptors
2402.64,3.92,but
2404.48,4.48,we also read
2406.56,4.08,from all the connections
2408.96,4.24,but
2410.64,3.84,we do not process so we read the
2413.2,3.04,requests
2414.48,2.879,the little the listener thread is just
2416.24,3.119,re
2417.359,4.48,accepting connections saving this for
2419.359,5.281,the sculptor and also reading from all
2421.839,5.681,these connections
2424.64,4.64,so it's reading request but the request
2427.52,3.52,oh you want git slash this is get slash
2429.28,3.76,api this is good
2431.04,4.799,blah this is a good structure
2433.04,7.2,and now that it has the
2435.839,6.641,vision of requests what it does is hey
2440.24,4.56,okay i have a request i think this is
2442.48,4.32,going to be expensive go there thread
2444.8,3.2,hey there's another request you're there
2446.8,2.72,there's another
2448.0,3.599,all right and
2449.52,4.319,we start distributing requests to
2451.599,4.561,threads not connections the the threads
2453.839,4.801,have no clue about connections here so
2456.16,4.4,you just send requests
2458.64,3.679,send requests hey process this process
2460.56,2.96,this process
2462.319,3.361,so now we just
2463.52,4.319,split it the problem
2465.68,2.96,that's a beautiful design i like it a
2467.839,1.76,lot
2468.64,2.56,and
2469.599,3.841,i like it a lot
2471.2,5.119,now we kind of distributed the lot
2473.44,5.36,because now if there is a thread that is
2476.319,4.8,doing a lot of work the main thread
2478.8,4.64,knows about it hey this thing is busy it
2481.119,4.48,knows it's busy because hey it's talking
2483.44,4.56,to it you can argue that this is part of
2485.599,4.401,the problem we're talking to it there is
2488.0,4.079,exchange
2490.0,4.24,but hey you got to pay a price all right
2492.079,4.161,nothing is free
2494.24,4.8,but yeah just talking to them talk talk
2496.24,4.96,talk talk and then send requests right
2499.04,4.319,and hey you're busy hey he's a threat
2501.2,4.32,that is not doing anything hey get back
2503.359,5.201,to work here's some work
2505.52,4.96,do some work stop sitting
2508.56,3.279,next to the water
2510.48,2.96,cooler
2511.839,3.041,do some work
2513.44,3.36,okay
2514.88,3.52,no more sitting next to the
2516.8,2.72,water cooler
2518.4,2.0,okay
2519.52,2.559,so
2520.4,3.36,load dancing assault that's what's
2522.079,4.161,that's an interesting solution that's
2523.76,4.4,all i like it a lot i like a lot
2526.24,2.72,i forgot what app uses that design
2528.16,2.8,though
2528.96,3.52,here's another one
2530.96,3.04,uh
2532.48,4.4,go back
2534.0,5.119,to the original model
2536.88,2.239,right
2539.839,4.24,now let's let's let's do one more
2542.16,4.0,so one two three fourth
2544.079,4.561,a fourth one
2546.16,5.6,we always talk about one listener thread
2548.64,4.88,why do we have only one listener process
2551.76,4.4,why don't we have multiple
2553.52,4.64,processes listen to the same port haha
2556.16,2.88,we can't have you even seen this error
2558.16,2.4,before
2559.04,3.279,you listen to port 80 and you try to
2560.56,3.92,listen to port 80 again
2562.319,3.841,another app says hey port is already
2564.48,3.2,listening
2566.16,3.439,can't do that
2567.68,4.56,right that was by design you cannot have
2569.599,5.201,two processors listed on the same port
2572.24,6.4,but if you know what you're doing you
2574.8,5.92,can turn that that switch and let the
2578.64,5.92,operating system know
2580.72,5.04,it's cool opening system i own these two
2584.56,3.2,puppies
2585.76,2.96,so you can spin up two puppies two
2587.76,5.52,threads
2588.72,8.08,listening on the same port
2593.28,5.28,by turning on an option called
2596.8,4.48,so
2598.56,4.799,reuse port socket option underscore
2601.28,6.16,reuse port it's like hey reuse port
2603.359,5.361,useful so now you have multiple
2607.44,3.6,reds
2608.72,5.04,listeners listening on the same port so
2611.04,4.559,now multiple threads
2613.76,4.319,you can have 10 threads listening on the
2615.599,5.201,same port
2618.079,4.881,so the operating system
2620.8,3.92,and all of them are calling accept
2622.96,3.44,are looping
2624.72,2.96,so now the throughput of accepting
2626.4,4.56,connection are
2627.68,5.28,way higher you don't have a single
2630.96,5.44,thread accepting the connection because
2632.96,4.96,if you have a client a flood of users
2636.4,3.52,connected at the same time you're going
2637.92,4.08,to face trouble accepting connections
2639.92,3.52,right talked about that right the accept
2642.0,4.079,queue might be full
2643.44,3.84,and the app is not fast enough except in
2646.079,3.681,this connection because it's just a
2647.28,3.28,single thread so you do this
2649.76,2.319,just
2650.56,3.36,scatter shot
2652.079,3.04,all of the threads threads are less
2653.92,3.52,unorthodox
2655.119,3.761,all of them are listening
2657.44,2.399,all of them are listening at the same
2658.88,1.84,time
2659.839,3.041,and all of them are accepting
2660.72,4.32,connections so it's an in-parallel
2662.88,4.4,connection acceptance so each of you
2665.04,3.84,whatever connection you accept it's your
2667.28,4.319,loot
2668.88,5.04,you take care of it it's yours you
2671.599,4.161,process it you do whatever you want
2673.92,3.679,proxies like invoice support that
2675.76,4.559,proxies like ha proxy supports that i
2677.599,5.841,support nginx even supports that
2680.319,4.881,right because it's a it's a busy you do
2683.44,5.04,this when you have like a very busy
2685.2,6.399,back-end you accept like a api gateway a
2688.48,6.0,load balancer like a layer 4 reverse
2691.599,4.72,proxy when you do that even layer 7
2694.48,3.599,doesn't matter right
2696.319,5.04,you
2698.079,5.601,right this gateway is going to have ton
2701.359,5.201,of connections so you would need to
2703.68,4.88,accept as fast as possible connections
2706.56,4.08,either deliver them to another thread
2708.56,3.92,you can do that model right instead of
2710.64,4.08,you but then you're going to have a
2712.48,3.28,thread explosion
2714.72,3.52,so
2715.76,4.16,comes to the fourth this is fourth one
2718.24,3.119,fifth one now
2719.92,3.36,which is kind of
2721.359,4.0,i i like
2723.28,4.48,back to the basics back to the original
2725.359,4.801,model single beautiful thread
2727.76,4.64,it listens and it works
2730.16,5.12,as i said you're not using your power
2732.4,4.0,of multi-core
2735.28,3.2,sure
2736.4,3.36,i can though
2738.48,2.8,what if
2739.76,3.76,i
2741.28,5.039,i don't want to listen in the same port
2743.52,5.839,single threaded app so simple that's my
2746.319,5.04,job that's my app so my app becomes so
2749.359,3.841,elegant because it's a single thread
2751.359,4.561,doesn't have this mumbo jumbo of threads
2753.2,5.04,and connections and loop and
2755.92,4.08,coordination no not that
2758.24,3.52,a single thread you might say jose
2760.0,3.52,single core you're not going to take
2761.76,6.559,advantage of your
2763.52,4.799,16 core aws instance here
2768.4,2.959,i'll let you know
2769.839,4.401,i have this beautiful thing and i use
2771.359,5.281,this thing that's called docker you know
2774.24,3.119,put in my app in a container and i spin
2776.64,2.88,up
2777.359,4.161,a hundred containers
2779.52,4.079,of my application
2781.52,3.76,all of them are different ports sure and
2783.599,2.72,then put that
2785.28,3.68,and then
2786.319,4.8,let them do the work right
2788.96,3.76,in this case
2791.119,3.2,can i have two containers listed on the
2792.72,3.359,same port
2794.319,4.161,i wish i can
2796.079,3.841,if it's not if it's possible then this
2798.48,4.08,is really good let the operating system
2799.92,3.919,handle that i suppose you can i never
2802.56,3.759,tried it
2803.839,3.841,right but that'll be really cool but
2806.319,2.241,even if not
2807.68,3.84,then
2808.56,5.36,i can just do an ipv table
2811.52,5.76,rule that just say hey if someone
2813.92,6.32,connect to port 443 or 80
2817.28,4.96,load balance them through these guys
2820.24,5.68,right and you're going to have an a
2822.24,5.2,process running on port 81 82 83
2825.92,4.72,just give an example
2827.44,5.04,so now your app is didn't change
2830.64,3.84,but now you've just taken
2832.48,3.76,advantage of a single
2834.48,5.44,threaded app
2836.24,5.119,but literally multiplicated
2839.92,3.6,right
2841.359,4.24,so you are taking advantage of your
2843.52,3.44,single machine cores
2845.599,3.681,and at the same time you kept your
2846.96,5.599,application simple i like this design i
2849.28,5.76,like it a lot hey you might say one one
2852.559,5.28,app might receive more load than the
2855.04,6.559,other then you might add another logic
2857.839,6.161,on top of it like a a layer 4 proxy that
2861.599,3.681,controls that maybe
2864.0,2.88,you can do that
2865.28,3.52,then of course it becomes kind of a
2866.88,4.239,single point of failure
2868.8,4.96,make it simple make it a nat
2871.119,4.561,level layer for proxy
2873.76,4.24,i don't know i just i just like that
2875.68,4.879,fifth model it's just it seems like it's
2878.0,4.24,so elegant and simple i i of course
2880.559,3.52,nothing is free i'm pretty sure it has
2882.24,5.119,its own problem but simplicity like
2884.079,6.321,going back to the basics okay
2887.359,4.72,my app having my app being simple is is
2890.4,3.919,a game changer
2892.079,4.0,like given that you have to of course
2894.319,4.321,write your app in a way that is
2896.079,4.801,statelesslyishway
2898.64,4.88,yeah certain isn't it i throw an arabic
2900.88,5.04,word there and when i'm tired
2903.52,4.72,specifically after a long day
2905.92,5.36,like today right i'll
2908.24,5.119,uh my english juice will
2911.28,4.88,deplete and i'll start throwing arabic
2913.359,5.521,words because back to my native language
2916.16,5.76,i i work always and by the time i it's 6
2918.88,5.679,p.m i'll start just uh
2921.92,5.28,i can't talk english anymore
2924.559,4.081,i don't this is just me
2927.2,3.28,all right this is kind of indication
2928.64,3.52,that i have to in this video all right
2930.48,3.599,guys i hope you enjoyed this uh video i
2932.16,3.6,i like this stuff i like this a lot uh
2934.079,2.961,i'm learning a lot
2935.76,2.559,and uh
2937.04,2.96,if you enjoyed this kind of content
2938.319,3.201,consider becoming a member this channel
2940.0,4.0,supports the show
2941.52,4.319,uh check us out on spotify
2944.0,3.119,apple podcast would you if you prefer to
2945.839,4.72,listen to this
2947.119,5.041,and uh check out my courses uh this is
2950.559,3.76,this is kind of at the same realm
2952.16,3.84,network.hsnasa.com
2954.319,3.921,for discount coupon learn the
2956.0,4.559,fundamentals of network engineering
2958.24,5.119,because any anything that comes on top
2960.559,4.641,can be derived to its basic first
2963.359,3.041,principles hope you enjoyed this episode
2965.2,4.919,i'm going to see you in the next one you
2966.4,3.719,guys stay awesome goodbye
