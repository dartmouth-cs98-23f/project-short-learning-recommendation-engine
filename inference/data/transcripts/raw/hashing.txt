second,duration,transcript
0.08,2.96,in a previous episode of the vacuum
1.439,2.641,engineering show i talked about hash
3.04,2.64,tables
4.08,4.64,and how
5.68,4.24,uh powerful and very commonly used they
8.72,2.879,are
9.92,5.28,given a key
11.599,6.801,we can find its corresponding value
15.2,4.72,in no time in zero seek time we're not
18.4,4.16,searching we're not scanning we're not
19.92,5.279,doing anything it's a single axis
22.56,6.639,in memory retrieving that value the
25.199,6.0,power behind hash tables is the use of
29.199,4.081,the arrays which is a very common data
31.199,4.481,structure obviously very
33.28,4.799,very common data structure right knowing
35.68,3.68,the array position the
38.079,3.921,the index
39.36,5.359,you can get the value of the array
42.0,5.039,immediately because you know how how
44.719,3.601,does memory work if you know the address
47.039,2.561,of the ram
48.32,3.919,where your
49.6,4.72,cell exists where your values exist
52.239,4.16,you can get the value immediately right
54.32,5.36,the cpu can fetch the value immediately
56.399,5.201,for you right so once you find the index
59.68,4.0,you find the address you can value so
61.6,3.68,what the hash table guys did it says
63.68,4.24,okay we're gonna
65.28,5.68,take your name your string your color
67.92,4.879,your car your va anything that has been
70.96,4.0,this key we're going to hash it using a
72.799,4.32,one-way function and then convert that
74.96,4.88,into an index using a modulo function
77.119,4.561,based on the array size so we eventually
79.84,4.72,from the name we convert and continue an
81.68,4.4,index and that will give us the address
84.56,3.599,and the memory and we can get the value
86.08,4.8,so that's the trick the hash table guys
88.159,4.64,use you know so the only cost you add is
90.88,4.559,like what the hashing function which is
92.799,4.801,not really that bad but that's the power
95.439,5.601,of the hash table but the problem is the
97.6,5.6,moment the size of the array changes the
101.04,4.079,hash table size changes
103.2,5.52,this all forms apart
105.119,7.761,because what what the if blue the key
108.72,6.64,blue used to fit in index number 11
112.88,4.72,if you increased or decreased the array
115.36,5.439,size and i you know where i'm going with
117.6,5.839,this then the blue will fit into index
120.799,4.801,99 now and as a result
123.439,4.0,right you either won't find the value or
125.6,2.879,you're gonna start writing the values
127.439,1.921,duplicate
128.479,2.641,and
129.36,4.16,everything will basically
131.12,5.119,be bad so you now have to really move
133.52,5.2,things around your resize and it's a
136.239,4.961,really big problem so why i'm mentioning
138.72,4.64,that the problem that we are seeing
141.2,3.36,today with distributive system is as
143.36,4.48,follows
144.56,6.24,if my database are increasing in size
147.84,6.24,and it no longer can fit in a single
150.8,7.2,instance i i bumped up the vertical
154.08,5.12,scaling to its maximum it's now 48 core
158.0,4.84,cpu
159.2,7.759,three gigahertz whatever you know it's
162.84,8.039,512 gigabyte or even one terabyte
166.959,6.881,ram but still i have billions of rows
170.879,5.041,i cannot i added all the indexes i try
173.84,5.28,to partition it horizontally in the same
175.92,6.239,instance by range so but still the even
179.12,6.56,the partitions are so large so i that
182.159,6.241,machine cannot handle the queries um
185.68,5.919,throwing at my beautiful database so
188.4,4.88,what do we do we distribute it we shard
191.599,3.92,the database that's
193.28,4.72,i really don't like to go there unless i
195.519,4.8,kind of exhaust all my options and
198.0,5.44,believe me people don't even look at the
200.319,5.441,options anymore people are very quick to
203.44,4.159,follow modern things you know without
205.76,3.68,actually going to the basics and
207.599,3.521,trying to tune your database and getting
209.44,2.96,a better performance but regardless
211.12,3.839,let's assume you're a youtube scale
212.4,4.96,let's give you a google scale and you
214.959,4.321,run out ideas that single instance can't
217.36,4.879,handle anymore you need to distribute
219.28,6.16,the billions of rows table
222.239,4.161,or key dictionary or collection into
225.44,3.2,multiple
226.4,3.759,servers right so instead of having
228.64,3.36,billions let's have i know a few
230.159,2.961,millions on this server and few millions
232.0,3.04,on this server a few millions on the
233.12,4.56,server female in the server
235.04,4.559,immediately a problem occur the problem
237.68,3.199,is like how do i know
239.599,4.161,right
240.879,6.08,if i have a key i want to look it up
243.76,5.92,we introduced an intermediately an
246.959,4.64,intermediary problem right that didn't
249.68,4.96,exist before
251.599,4.88,well first if i have a key i go to my
254.64,4.24,database server and i ask it and i
256.479,4.48,immediately give it to me i only go to
258.88,4.48,one hop now
260.959,3.921,if you're distributed and you only have
263.36,4.0,the key
264.88,5.52,you have to answer the first question
267.36,6.399,which server should i connect
270.4,5.519,to to retrieve the key which server
273.759,4.481,hosts my key
275.919,5.121,and that is the problem here that is the
278.24,5.36,original and only problem that we have
281.04,5.599,in distributed system which
283.6,5.28,server should i connect to to fetch that
286.639,2.241,key
289.44,6.4,so the trick was always
292.56,5.12,let's figure out the server from the key
295.84,4.4,and that is the concept of hashing
297.68,4.4,hashing tables appear here so in this
300.24,4.239,episode of the vacancy show i'd like to
302.08,4.88,talk about that a little bit distributed
304.479,4.321,hashing and then
306.96,5.44,what problems did we have and how
308.8,5.119,consistent hashing solves this problem
312.4,3.68,and obviously
313.919,4.56,nothing is perfect in this world so i'd
316.08,4.559,also like like to talk about the
318.479,4.16,problems consisting hashing actually
320.639,3.361,have today welcome to the backend
322.639,4.081,engineering show with your host hussein
324.0,5.039,nelson and the concept of distributed
326.72,5.759,system is a must when you get to a
329.039,4.72,certain scale yeah i always try as much
332.479,2.081,as possible
333.759,1.761,to
334.56,4.32,you know
335.52,5.84,push people against being distributed if
338.88,4.8,they can do things to have their single
341.36,4.8,instance you know be more performant
343.68,3.44,when it comes to query because you see a
346.16,2.319,lot of
347.12,2.88,a lot of people
348.479,4.801,our engineers
350.0,4.639,are hurry up to scale right and spend
353.28,3.759,more money
354.639,4.641,to start to work with the distributor
357.039,3.121,without actually while their query is
359.28,4.479,actually
360.16,4.4,using 500 of their cpu and then doing
363.759,3.841,like
364.56,4.079,a million logical reads you know where
367.6,3.84,they can
368.639,4.56,tweak it a little bit and
371.44,5.28,tweak it and tune the database a little
373.199,5.521,bit understand their queries so they can
376.72,5.199,have or even you know
378.72,4.88,lower that cost you know as a result but
381.919,4.321,we don't think this way anymore we
383.6,4.24,always take the shortcut unfortunately
386.24,5.84,but regardless so
387.84,6.479,usually advanced and adept dpas try to
392.08,4.959,optimize a single coin as a result if
394.319,6.0,you if you can get a query to consume
397.039,6.16,less cpu even if it's a small query
400.319,5.44,scaling that query right will eventually
403.199,4.72,give you better scaling on your instance
405.759,3.761,but that's not our topic that's another
407.919,4.641,day but let's say you reached the state
409.52,5.6,where you exhausted all your options you
412.56,5.199,know when it comes to a single instance
415.12,4.799,right then you moved he says hey i have
417.759,3.84,to move to and uh distribute the system
419.919,2.881,it's just too large
421.599,3.6,you gotta move
422.8,4.08,so people what they did says okay i have
425.199,4.241,a key
426.88,5.599,and now i don't know which i have
429.44,5.039,10 servers right i don't know where this
432.479,4.081,key lives in distant server environment
434.479,4.241,so i'll say all right so we're going to
436.56,4.16,do let's say i have four server a
438.72,5.36,cluster with four servers and i want to
440.72,8.24,distribute my values across these four
444.08,6.48,servers so server s0 s1 s2 and s3 right
448.96,4.0,what we're gonna do is like giving the
450.56,5.039,key i need to know the server
452.96,5.12,name the server ip and that's something
455.599,5.921,that we are introducing as a problem
458.08,5.36,like we introduced a friction that
461.52,4.0,didn't exist before first
463.44,4.96,previously so i just one server we know
465.52,4.799,the server right but now we have to
468.4,4.16,figure out from the key we have to
470.319,4.72,figure out the iprs of the server to
472.56,3.919,connect to in order where our key
475.039,4.641,actually exists
476.479,5.28,that answer can be answered using a very
479.68,3.919,simple hashing function so we're going
481.759,4.641,to hash the value let's say i'm have
483.599,4.88,value number four uh gonna hash it get
486.4,4.479,some value and then that value we're
488.479,4.881,gonna do modulo number four and that
490.879,5.521,gives you server zero so
493.36,4.8,store server zero right here right
496.4,3.68,in this case right so four modulo four
498.16,4.08,is zero and then okay how about key
500.08,4.72,number five right
502.24,4.799,or even whatever that key used to be
504.8,4.399,maybe let's say it's a it's a blue or
507.039,4.321,red right red you're gonna hash it get
509.199,4.32,that value number five which is a number
511.36,3.28,and then five modulo four will give you
513.519,4.0,s1
514.64,3.92,and s1 will go right here right so
517.519,3.841,five
518.56,5.68,right lives in s1 and same thing 6 will
521.36,5.28,live in s2 and 7 will live in
524.24,4.96,s3 you're just gonna do module four
526.64,4.319,because four is your server pool size
529.2,3.759,right and then let's say going back
530.959,4.081,let's say eight then eight module four
532.959,4.081,oh so back to zero and then
535.04,4.799,use get the point which is which works
537.04,6.64,perfectly from the key
539.839,3.841,i was able to figure out
543.92,4.08,the server
545.04,6.479,so cost is zero is nothing here's we
548.0,5.2,solve distributed system right there
551.519,4.561,here's one problem though as long as you
553.2,5.759,have four servers your love is beautiful
556.08,5.199,you don't have to worry about anything
558.959,3.921,but now
561.279,3.281,even those four servers reach their
562.88,3.84,limit again
564.56,4.8,whatever reason limit that means you're
566.72,5.92,you're at the globe scale you know you
569.36,4.72,have so many users right so
572.64,3.68,to me
574.08,4.4,that i need four machine more than four
576.32,4.32,machines database instance that means
578.48,3.28,i'm at the global scale and i have
580.64,3.44,users
581.76,4.4,left and right millions of heads you
584.08,4.48,know so that's the scale we're talking
586.16,4.88,about right so i say okay okay all right
588.56,8.16,let's just add another server
591.04,8.479,server 4 s4 so we have s0 s1 s2 s3 and
596.72,4.0,s4 sounds good
599.519,3.041,comes back to the problem with hashing
600.72,4.16,tables
602.56,6.48,the moment you change the size
604.88,6.72,the whatever value where original so
609.04,5.6,the values their original key values are
611.6,4.32,now all shuffled right previously value
614.64,5.04,number four
615.92,5.76,used you do for modulo 4 the key four
619.68,6.56,used to live on server s0 because 4
621.68,6.48,modulo 4 is zero but now for modulo 5
626.24,3.039,which is now the new server we have five
628.16,3.2,servers
629.279,4.56,is actually gives you value four so it's
631.36,4.88,now as an s4
633.839,3.521,so now what you need to do is like move
636.24,1.92,the key
637.36,4.56,with
638.16,5.28,a value four from the server zero to
641.92,4.56,server four
643.44,4.88,and now you have to move everything else
646.48,4.479,and this is this is basically the same
648.32,5.04,thing five modulo five right the server
650.959,3.841,five the the key four will move to
653.36,5.039,server four
654.8,6.719,the key eight will move to server three
658.399,5.361,the key 5 will move to server 0 the key
661.519,5.281,6 will move to server
663.76,5.92,1 and the key 7 will move to the key 7
666.8,6.56,will move to s1 right so everything will
669.68,4.96,be shuffled and the operation of adding
673.36,5.039,a new server
674.64,6.24,will cost us a huge amount of effort
678.399,4.401,to kind of shuffle things around so look
680.88,4.0,think about networking think about
682.8,4.719,database usage just to add another
684.88,6.16,server to not only bothering one server
687.519,5.121,you're bothering the entire cluster with
691.04,3.84,your operation because you have to
692.64,4.4,shuffle things around right because your
694.88,4.0,key no longer maps
697.04,4.56,so what what people think what the smart
698.88,4.32,people say okay let's invent something
701.6,4.08,that might solve this problem which is
703.2,6.0,called consistent hashing so how does it
705.68,6.48,really work so they go they went back to
709.2,5.28,the idea of having so they went back to
712.16,4.32,idea the core idea
714.48,5.12,we use the index
716.48,3.919,as the server names here right
719.6,3.359,let's
720.399,4.801,flip this let's change this a little bit
722.959,4.641,let's not be very discreet like oh
725.2,4.079,server 0 1 2 3 4.
727.6,3.12,let's build
729.279,3.041,a ring
730.72,3.919,let's actually build a ring of these
732.32,4.319,servers all right so
734.639,4.241,instead they think of this idea as an
736.639,4.0,actual rank as an actual circle so
738.88,4.079,values go back
740.639,4.32,right and
742.959,4.56,remember a lot of people thought a lot
744.959,4.32,about this to solve this problem and the
747.519,3.12,key here is
749.279,4.161,instead of
750.639,3.921,the output of the key hash going to a
753.44,4.079,server
754.56,5.12,we're going to approximate it you know
757.519,4.481,by by using this
759.68,4.719,concept of the rank so let's take an
762.0,5.68,example so clarify the first thing we're
764.399,5.521,going to do is the servers themselves
767.68,4.8,we need to fit them on the ring which
769.92,4.96,this is something we didn't do before so
772.48,4.0,the ring is think of this rank as a
774.88,3.519,circle so
776.48,4.88,the degrees based on the degrees this is
778.399,4.801,a 360 degrees right so server let's say
781.36,3.279,server one you're going to do a modulo
783.2,3.28,360.
784.639,4.481,let's say we're gonna get a zero right
786.48,5.2,so we're gonna put servers server one
789.12,5.12,and as we're gonna call it s0 based on
791.68,4.64,the degree here right and then let's say
794.24,5.279,server two ip address ten zero zero
796.32,4.72,three modulo 360 we got 90 right and
799.519,4.161,again i'm picking
801.04,4.64,i'm picking values that are so
803.68,3.599,rounded up this is just for example
805.68,4.159,you're never going to get you're hardly
807.279,5.68,going to get s 90 right exactly right
809.839,5.521,you're going to probably get x is 27
812.959,4.88,right but yeah x90
815.36,5.36,same thing server 3 or server 4 you're
817.839,5.56,going to get s 180 if after you do that
820.72,9.04,and then server 3 gonna get
823.399,8.761,s2270 we have s0 s90 s180 and s270
829.76,4.319,you know that's that completes an actual
832.16,3.84,range and for people listening in the
834.079,4.161,podcast think of this as an actual ring
836.0,4.56,with the values for servers and each
838.24,5.92,corner effectively so why are we doing
840.56,5.76,this the beauty here is we have values
844.16,4.64,and this is the key here
846.32,4.639,let's have a key value of
848.8,3.12,a thousand same thing you're gonna do
850.959,4.24,right
851.92,5.68,the thousand the key value thousand
855.199,4.241,right however this key exists maybe it
857.6,4.32,was blue and then you did a hash and
859.44,4.72,then got you got the number thousand you
861.92,4.0,take that thousand right and you do a
864.16,4.16,modular 360.
865.92,4.08,will you get an actual server
868.32,3.04,immediately the server index no you're
870.0,3.12,not going to get that
871.36,4.64,so now let's let's actually put it in an
873.12,3.6,actual example right here right
876.0,2.639,so
876.72,4.32,now i'm about to insert the value i'm
878.639,5.521,going to insert a new key
881.04,4.72,value 1 500. that's that's my key right
884.16,3.44,there so what you're going to do is
885.76,4.16,you're going to do modulo 360 which is
887.6,4.32,the circle again
889.92,4.719,don't don't be very
891.92,4.159,uh specific on the the value 360. you
894.639,3.601,can double this and double this and
896.079,4.32,double this to get more values but i'm
898.24,3.039,again this is just an example so 360
900.399,2.401,here
901.279,3.521,so if i take
902.8,4.24,1500 right
904.8,3.52,and modulo 360
907.04,3.44,i'm going to get
908.32,4.16,a value of 60.
910.48,5.68,if you think about it s60 doesn't exist
912.48,6.08,there is no server marked 60 but
916.16,6.4,here's a trick we do have a server mark
918.56,6.56,as zero and we have an s90 so s60 really
922.56,5.12,fits between the 0 and the 90. and what
925.12,4.32,you do is you pick the next one so 60 if
927.68,3.92,it's between 0 and 90
929.44,4.8,immediately so that key will go to the
931.6,4.72,next value which is s90 and that's
934.24,4.32,that's how you do it basically
936.32,4.959,now
938.56,5.76,visually this is easy to understand
941.279,4.56,right computationally this is not as
944.32,3.439,simple because
945.839,4.081,what does that mean between 0 and 90 i
947.759,6.08,have i have four servers that's that's
949.92,6.32,easy to find where where your value
953.839,4.721,how 60 fits between 0 and 90 is actually
956.24,4.159,computational and that's another binary
958.56,3.92,search to actually find that value
960.399,4.081,that's a little bit outscale outside the
962.48,5.12,scope of this video but now once we have
964.48,4.159,that value we have the 60 now okay oh 60
967.6,3.76,is like
968.639,5.361,what's right after 60 is 90.
971.36,4.159,now okay so the value of 1500 fits on
974.0,4.079,server s90
975.519,5.12,that's how we solve it so
978.079,4.641,by doing this scan
980.639,6.0,what is the next one
982.72,6.96,we really removed that discrete value
986.639,7.2,lookup you know we instead changed it
989.68,6.159,with a scan and the beauty of this scan
993.839,4.081,is going to save us a lot of things in
995.839,4.161,the future let's continue these examples
997.92,5.039,all right 1500 let's take another
1000.0,6.88,example as a 2000 2000 modular 360 is
1002.959,7.201,200 200 fits between server s180 and
1006.88,6.879,server s270 again 180 and 270 think of
1010.16,5.76,the as degrees right so right there in
1013.759,5.52,this case okay what's exactly right
1015.92,5.76,after 200 it's 270 so 2000 less than
1019.279,3.601,270. okay so
1021.68,3.68,think of it like you're looking at
1022.88,3.6,clockwise so whatever is the next value
1025.36,4.0,you're going to get that and then you
1026.48,4.24,put another value say 3000 modular 360.
1029.36,3.92,that's 120
1030.72,6.0,120 if it's between server 90 and server
1033.28,5.919,180 select moves directly to the 180 and
1036.72,4.719,then you store the value 3000 there how
1039.199,4.72,about a thousand thousand modular 360 is
1041.439,3.52,actually gives you 280 wait a minute 280
1043.919,3.52,is the
1044.959,4.441,there are no server after the last
1047.439,4.961,server the largest value is actually
1049.4,5.48,s270 there is no larger after that
1052.4,5.2,right there is no larger than two server
1054.88,3.679,217 this is values 280. so what do you
1057.6,3.28,do
1058.559,4.961,if there's no larger values you go back
1060.88,4.799,to the circle right and this is very
1063.52,6.32,nicely when you actually draw the circle
1065.679,7.201,you see that s 280 is between s270 and
1069.84,4.56,s0 so you immediately go and put the
1072.88,4.56,value 1000
1074.4,5.2,in server 0 and that's how you build the
1077.44,4.4,ring let's take another example for
1079.6,5.76,completeness here uh four thousand four
1081.84,7.52,thousand modulo 360 it gives you 40 40
1085.36,7.04,is between 0 and 90 right oh that's very
1089.36,6.88,nice so for so now we have two keys
1092.4,6.08,slips in server s90 in this case
1096.24,5.84,yeah that's very interesting
1098.48,6.8,let's spice things up now what if
1102.08,6.08,i added a new server here look at the
1105.28,5.279,beauty of this here now if i add a new
1108.16,6.08,server here let's say it's ipa this is
1110.559,8.0,at 10 0 0 13 right
1114.24,8.08,i do it modulo 3 360 and i got 50. so
1118.559,7.841,now my server is actually s50 fits right
1122.32,5.84,between s0 and s90 keep that in mind
1126.4,4.72,now
1128.16,6.639,things change because we
1131.12,6.559,still need to move data around but not
1134.799,4.0,as much let's figure that out how much
1137.679,4.721,data
1138.799,6.481,i need to move around well the algorithm
1142.4,5.519,goes like this right
1145.28,4.88,remember if you have values if you add
1147.919,4.961,value says 50 in this case anything
1150.16,6.08,between the 0 and the 50
1152.88,5.12,really needs to be fit in server 50
1156.24,3.52,right because that's the algorithm
1158.0,3.2,that's the range here that we're looking
1159.76,4.56,at right here
1161.2,5.44,and so if you the the algorithms look
1164.32,4.8,like this like okay so
1166.64,4.08,what is the server right after me well
1169.12,3.28,the server right after me is right here
1170.72,5.28,is 90 right
1172.4,6.399,so let's query that server find out
1176.0,4.0,all the hash values and out all the hash
1178.799,3.601,values
1180.0,5.2,where the actual hash value is less than
1182.4,5.76,40 right because s90 would have stored
1185.2,5.44,everything between 0 and 90 right so
1188.16,6.0,find out everything that is less than
1190.64,4.32,50 because i i should store these now
1194.16,3.84,right
1194.96,5.04,so we found one entry which is 40. oh 40
1198.0,4.799,doesn't belong 90 anymore so go ahead
1200.0,4.559,and talk to server 90 establish a
1202.799,3.36,communication could be tcp could be
1204.559,4.48,anything and then start moving data
1206.159,5.361,around right hey it's 90. and do you
1209.039,4.64,have anything with a hash value that is
1211.52,4.56,less than 40 is this less than 50 which
1213.679,5.521,is me oh yeah i have this value
1216.08,5.52,move it to me and as a result we just
1219.2,4.08,established the data here so now think
1221.6,4.559,of it as
1223.28,5.68,as i add another server
1226.159,5.041,the only change is my neighbor really
1228.96,4.32,i'm only gonna bother my neighbor and
1231.2,4.719,it's only the neighbor right after me
1233.28,4.32,right that's that's what i'm gonna
1235.919,2.721,do in this case right
1237.6,3.68,and
1238.64,4.48,so instead of actually
1241.28,4.879,bothering all the servers in my cluster
1243.12,5.28,i'm only bothering one server so that's
1246.159,5.121,much much much better than actual
1248.4,3.759,hashing but still there is a cost to it
1251.28,3.44,right
1252.159,5.52,there is complexity you need to build
1254.72,5.839,all that out what if the operation
1257.679,5.36,failed how do you roll back what if do
1260.559,5.521,you add the server anyway what if one of
1263.039,5.201,the keys didn't transmit so we're adding
1266.08,5.599,so much complexity so distributed
1268.24,5.679,systems are not easy you guys right
1271.679,4.24,even if you think about it let's take
1273.919,4.0,another example where we're removing a
1275.919,4.441,server if we go back to our original
1277.919,6.401,case where we have s0
1280.36,7.16,s90 s180 and s27 and let's say i'm going
1284.32,5.92,to remove s90 altogether so now what
1287.52,7.36,happens here if you remove s90 then
1290.24,6.48,anything that s90 had must go to s180 if
1294.88,4.64,you think about it right because any
1296.72,4.64,value so now what what happens is the
1299.52,2.96,operation should go okay remove server
1301.36,3.36,s90
1302.48,4.559,that operation that we need to do right
1304.72,4.48,i'm gonna remove that physically remove
1307.039,4.321,it not talking about a crash that's a
1309.2,3.839,completely different story right
1311.36,3.12,crash you don't even have time to move
1313.039,2.561,anything right
1314.48,2.8,so if you
1315.6,3.68,that's why you have to have redundancy
1317.28,4.48,that's another complication right there
1319.28,4.399,but if you have a physical operation
1321.76,5.68,that say okay i want to remove this for
1323.679,7.521,maintenance remove s90 well it's 90
1327.44,5.68,holes and all values between 0 and 90 so
1331.2,4.8,all of those should go directly to the
1333.12,6.48,server right after me clockwise which is
1336.0,6.4,180 so remove all those puppies
1339.6,4.8,and stick them to where to server 180.
1342.4,4.0,that's a very expensive operation as
1344.4,4.08,well so if you think about it
1346.4,4.0,consistent hashing are powerful is
1348.48,4.079,powerful the algorithm of consistency
1350.4,4.88,are very powerful but the limitation
1352.559,6.081,here becomes you still need to move data
1355.28,6.16,around and the more data you have you
1358.64,6.0,know in these instances then the
1361.44,5.44,transmit of these will take more time so
1364.64,5.519,adding or removing server is actually
1366.88,5.279,not a trivial operation you know and
1370.159,4.081,then you really think need to think
1372.159,4.081,about
1374.24,3.919,another thing that is called
1376.24,4.0,replication you need to duplicate this
1378.159,3.921,data as much as possible because a
1380.24,3.76,server might crash so you need to have a
1382.08,4.24,backup so
1384.0,6.24,just using this algorithm blindly is not
1386.32,5.52,enough you have to cater for crashes you
1390.24,2.799,know and as a result you have to have a
1391.84,2.959,backup oh if this server is not
1393.039,4.241,available let's let's have a mapping
1394.799,5.12,server that actually
1397.28,4.879,directly copies that data immediately
1399.919,4.321,right so that's what you do you have to
1402.159,3.281,do that well what if two servers map to
1404.24,3.36,the same
1405.44,4.96,hash you can't have it if you have a lot
1407.6,4.559,of more than 360 servers you're gonna
1410.4,4.639,you're bound to have the value that fits
1412.159,4.801,in the same server and i'm not sure what
1415.039,3.76,you can do here you can what you can do
1416.96,3.36,is like i suppose in this case you can
1418.799,4.88,treat it as a
1420.32,5.12,as a replication so you have like a a
1423.679,4.321,backup scenario where we have this
1425.44,3.92,server you can either put it in both
1428.0,3.2,right that was an episode of the
1429.36,3.6,consistent hashing hope you enjoyed this
1431.2,4.479,video i'm gonna see on the next one guys
1432.96,2.719,thousand goodbye
